![Wrapper](wrapper.png)

# C++ и ничего более

# О книге

Для кго предназначена книга?
> Для тех, кто уже программировал (жел. на Python, JavaSctipt и им подобным)

Что если я полный ноль в программировании?

> Прочтите "С++ from Scratch (A.Bozich)" и приступите к этой книге



# Соденжание

> ___
> ## [Глава 1. Основы основ.]()
> ___
> * [Первая программа.]()
> * [Выражения.]()
> ___
> * [Типы данных.]()
> * [Переменные.]()
> * [Константы.]()
> ___
> * [Арифметические операторы.]()
> * [Операторы присваивания.]()
> * [Приоритеты операторов.]()
> ___
> * [Ввод / Вывод.]()
> ___
> * [Условия, условные операторы.]()
> * [Циклы.]()
> ___ 
> * [Массивы, их методы.]()
> * [Строки, их методы.]()
> ___ 
> * [Функции.]()
> ___
> * [ООП (Поверхносно).]()
> * [Модули.]()
> ___
> * [Также.]()
> * [Подитожим.]()
> ___

Приступим!

# Глава 1. Основы основ

# Первая программа или Hello, World!

Следующий код выведет на экран "Hello, World"

``` cpp
#include <iostream>

int main(int argc, char * argv[]) {
    std::cout << “Hello, World“ << std::endl;

    return 0;
}
```
Мы (вы) написали первую программу на С++. Давайте разберём этот код !

``` cpp
// Кстати, это комментарий. Компьютер его игнорирует. Он записуеться двумя косыми чертами

#include <iostream> // подключает ввод-вывод

int main(int argc, char * argv[]) {
    // функция main. Сама программа (?)
    // Где argc — количество аргументов
    // Где argv — аргументы функции

    std::cout << “Hello, World“ << std::endl;
    // std::cout это вывод, std::endl — это „Enter“ (\n).

    // Еще про std: его можно не вписывать каждый раз написав после "инклудов":
    // using namespace std;


    // Hello, World Это выводимая строка
    return 0; 
    // ^^^ 
    // результат функции main 0 говорит о том, что программа была завершена успешно
} // закрывающая фигурная скобка, завершение main (обязательно)
```

# Выражения

> Что такое выражение. Считайте - это команда. То есть, например, создание переменной (`int var = 1;`) это выражение. Вывод чего-то на экран - это тоже выражение. В Python выражения иногда называют логическими строками. Комментарий не являеться выражением (компьютер его игнорирует)

> После каждого выражения ставиться **точка с запятой ;**

# Типы данных

Основные типы данных:

``` cpp
bool // логическое значение true, false
int // целое число в диапазоне от −2 147 483 648 до 2 147 483 647 (пи 4 батах = 32 бита)
double // число с плавающей точкой (дробное) в диапазоне +/- 1.7E-308 до 1.7E+308 (64 бит)
float // это Double, но более точное (в диапазоне +/- 3.4E-38 до 3.4E+38, 32 бита)
string // только при #include <string>, соответственно, строка (массив символов)
```

Все типы данных (для особо дотошных):

**[К следующему разделу](#Переменные)**

> bool: логический тип. Может принимать одну из двух значений true (истина) и false (ложь). Размер занимаемой памяти для этого типа точно не определен.

> char: представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255

> signed char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от -128 до 127

> unsigned char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255

> wchar_t: представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)

> char16_t: представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535

> char32_t: представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295

> short: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).

> Данный тип также имеет синонимы short int, signed short int, signed short.

> unsigned short: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).

> Данный тип также имеет синоним unsigned short int.

> int: представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах). Но в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long

> Данный тип имеет синонимы signed int и signed.

> unsigned int: представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).

> В качестве синонима этого типа может использоваться unsigned

> long: представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647. Занимает в памяти 4 байта (32 бита).

> У данного типа также есть синонимы long int, signed long int и signed long

> unsigned long: представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).

> Имеет синоним unsigned long int.

> long long: представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт (64 бита).

> Имеет синонимы long long int, signed long long int и signed long long.

> unsigned long long: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт (64 бита).

> Имеет синоним unsigned long long int.

> float: представляет вещественное число ординарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)

> double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)

> long double: представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.

> void: тип без значения

# Переменные

Переменные, например в Python, создаються без ключевых
слов (за искл. Global):

```python
value = 12 // переменная value с значением # 12, тип (авто) - Int
```

А переменные в JavaScript создаються с помощью клучевого
слова var, let (const для констант):
``` javascript
var num = 13 // Number
let num_2 = 14 // Number
```

> Переменные же в С++ создаються следующей формулой:

``` cpp
тип название = значение;
```
> Значение можно присваивать не сразу, но всё же можно присвоить сразу (...)

``` cpp
int num = 12;
// То же что:
int num;
num = 12;
```

## Названия переменных.

Правила те же, что и в Python/JS. Но всё же, повторю: 
> Можно использовать все символы UTF-8, также «_» и числа, но числа не должны быть в начале.

То есть
``` cpp
int num_1; // OK
int 2num; // WRONG
int _2num; // OK
int num2; // OK
int num; // OK
int _2; // OK
```

> Переменной можно присваивать значение когда угодно, но есле она обьявлена. В отличии от [Констант]().

# Константы

> Константа - это "переменная", которая не маняет значение.

> Константы обьявляються как переменные, но с const в начале выражения. И им значение присваеваеться только один раз. То есть:

``` cpp
const int num = 10 // num = 10
num = 12 // ошибка! 
```

# Арифметические операторы


Арифметические операторы в С++:

| Оператор             | Символ | Пример | Операция |
|----------------------|:------:|:-----:|----------:|
| Сложение             | +      | x + y  | x плюс у |
| Вычитание            | -      | x - y  | х минус у |
| Умножение            | *      | x * y  | х умножить на у |
| Деление              | /      | x / y  | х делить на у |
| Остаток при делении  | %      | x % y  | Остаток от деления х на у |

___

> Также В С++ существует унарный +/-, и бинарный +/-

> Простыми словами: унарный +/- это знак числа (число с унарным минусом отрицательное, с плюсом - положительное).

| Оператор      | Символ | Пример | Значение |
| --------------|:------:|:------:|---------:|
| Унарный плюс  | +      | (+x)   | Значение х
| Унарный минус | -      | (-x)   | Отрицательное значение х

___
> Скобки желательно ставить почти всегда при использовании унарного плюса\минуса. Это для того, то-бы компилятор не спутал унарный знак с бинарным (или с инкрементом\декрементом).

# Операторы присваивания


| Оператор                          | Символ | Пример | Операция                                   | Другими словами |
|-----------------------------------|:------:|:------:|:------------------------------------------:|----------------:|
| Присваивание                      | =      | x = y  | х присваиваеться значение y                | х становиться равно y
| Сложение с присваиванием          | +=     | x += y | х присваиваеться x + y                     | х = х + у
| Вычитание с присваиванием         | -=     | x -= y | х присваиваеться х - у                     | х = х - у
| Умножение с присваиванием         | *=     | x *= y | х присваиваеться х * у                     | х = х * у
| Деление с присваиванием           | /=     | x /= y | х присваиваеться х / у                     | х = х / у
| Остаток от деления с присваиванием| %=     | x %= y | х присваиваеться остаток при х / у (х % у) | х = х / у
| Инкремент         | ++     | x++ или ++х| x присваиваеться значение x + 1            | x += 1          |
| Декремент         | --     | x-- или --х| x присваиваеться значение x - 1            | x -= 1          |

> Ин(де-)кремент используеться для увеличения/уменьшения значения переменной на 1. Но это меняет значение самой переменной на  `x + 1`.

#  Приоритеты операторов в С++


> Чем ниже ассоциативность, тем приоритетнее оператор (тем первее он начнет свою работу относительно других в *этом*/*текущем* выражении)

> Сдесь таблица *всех* операторов С++ с их приоритетами. Найдите вам известные и изучите их. (спасибо ravesli.com за таблицу)

<table class="tabluc" style="margin-bottom: 15px;"><tbody><tr><td><strong><span class="raznui_kolir_td">Ассоциативность</span></strong></td><td><strong><span class="raznui_kolir_td">Оператор</span></strong></td><td><strong><span class="raznui_kolir_td">Описание</span></strong></td><td><strong><span class="raznui_kolir_td">Пример</span></strong></td></tr><tr><td rowspan="2">1.&nbsp;Нет</td><td>::</td><td>Глобальная область видимости (унарный)</td><td>::name</td></tr><tr><td>::</td><td>Область видимости класса&nbsp;(бинарный)</td><td>class_name::member_name</td></tr><tr><td rowspan="16">2. L -&gt; R</td><td>()</td><td>Круглые скобки</td><td>(expression)</td></tr><tr><td>()</td><td>Вызов функции</td><td>function_name(parameters)</td></tr><tr><td>()</td><td>Инициализация</td><td>type name(expression)</td></tr><tr><td>{}</td><td>uniform-инициализация (C++11)</td><td>type name{expression}</td></tr><tr><td>type()</td><td>Конвертация типа</td><td>new_type(expression)</td></tr><tr><td>type{}</td><td>Конвертация типа (C++11)</td><td>new_type{expression}</td></tr><tr><td>[]</td><td>Индекс массива</td><td>pointer[expression]</td></tr><tr><td>.</td><td>Доступ к члену объекта</td><td>object.member_name</td></tr><tr><td>-&gt;</td><td>Доступ к члену объекта через указатель</td><td>object_pointer-&gt;member_name</td></tr><tr><td>++</td><td>Пост-инкремент</td><td>lvalue++</td></tr><tr><td>––</td><td>Пост-декремент</td><td>lvalue––</td></tr><tr><td>typeid</td><td>Информация о типе во время выполнения</td><td>typeid(type) or typeid(expression)</td></tr><tr><td>const_cast</td><td>Cast away const</td><td>const_cast(expression)</td></tr><tr><td>dynamic_cast</td><td>Type-checked cast во время выполнения</td><td>dynamic_cast(expression)</td></tr><tr><td>reinterpret_cast</td><td>Конвертация одного типа в другой</td><td>reinterpret_cast(expression)</td></tr><tr><td>static_cast</td><td>Type-checked cast во время компиляции</td><td>static_cast(expression)</td></tr><tr><td rowspan="14">3. R -&gt; L</td><td>+</td><td>Унарный&nbsp;плюс</td><td>+expression</td></tr><tr><td>—</td><td>Унарный&nbsp;минус</td><td>-expression</td></tr><tr><td>++</td><td>Пре-инкремент</td><td>++lvalue</td></tr><tr><td>––</td><td>Пре-декремент</td><td>––lvalue</td></tr><tr><td>!</td><td>Логическое&nbsp;НЕ (NOT)</td><td>!expression</td></tr><tr><td>~</td><td>Побитовое&nbsp;НЕ (NOT)</td><td>~expression</td></tr><tr><td>(type)</td><td>C-style cast</td><td>(new_type)expression</td></tr><tr><td>sizeof</td><td>Размер в&nbsp;байтах</td><td>sizeof(type) or sizeof(expression)</td></tr><tr><td>&amp;</td><td>Адрес</td><td>&amp;lvalue</td></tr><tr><td>*</td><td>Разыменование</td><td>*expression</td></tr><tr><td>new</td><td>Динамическое выделение памяти</td><td>new type</td></tr><tr><td>new[]</td><td>Динамическое выделение массива</td><td>new type[expression]</td></tr><tr><td>delete</td><td>Динамическое удаление памяти</td><td>delete pointer</td></tr><tr><td>delete[]</td><td>Динамическое удаление массива</td><td>delete[] pointer</td></tr><tr><td rowspan="2">4. L -&gt; R</td><td>-&gt;*</td><td>Member pointer selector</td><td>object_pointer-&gt;*pointer_to_member</td></tr><tr><td>.*</td><td>Member object selector</td><td>object.*pointer_to_member</td></tr><tr><td rowspan="3">5. L -&gt; R</td><td>*</td><td>Умножение</td><td>expression * expression</td></tr><tr><td>/</td><td>Деление</td><td>expression / expression</td></tr><tr><td>%</td><td>Деление с остатком</td><td>expression % expression</td></tr><tr><td rowspan="2">6. L -&gt; R</td><td>+</td><td>Сложение</td><td>expression + expression</td></tr><tr><td>—</td><td>Вычитание</td><td>expression — expression</td></tr><tr><td rowspan="2">7. L -&gt; R</td><td>&lt;&lt;</td><td>Побитовый сдвиг влево</td><td>expression &lt;&lt; expression</td></tr><tr><td>&gt;&gt;</td><td>Побитовый сдвиг&nbsp;вправо</td><td>expression &gt;&gt; expression</td></tr><tr><td rowspan="4">8. L -&gt; R</td><td>&lt;</td><td>Сравнение: меньше чем</td><td>expression &lt; expression</td></tr><tr><td>&lt;=</td><td>Сравнение: меньше чем или равно</td><td>expression &lt;=expression</td></tr><tr><td>&gt;</td><td>Сравнение: больше чем</td><td>expression &gt; expression</td></tr><tr><td>&gt;=</td><td>Сравнение: больше чем или равно</td><td>expression &gt;=expression</td></tr><tr><td rowspan="2">9. L -&gt; R</td><td>==</td><td>Равно</td><td>expression==expression</td></tr><tr><td>!=</td><td>Не равно</td><td>expression !=expression</td></tr><tr><td>10. L -&gt; R</td><td>&amp;</td><td>Побитовое И (AND)</td><td>expression &amp; expression</td></tr><tr><td>11. L -&gt; R</td><td>^</td><td>Побитовое исключающее ИЛИ (XOR)</td><td>expression ^ expression</td></tr><tr><td>12. L -&gt; R</td><td>|</td><td>Побитовое ИЛИ (OR)</td><td>expression | expression</td></tr><tr><td>13. L -&gt; R</td><td>&amp;&amp;</td><td>Логическое&nbsp;И (AND)</td><td>expression &amp;&amp; expression</td></tr><tr><td>14. L -&gt; R</td><td>||</td><td>Логическое ИЛИ (OR)</td><td>expression || expression</td></tr><tr><td rowspan="12">15. R -&gt; L</td><td>?:</td><td>Тернарный условный оператор</td><td>expression ? expression : expression</td></tr><tr><td>=</td><td>Присваивание</td><td>lvalue=expression</td></tr><tr><td>*=</td><td>Умножение с присваиванием</td><td>lvalue *=expression</td></tr><tr><td>/=</td><td>Деление с присваиванием</td><td>lvalue /=expression</td></tr><tr><td>%=</td><td>Деление с остатком и с присваиванием</td><td>lvalue %=expression</td></tr><tr><td>+=</td><td>Сложение с присваиванием</td><td>lvalue +=expression</td></tr><tr><td>-=</td><td>Вычитание с присваиванием</td><td>lvalue -=expression</td></tr><tr><td>&lt;&lt;=</td><td>Присваивание с побитовым сдвигом влево</td><td>lvalue &lt;&lt;=expression</td></tr><tr><td>&gt;&gt;=</td><td>Присваивание с побитовым сдвигом вправо</td><td>lvalue &gt;&gt;=expression</td></tr><tr><td>&amp;=</td><td>Присваивание с побитовой операцией И (AND)</td><td>lvalue &amp;=expression</td></tr><tr><td>|=</td><td>Присваивание с побитовой операцией&nbsp;ИЛИ (OR)</td><td>lvalue |=expression</td></tr><tr><td>^=</td><td>Присваивание с побитовой операцией «Исключающее ИЛИ» (XOR)</td><td>lvalue ^=expression</td></tr><tr><td>16. R -&gt; L</td><td>throw</td><td>Генерация исключения</td><td>throw expression</td></tr><tr><td>17. L -&gt; R</td><td>,</td><td>Оператор Запятая</td><td>expression, expression</td></tr></tbody></table>

# Ввод / Вывод

# Вывод данных в консоль

Запустите следующий код:

``` cpp
#include <iostream> // для ввода-вывода
#include <string> // строки
using namespace std;

int main(int argc, char * argv[]) {
    string str = "I am string";
    float num = 11.5f; // f обязательно при float
    cout << "String says: \"" << str;
    cout << "\". Number says: \"My value is ";
    cout << num << "\"";
    cout << endl;
    return 0;
}
```

Вывод должен быть `String says: "I am string". Number says: "My value
is 11.5"`

## Разбор кода

``` cpp
#include <iostream> // для ввода-вывода
#include <string> // строки
using namespace std;

int main(int argc, char * argv[]) {
    string str = "I am string"; // Простая строка
    float num = 11.5f; // f обязательно при float

    cout << "String says: \"" << str;
    // Выводим *строку*
    cout << "\". Number says: \"My value is ";
    // Выводим другую строку
    cout << num << "\"";
    // Вывод число со строкой
    cout << endl;
    // Переход на новую строку
    return 0;
    // Программа завершена успешно
}
```

> Вы заметили `\` в выводимых строках? Мы изучим форматирование строк в соответствующем разделе ["Строки"]()

> Что такое `cout`? По принципу нужно писать `std::cout`, но так как мы написали `using namespace std;`, нам будет выводить данные удобнее.

> Что означает `<<`? Это как знак "вставки".

То есть простыми словами: 

> `cout`- это вывод в консоли. А`<<` вставляет вежи справа в тот самый вывод.

> `endl` - это переход на новую строку (\n)

# Ввод двнных с клавиатуры

Запустите:

``` cpp
#include <iostream> // для ввода-вывода
#include <string> // строки
using namespace std; // Удобный ввод-вывод данных


int main(int argc, char * argv[]) {
    double num; double num2;
    // Числа


    cout << "Write number 1: ";
    cin >> num; // Ввод данных в num
    cout << "Number 2: ";
    cin >> num2; // Ввод в num2
    cout << num << " + " << num2 << " = ";
    cout << num + num2; // Вывод суммы
    cout << endl; // Переход на н.с.

    return 0; // Программа завершена успешно
}
```

> Как вы заметели, `cin` используеться с `>>` а не с `<<`. То есть значение из `cin` вставляеться в переменную.

# Условия

Помните условия в Python/JavaScript? В С++ они очень схожи, так как работают по одному ринципу:

![Если (условие) = true, то выполнить блок кода, иначе - игнорировать его и продолжить выполнение программы](ifelse.png)

> Условие, простыми словами, это логическое значение (bool; true, false). Оно может иметь внутри себя операторы (>, <, =, лог. ИЛИ лог. И, итп.). 

Синтаксис типичного условия С++:

``` cpp
int a = 12;
int b = ++a * 2;

if (--a == b/2-2) {
    cout << "True";
}
else if (++a == b/2) {
    cout << "Second True";
}
else {
    cout << "False";
}

cout << endl;
```

Вывелось `Second True`. Давайте разберём, почему.


``` cpp
// Две переменные
int a = 12;
int b = ++a * 2; 
// b = (a+1) * 2 = 26
// а = 13 (++а)

if (--a == b/2-2) { // a теперь = 12
    cout << "True";
}
else if (++a == b/2) { // теперь а снова 13
    cout << "Second True";
}
else {
    cout << "False";
}

cout << endl;
```

> Думаю, вы заметили, насколько "чуствительно" С++ относиться к инкременту/декременту!

Вопросы:

Почему два знака равенства?

> В С++ существуют следующие основные условные операторы:

|Оператор | Знак | Пример | Также |
|---------|------|--------|--|
|Больше|>|1 > 2 (false); 2>2 (false) |
|Меньше|<|1 < 2 (true); 0<0 (false) |
|Больше или равно|>=|2>=1 (true); 2>=2 (true) |
|Меньше или равно|<=|2<=1 (false); 2<=2 (true)|
|Равно или равно|==|1==1 (true); 1==2 (false)|
|Не равно|!=| 1 != 2 (true); 1 != 1 (false)|
|Побитовое И|&&| true && true (true); true && false (false); false && false (false)|
|Побитовое ИЛИ| \|\| | true \|\| false (true); true \|\| true (true); false \|\| false (false)|
|Побитовое НЕ|!| !true (false); !false (true)|
