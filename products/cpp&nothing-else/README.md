![Wrapper](wrapper.png)

# C++ And Nothing Else / RU


> В этой книге планируеться рассмотреть язык С++ как таковой. То есть мы ограничимся созданием консольных приложений, но мы выучим С++ на должном уровне.

# Для кого книга?
- Для тех, кто хоть как-то знает, как программировать хоть на каком-то из языков ниже (или им подобным): Python, JavaScript, Swift, Go, C#… И да, в этой книге мы будем сравнивать С++ с языками JavaScript и Python 

> *Лично я хорошо знаю Python и JavaScript.

> Если вы полный ноль в программировании как таковом и решились учить С++ (не рекомендовано учить его первым), то прочтите мою же книгу «C++ From Scratch (Bozich)». Где, собственно, вы изучите С++ сравнивая его с Scratch. Но это будут основы основ (синтаксис, переменные, операторы, условия, циклы итп) (далее можете приступить к этой книге).

# Соденжание

> ## [Глава 1. Основы основ.]()
> * [Первая программа.]()
> * [Переменные.]()
> * [Арифметические операторы.]()
> * [Приоритеты операторов.]()
> * [Ввод / Вывод.]()
> * [Условия, условные операторы.]()
> * [Циклы.]()
> * [Массивы, их методы.]()
> * [Строки, их методы.]()
> * [Функции.]()
> * [ООП (Поверхносно).]()
> * [Модули.]()
> * [Также.]()
> * [Подитожим.]()

# Глава 1. Основы основ

# Первая программа или Hello, World!

Следующий код выведет на экран "Hello, World"

``` cpp
#include <iostream>
using namespace std;

int main(int argc, char * argv[]) {
    cout << “Hello, World“ << endl;
}
```
Мы написали первую программу на С++. Давайте разберём этот код!

``` cpp
// Кстати, это комментарий. Компьютер его игнорирует. Он записуеться двумя косыми чертами

#include <iostream> // подключает ввод-вывод
using namespace std; // подключает std (тоже для ввода-вывода)
int main(int argc, char * argv[]) {
// функция main. Сама программа (?)
// Где argc — количество аргументов
// Где argv — аргументы функции

cout << “Hello, World“ << endl;
// cout это вывод, endl — это „Enter“ (\n).
// Hello, World Это выводимая строка
return 0; 
// ^^^ 
// результат функции main 0 говорит о том, что программа была завершена успешно
} // закрывающая фигурная скобка, завершение main (обязательно)
```

# Выражения

> Что такое выражение. Считайте - это команда. То есть, например, создание переменной (`int var = 1;`) это выражение. Вывод чего-то на экран - это тоже выражение. В Python выражения иногда называют логическими строками. Комментарий не являеться выражением (компьютер его игнорирует)

> После каждого выражения ставиться **точка с запятой ;**

# Типы данных

Основные типы данных:

``` cpp
bool // логическое значение true, false
int // целое число в диапазоне от −2 147 483 648 до 2 147 483 647 (пи 4 батах = 32 бита)
double // число с плавающей точкой (дробное) в диапазоне +/- 1.7E-308 до 1.7E+308 (64 бит)
float // это Double, но более точное (в диапазоне +/- 3.4E-38 до 3.4E+38, 32 бита)
string // только при #include <string>, соответственно, строка (массив символов)
```

Все типы данных (для особо дотошных):
**[К следующему разделу](#Переменные)**

> bool: логический тип. Может принимать одну из двух значений true (истина) и false (ложь). Размер занимаемой памяти для этого типа точно не определен.

> char: представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255

> signed char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от -128 до 127

> unsigned char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255

> wchar_t: представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)

> char16_t: представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535

> char32_t: представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295

> short: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).

> Данный тип также имеет синонимы short int, signed short int, signed short.

> unsigned short: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).

> Данный тип также имеет синоним unsigned short int.

> int: представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах). Но в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long

> Данный тип имеет синонимы signed int и signed.

> unsigned int: представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).

> В качестве синонима этого типа может использоваться unsigned

> long: представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647. Занимает в памяти 4 байта (32 бита).

> У данного типа также есть синонимы long int, signed long int и signed long

> unsigned long: представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).

> Имеет синоним unsigned long int.

> long long: представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт (64 бита).

> Имеет синонимы long long int, signed long long int и signed long long.

> unsigned long long: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт (64 бита).

> Имеет синоним unsigned long long int.

> float: представляет вещественное число ординарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)

> double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)

> long double: представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.

> void: тип без значения

# Переменные

Переменные, например в Python, создаються без ключевых
слов (за искл. Global):

```python
value = 12 // переменная value с значением # 12, тип (авто) - Int
```

А переменные в JavaScript создаються с помощью клучевого
слова var, let (const для констант):
``` javascript
var num = 13 // Number
let num_2 = 14 // Number
```

> Переменные же в С++ создаються следующим образом:

``` cpp
тип название = значение;
```
> Значение можно присваивать не сразу, но всё же можно присвоить сразу (...)

``` cpp
int num = 12;
// То же что:
int num;
num = 12
```

## Названия переменных.

Правила те же, что и в Python/JS. Но всё же, повторю: 
> Можно использовать все символы UTF-8, также «_» и числа, но числа не должны быть в начале.

То есть
``` cpp
int num_1 // OK
int 2num // WRONG
int _2num // OK
int num2 // OK
int num // OK
int _2 // OK
```

> Переменной можно присваивать значение когда угодно, но есле она обьявлена. В отличии от [Констант]().

# Константы

> Константа - это переменная, которая не маняет значение.

> Константы обьявляються как переменные, но с const в начале выражения. И им значение присваеваеться только один раз. То есть:

``` cpp
const int num = 10 // num = 10
num = 12 // ошибка! 
```

# Арифметические операторы

Вы же знаете про арифметические операторы (+, -, *, /). Вот их таблица:

> В ниже представленой таблице все операторы расположены по порядку возростания приоритета.

> Чем ниже приоритет у оператора, тем первее он будет действовать относительно других (в выражении, конечно).


|Приоритет | Оператор             | Символ | Пример | Операция |
||----------------------|:------:|:-----:|----------:|
|| Сложение             | +      | x + y  | x плюс у |
|| Вычитание            | -      | x - y  | х минус у |
|| Умножение            | *      | x * y  | х умножить на у |
|| Деление              | /      | x / y  | х делить на у |
|| Остаток при делении  | %      | x % y  | Остаток от деления х на у |
|| Префиксный инкремент | ++     | **++х**| x плюс 1 | 
|| Префиксный инкремент | --     | **--х**| x минус 1 | 


> **Префиксный** инкремент - это значение. То есть `++x` идентично `x + 1`. 

> Но, **префиксный** инкремент/декремент ничего не присваивает! 

Также В С++ существует унарный +/-, и бинарный +/-

> Простыми словами: унарный +/- это знак числа (число с унарным минусом отрицательное, с плюсом - положительное).

| Оператор      | Символ | Пример | Значение |
| --------------|:------:|:------:|---------:|
| Унарный плюс  | +      | (+x)   | Значение х
| Унарный минус | -      | (-x)   | Отрицательное значение х


> Скобки желательно ставить почти всегда при использовании унарного плюса\минуса. Это для того, то-бы компилятор не спутал унарный знак с бинарным (или с инкрементом\декрементом).

# Операторы присваивания


|Приоритет | Оператор                          | Символ | Пример | Операция                                   | Другими словами |
|---------|-----------------------------------|:------:|:------:|:------------------------------------------:|----------------:|
|| Присваивание                      | =      | x = y  | х присваиваеться значение y                | х становиться равно y
|| Сложение с присваиванием          | +=     | x += y | х присваиваеться x + y                     | х = х + у
|| Вычитание с присваиванием         | -=     | x -= y | х присваиваеться х - у                     | х = х - у
|| Умножение с присваиванием         | *=     | x *= y | х присваиваеться х * у                     | х = х * у
|| Деление с присваиванием           | /=     | x /= y | х присваиваеться х / у                     | х = х / у
|| Остаток от деления с присваиванием| %=     | x %= y | х присваиваеться остаток при х / у (х % у) | х = х / у
|| **Постфиксный** инкремент         | ++     | **x++**| x присваиваеться значение x + 1            | x += 1          |
|| **Постфиксный** декремент         | --     | **x--**| x присваиваеться значение x - 1            | x -= 1          |



