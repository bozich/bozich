![Wrapper](wrapper.png)

# C++ And Nothing Else / RU


> В этой книге планируеться рассмотреть язык С++ как таковой. То есть мы ограничимся созданием консольных приложений, но мы выучим С++ на должном уровне.

# Для кого книга?
- Для тех, кто хоть как-то знает, как программировать хоть на каком-то из языков ниже (или им подобным): Python, JavaScript, Swift, Go, C#… И да, в этой книге мы будем сравнивать С++ с языками JavaScript и Python 

> *Лично я хорошо знаю Python и JavaScript.

> Если вы полный ноль в программировании как таковом и решились учить С++ (не рекомендовано учить его первым), то прочтите мою же книгу «C++ From Scratch (Bozich)». Где, собственно, вы изучите С++ сравнивая его с Scratch. Но это будут основы основ (синтаксис, переменные, операторы, условия, циклы итп) (далее можете приступить к этой книге).

# Соденжание

> ## [Глава 1. Основы основ.]()
> * [Первая программа.]()
> * [Переменные.]()
> * [Арифметические операторы.]()
> * [Приоритеты операторов.]()
> * [Ввод / Вывод.]()
> * [Условия, условные операторы.]()
> * [Циклы.]()
> * [Массивы, их методы.]()
> * [Строки, их методы.]()
> * [Функции.]()
> * [ООП (Поверхносно).]()
> * [Модули.]()
> * [Также.]()
> * [Подитожим.]()

# Глава 1. Основы основ

# Первая программа или Hello, World!

Следующий код выведет на экран "Hello, World"

``` cpp
#include <iostream>
using namespace std;

int main(int argc, char * argv[]) {
    cout << “Hello, World“ << endl;
}
```
Мы написали первую программу на С++. Давайте разберём этот код!

``` cpp
// Кстати, это комментарий. Компьютер его игнорирует. Он записуеться двумя косыми чертами

#include <iostream> // подключает ввод-вывод
using namespace std; // подключает std (тоже для ввода-вывода)
int main(int argc, char * argv[]) {
// функция main. Сама программа (?)
// Где argc — количество аргументов
// Где argv — аргументы функции

cout << “Hello, World“ << endl;
// cout это вывод, endl — это „Enter“ (\n).
// Hello, World Это выводимая строка
return 0; 
// ^^^ 
// результат функции main 0 говорит о том, что программа была завершена успешно
} // закрывающая фигурная скобка, завершение main (обязательно)
```

# Выражения

> Что такое выражение. Считайте - это команда. То есть, например, создание переменной (`int var = 1;`) это выражение. Вывод чего-то на экран - это тоже выражение. В Python выражения иногда называют логическими строками. Комментарий не являеться выражением (компьютер его игнорирует)

> После каждого выражения ставиться **точка с запятой ;**

# Типы данных

Основные типы данных:

``` cpp
bool // логическое значение true, false
int // целое число в диапазоне от −2 147 483 648 до 2 147 483 647 (пи 4 батах = 32 бита)
double // число с плавающей точкой (дробное) в диапазоне +/- 1.7E-308 до 1.7E+308 (64 бит)
float // это Double, но более точное (в диапазоне +/- 3.4E-38 до 3.4E+38, 32 бита)
string // только при #include <string>, соответственно, строка (массив символов)
```

Все типы данных (для особо дотошных):
**[К следующему разделу](#Переменные)**

> bool: логический тип. Может принимать одну из двух значений true (истина) и false (ложь). Размер занимаемой памяти для этого типа точно не определен.

> char: представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255

> signed char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от -128 до 127

> unsigned char: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255

> wchar_t: представляет расширенный символ. На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)

> char16_t: представляет один символ в кодировке Unicode. Занимает в памяти 2 байта (16 бит). Может хранить любой значение из диапазона от 0 до 65 535

> char32_t: представляет один символ в кодировке Unicode. Занимает в памяти 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 4 294 967 295

> short: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).

> Данный тип также имеет синонимы short int, signed short int, signed short.

> unsigned short: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).

> Данный тип также имеет синоним unsigned short int.

> int: представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах). Но в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long

> Данный тип имеет синонимы signed int и signed.

> unsigned int: представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).

> В качестве синонима этого типа может использоваться unsigned

> long: представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647. Занимает в памяти 4 байта (32 бита).

> У данного типа также есть синонимы long int, signed long int и signed long

> unsigned long: представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).

> Имеет синоним unsigned long int.

> long long: представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт (64 бита).

> Имеет синонимы long long int, signed long long int и signed long long.

> unsigned long long: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт (64 бита).

> Имеет синоним unsigned long long int.

> float: представляет вещественное число ординарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта (32 бита)

> double: представляет вещественное число двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт (64 бита)

> long double: представляет вещественное число двойной точности с плавающей точкой не менее 8 байт (64 бит). В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений.

> void: тип без значения

# Переменные

Переменные, например в Python, создаються без ключевых
слов (за искл. Global):

```python
value = 12 // переменная value с значением # 12, тип (авто) - Int
```

А переменные в JavaScript создаються с помощью клучевого
слова var, let (const для констант):
``` javascript
var num = 13 // Number
let num_2 = 14 // Number
```

> Переменные же в С++ создаються следующим образом:

``` cpp
тип название = значение;
```
> Значение можно присваивать не сразу, но всё же можно присвоить сразу (...)

``` cpp
int num = 12;
// То же что:
int num;
num = 12
```

## Названия переменных.

Правила те же, что и в Python/JS. Но всё же, повторю: 
> Можно использовать все символы UTF-8, также «_» и числа, но числа не должны быть в начале.

То есть
``` cpp
int num_1 // OK
int 2num // WRONG
int _2num // OK
int num2 // OK
int num // OK
int _2 // OK
```

> Переменной можно присваивать значение когда угодно, но есле она обьявлена. В отличии от [Констант]().

# Константы

> Константа - это переменная, которая не маняет значение.

> Константы обьявляються как переменные, но с const в начале выражения. И им значение присваеваеться только один раз. То есть:

``` cpp
const int num = 10 // num = 10
num = 12 // ошибка! 
```

# Арифметические операторы

Вы же знаете про арифметические операторы (+, -, *, /). Вот их таблица:


| Оператор             | Символ | Пример | Операция |
|----------------------|:------:|:-----:|----------:|
| Сложение             | +      | x + y  | x плюс у |
| Вычитание            | -      | x - y  | х минус у |
| Умножение            | *      | x * y  | х умножить на у |
| Деление              | /      | x / y  | х делить на у |
| Остаток при делении  | %      | x % y  | Остаток от деления х на у |
| Префиксный инкремент | ++     | **++х**| x плюс 1 | 
| Префиксный инкремент | --     | **--х**| x минус 1 | 


> **Префиксный** инкремент - это значение. То есть `++x` идентично `x + 1`. 

> Но, **префиксный** инкремент/декремент ничего не присваивает! 

Также В С++ существует унарный +/-, и бинарный +/-

> Простыми словами: унарный +/- это знак числа (число с унарным минусом отрицательное, с плюсом - положительное).

| Оператор      | Символ | Пример | Значение |
| --------------|:------:|:------:|---------:|
| Унарный плюс  | +      | (+x)   | Значение х
| Унарный минус | -      | (-x)   | Отрицательное значение х


> Скобки желательно ставить почти всегда при использовании унарного плюса\минуса. Это для того, то-бы компилятор не спутал унарный знак с бинарным (или с инкрементом\декрементом).

# Операторы присваивания


| Оператор                          | Символ | Пример | Операция                                   | Другими словами |
|-----------------------------------|:------:|:------:|:------------------------------------------:|----------------:|
| Присваивание                      | =      | x = y  | х присваиваеться значение y                | х становиться равно y
| Сложение с присваиванием          | +=     | x += y | х присваиваеться x + y                     | х = х + у
| Вычитание с присваиванием         | -=     | x -= y | х присваиваеться х - у                     | х = х - у
| Умножение с присваиванием         | *=     | x *= y | х присваиваеться х * у                     | х = х * у
| Деление с присваиванием           | /=     | x /= y | х присваиваеться х / у                     | х = х / у
| Остаток от деления с присваиванием| %=     | x %= y | х присваиваеться остаток при х / у (х % у) | х = х / у
| **Постфиксный** инкремент         | ++     | **x++**| x присваиваеться значение x + 1            | x += 1          |
| **Постфиксный** декремент         | --     | **x--**| x присваиваеться значение x - 1            | x -= 1          |

#  Приоритеты операторов в С++

> В ниже представленной таблице (спасибо сайту ravesli.com) представлены все приоритеты в С++ с их приоритетами.

> Чем ниже ассоциативность, тем приоритетнее он.

<table class="tabluc" style="margin-bottom: 15px;"><tbody><tr><td><strong><span class="raznui_kolir_td">Ассоциативность</span></strong></td><td><strong><span class="raznui_kolir_td">Оператор</span></strong></td><td><strong><span class="raznui_kolir_td">Описание</span></strong></td><td><strong><span class="raznui_kolir_td">Пример</span></strong></td></tr><tr><td rowspan="2">1.&nbsp;Нет</td><td>::</td><td>Глобальная область видимости (унарный)</td><td>::name</td></tr><tr><td>::</td><td>Область видимости класса&nbsp;(бинарный)</td><td>class_name::member_name</td></tr><tr><td rowspan="16">2. L -&gt; R</td><td>()</td><td>Круглые скобки</td><td>(expression)</td></tr><tr><td>()</td><td>Вызов функции</td><td>function_name(parameters)</td></tr><tr><td>()</td><td>Инициализация</td><td>type name(expression)</td></tr><tr><td>{}</td><td>uniform-инициализация (C++11)</td><td>type name{expression}</td></tr><tr><td>type()</td><td>Конвертация типа</td><td>new_type(expression)</td></tr><tr><td>type{}</td><td>Конвертация типа (C++11)</td><td>new_type{expression}</td></tr><tr><td>[]</td><td>Индекс массива</td><td>pointer[expression]</td></tr><tr><td>.</td><td>Доступ к члену объекта</td><td>object.member_name</td></tr><tr><td>-&gt;</td><td>Доступ к члену объекта через указатель</td><td>object_pointer-&gt;member_name</td></tr><tr><td>++</td><td>Пост-инкремент</td><td>lvalue++</td></tr><tr><td>––</td><td>Пост-декремент</td><td>lvalue––</td></tr><tr><td>typeid</td><td>Информация о типе во время выполнения</td><td>typeid(type) or typeid(expression)</td></tr><tr><td>const_cast</td><td>Cast away const</td><td>const_cast(expression)</td></tr><tr><td>dynamic_cast</td><td>Type-checked cast во время выполнения</td><td>dynamic_cast(expression)</td></tr><tr><td>reinterpret_cast</td><td>Конвертация одного типа в другой</td><td>reinterpret_cast(expression)</td></tr><tr><td>static_cast</td><td>Type-checked cast во время компиляции</td><td>static_cast(expression)</td></tr><tr><td rowspan="14">3. R -&gt; L</td><td>+</td><td>Унарный&nbsp;плюс</td><td>+expression</td></tr><tr><td>—</td><td>Унарный&nbsp;минус</td><td>-expression</td></tr><tr><td>++</td><td>Пре-инкремент</td><td>++lvalue</td></tr><tr><td>––</td><td>Пре-декремент</td><td>––lvalue</td></tr><tr><td>!</td><td>Логическое&nbsp;НЕ (NOT)</td><td>!expression</td></tr><tr><td>~</td><td>Побитовое&nbsp;НЕ (NOT)</td><td>~expression</td></tr><tr><td>(type)</td><td>C-style cast</td><td>(new_type)expression</td></tr><tr><td>sizeof</td><td>Размер в&nbsp;байтах</td><td>sizeof(type) or sizeof(expression)</td></tr><tr><td>&amp;</td><td>Адрес</td><td>&amp;lvalue</td></tr><tr><td>*</td><td>Разыменование</td><td>*expression</td></tr><tr><td>new</td><td>Динамическое выделение памяти</td><td>new type</td></tr><tr><td>new[]</td><td>Динамическое выделение массива</td><td>new type[expression]</td></tr><tr><td>delete</td><td>Динамическое удаление памяти</td><td>delete pointer</td></tr><tr><td>delete[]</td><td>Динамическое удаление массива</td><td>delete[] pointer</td></tr><tr><td rowspan="2">4. L -&gt; R</td><td>-&gt;*</td><td>Member pointer selector</td><td>object_pointer-&gt;*pointer_to_member</td></tr><tr><td>.*</td><td>Member object selector</td><td>object.*pointer_to_member</td></tr><tr><td rowspan="3">5. L -&gt; R</td><td>*</td><td>Умножение</td><td>expression * expression</td></tr><tr><td>/</td><td>Деление</td><td>expression / expression</td></tr><tr><td>%</td><td>Деление с остатком</td><td>expression % expression</td></tr><tr><td rowspan="2">6. L -&gt; R</td><td>+</td><td>Сложение</td><td>expression + expression</td></tr><tr><td>—</td><td>Вычитание</td><td>expression — expression</td></tr><tr><td rowspan="2">7. L -&gt; R</td><td>&lt;&lt;</td><td>Побитовый сдвиг влево</td><td>expression &lt;&lt; expression</td></tr><tr><td>&gt;&gt;</td><td>Побитовый сдвиг&nbsp;вправо</td><td>expression &gt;&gt; expression</td></tr><tr><td rowspan="4">8. L -&gt; R</td><td>&lt;</td><td>Сравнение: меньше чем</td><td>expression &lt; expression</td></tr><tr><td>&lt;=</td><td>Сравнение: меньше чем или равно</td><td>expression &lt;=expression</td></tr><tr><td>&gt;</td><td>Сравнение: больше чем</td><td>expression &gt; expression</td></tr><tr><td>&gt;=</td><td>Сравнение: больше чем или равно</td><td>expression &gt;=expression</td></tr><tr><td rowspan="2">9. L -&gt; R</td><td>==</td><td>Равно</td><td>expression==expression</td></tr><tr><td>!=</td><td>Не равно</td><td>expression !=expression</td></tr><tr><td>10. L -&gt; R</td><td>&amp;</td><td>Побитовое И (AND)</td><td>expression &amp; expression</td></tr><tr><td>11. L -&gt; R</td><td>^</td><td>Побитовое исключающее ИЛИ (XOR)</td><td>expression ^ expression</td></tr><tr><td>12. L -&gt; R</td><td>|</td><td>Побитовое ИЛИ (OR)</td><td>expression | expression</td></tr><tr><td>13. L -&gt; R</td><td>&amp;&amp;</td><td>Логическое&nbsp;И (AND)</td><td>expression &amp;&amp; expression</td></tr><tr><td>14. L -&gt; R</td><td>||</td><td>Логическое ИЛИ (OR)</td><td>expression || expression</td></tr><tr><td rowspan="12">15. R -&gt; L</td><td>?:</td><td>Тернарный условный оператор</td><td>expression ? expression : expression</td></tr><tr><td>=</td><td>Присваивание</td><td>lvalue=expression</td></tr><tr><td>*=</td><td>Умножение с присваиванием</td><td>lvalue *=expression</td></tr><tr><td>/=</td><td>Деление с присваиванием</td><td>lvalue /=expression</td></tr><tr><td>%=</td><td>Деление с остатком и с присваиванием</td><td>lvalue %=expression</td></tr><tr><td>+=</td><td>Сложение с присваиванием</td><td>lvalue +=expression</td></tr><tr><td>-=</td><td>Вычитание с присваиванием</td><td>lvalue -=expression</td></tr><tr><td>&lt;&lt;=</td><td>Присваивание с побитовым сдвигом влево</td><td>lvalue &lt;&lt;=expression</td></tr><tr><td>&gt;&gt;=</td><td>Присваивание с побитовым сдвигом вправо</td><td>lvalue &gt;&gt;=expression</td></tr><tr><td>&amp;=</td><td>Присваивание с побитовой операцией И (AND)</td><td>lvalue &amp;=expression</td></tr><tr><td>|=</td><td>Присваивание с побитовой операцией&nbsp;ИЛИ (OR)</td><td>lvalue |=expression</td></tr><tr><td>^=</td><td>Присваивание с побитовой операцией «Исключающее ИЛИ» (XOR)</td><td>lvalue ^=expression</td></tr><tr><td>16. R -&gt; L</td><td>throw</td><td>Генерация исключения</td><td>throw expression</td></tr><tr><td>17. L -&gt; R</td><td>,</td><td>Оператор Запятая</td><td>expression, expression</td></tr></tbody></table>
