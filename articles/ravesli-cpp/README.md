# Все про С++ из сайта ravesli.com

Сдесь я собрал всю информацию про С++ (на 2021 год) из онлайн-учебника ravesli. Цель: удобство, а также [pdf файл](http://github.com/bozich/bozich/raw/master/articles/ravesli-cpp/index.pdf) в репозитории [GitHub](http://github.com/bozich/bozich/tree/master/articles/ravesli-cpp/)

Веб-Сайт автора: [bozich.github.io](http://bozich.github.io).

Что-ж, начнем!

# Оглавление:

> ### [Глава №0. Введение. Начало работы]()
> * [Урок №1. Введение в программирование]()
> * [Урок №2. Введение в языки программирования C и С++]()
> * [Урок №3. Введение в разработку программного обеспечения]()
> * [Урок №4. Установка IDE (Интегрированной Среды Разработки)]()
> * [Урок №5. Компиляция вашей первой программы]()
> * [Урок №6. Режимы конфигурации «Debug» и «Release»]()
> * [Конфигурация компилятора: Расширения компилятора]()
> * [Конфигурация компилятора: Уровни предупреждений и ошибки]()
> * [Конфигурация компилятора: Выбор стандарта языка С++]()
> * [Урок №7. Решения самых распространенных проблем]()

> ### [Глава №1. Основы C++]()
> * [Урок №8. Структура программ]()
> * [Урок №9. Комментарии]()
> * [Урок №10. Переменные, Инициализация и Присваивание]()
> * [Урок №11. cout, cin и endl]()
> * [Урок №12. Функции и оператор возврата return]()
> * [Урок №13. Параметры и аргументы функций]()
> * [Урок №14. Почему функции — полезны, и как их эффективно использовать?]()
> * [Урок №15. Локальная область видимости]()
> * [Урок №16. Ключевые слова и идентификаторы]()
> * [Урок №17. Операторы]()
> * [Урок №18. Базовое форматирование кода]()
> * [Урок №19. Прототип функции и Предварительное объявление]()
> * [Урок №20. Многофайловые программы]()
> * [Урок №21. Заголовочные файлы]()
> * [Урок №22. Директивы препроцессора]()
> * [Урок №23. Header guards и #pragma once]()
> * [Урок №24. Конфликт имен и std namespace]()
> * [Урок №25. Разработка ваших первых программ]()
> * [Урок №26. Отладка программ: степпинг и точки останова]()
> * [Урок №27. Отладка программ: стек вызовов и отслеживание переменных]()
> * [Глава №1. Итоговый тест]()

> ### [Глава №2. Переменные и основные типы данных в C++]()
> * [Урок №28. Инициализация, присваивание и объявление переменных]()
> * [Урок №29. Тип данных void]()
> * [Урок №30. Размер типов данных]()
> * [Урок №31. Целочисленные типы данных: short, int и long]()
> * [Урок №32. Фиксированный размер целочисленных типов данных]()
> * [Урок №33. Типы данных с плавающей точкой: float, double и long double]()
> * [Урок №34. Логический тип данных bool]()
> * [Урок №35. Символьный тип данных char]()
> * [Урок №36. Литералы и магические числа]()
> * [Урок №37. const, constexpr и символьные константы]()
> * [Глава №2. Итоговый тест]()

> ### [Глава №3. Операторы в C++]()
> * [Урок №38. Приоритет операций и правила ассоциативности]()
> * [Урок №39. Арифметические операторы]()
> * [Урок №40. Инкремент, декремент и побочные эффекты]()
> * [Урок №41. Условный тернарный оператор, оператор sizeof и Запятая]()
> * [Урок №42. Операторы сравнения]()
> * [Урок №43. Логические операторы: И, ИЛИ, НЕ]()
> * [Урок №44. Конвертация чисел из двоичной системы в десятичную и наоборот]()
> * [Урок №45. Побитовые операторы]()
> * [Урок №46. Битовые флаги и битовые маски]()
> * [Глава №3. Итоговый тест]()

> ### [Глава №4. Область видимости и другие типы переменных в C++]()
> * [Урок №47. Блоки стейтментов (составные операторы)]()
> * [Урок №48. Локальные переменные, область видимости и продолжительность жизни]()
> * [Урок №49. Глобальные переменные]()
> * [Урок №50. Почему глобальные переменные – зло?]()
> * [Урок №51. Статические переменные]()
> * [Урок №52. Связи, область видимости и продолжительность жизни]()
> * [Урок №53. Пространства имен]()
> * [Урок №54. using-стейтменты]()
> * [Урок №55. Неявное преобразование типов данных]()
> * [Урок №56. Явное преобразование типов данных]()
> * [Урок №57. Введение в std::string]()
> * [Урок №58. Перечисления]()
> * [Урок №59. Классы enum]()
> * [Урок №60. Псевдонимы типов: typedef и type alias]()
> * [Урок №61. Структуры]()
> * [Урок №62. Вывод типов: ключевое слово auto]()
> * [Глава №4. Итоговый тест]()

> ### [Глава №5. Порядок выполнения кода в программе. Циклы, ветвления в C++]()
> * [Урок №63. Операторы управления потоком выполнения программ]()
> * [Урок №64. Операторы условного ветвления if/else]()
> * [Урок №65. Оператор switch]()
> * [Урок №66. Оператор goto]()
> * [Урок №67. Цикл while]()
> * [Урок №68. Цикл do while]()
> * [Урок №69. Цикл for]()
> * [Урок №70. Операторы break и continue]()
> * [Урок №71. Генерация случайных чисел]()
> * [Урок №72. Обработка некорректного пользовательского ввода]()
> * [Урок №73. Введение в тестирование кода]()
> * [Глава №5. Итоговый тест]()

> ### [Глава №6. Массивы, Строки, Указатели и Ссылки в C++]()
> * [Урок №74. Массивы]()
> * [Урок №75. Фиксированные массивы]()
> * [Урок №76. Массивы и циклы]()
> * [Урок №77. Сортировка массивов методом выбора]()
> * [Урок №78. Многомерные массивы]()
> * [Урок №79. Строки C-style]()
> * [Введение в класс std::string_view в С++]()
> * [Урок №80. Указатели]()
> * [Урок №81. Нулевые указатели]()
> * [Урок №82. Указатели и массивы]()
> * [Урок №83. Адресная арифметика и индексация массивов]()
> * [Урок №84. Символьные константы строк C-style]()
> * [Урок №85. Динамическое выделение памяти]()
> * [Урок №86. Динамические массивы]()
> * [Урок №87. Указатели и const]()
> * [Урок №88. Ссылки]()
> * [Урок №89. Ссылки и const]()
> * [Урок №90. Оператор доступа к членам через указатель]()
> * [Урок №91. Цикл foreach]()
> * [Урок №92. Указатели типа void]()
> * [Урок №93. Указатели на указатели]()
> * [Урок №94. Введение в std::array]()
> * [Урок №95. Введение в std::vector]()
> * [Введение в итераторы в С++]()
> * [Алгоритмы в Стандартной библиотеке С++]()
> * [Глава №6. Итоговый тест]()


> ### [Глава №7. Функции в C++]()
> * [Урок №96. Параметры и аргументы функций]()
> * [Урок №97. Передача по значению]()
> * [Урок №98. Передача по ссылке]()
> * [Урок №99. Передача по адресу]()
> * [Урок №100. Возврат значений по ссылке, по адресу и по значению]()
> * [Урок №101. Встроенные функции]()
> * [Урок №102. Перегрузка функций]()
> * [Урок №103. Параметры по умолчанию]()
> * [Урок №104. Указатели на функции]()
> * [Урок №105. Стек и Куча]()
> * [Урок №106. Ёмкость вектора]()
> * [Урок №107. Рекурсия и Числа Фибоначчи]()
> * [Урок №108. Обработка ошибок, cerr и exit()]()
> * [Урок №109. assert и static_assert]()
> * [Урок №110. Аргументы командной строки]()
> * [Урок №111. Эллипсис]()
> * [Лямбда-выражения в С++]()
> * [Лямбда-захваты в С++]()
> * [Глава №7. Итоговый тест]()


> ### [Глава №8. Основы ООП в C++]()
Урок №112. Введение в ООП> * []()
> * [Урок №113. Классы, Объекты и Методы]()
> * [Урок №114. Спецификаторы доступа public и private]()
> * [Урок №115. Инкапсуляция, Геттеры и Сеттеры]()
> * [Урок №116. Конструкторы]()
> * [Урок №117. Список инициализации членов класса]()
> * [Урок №118. Инициализация нестатических членов класса]()
> * [Урок №119. Делегирующие конструкторы]()
> * [Урок №120. Деструкторы]()
> * [Урок №121. Скрытый указатель *this]()
> * [Урок №122. Классы и заголовочные файлы]()
> * [Урок №123. Классы и const]()
> * [Урок №124. Статические переменные-члены класса]()
> * [Урок №125. Статические методы класса]()
> * [Урок №126. Дружественные функции и классы]()
> * [Урок №127. Анонимные объекты]()
> * [Урок №128. Вложенные типы данных в классах]()
> * [Урок №129. Измерение времени выполнения (тайминг) кода]()
> * [Глава №8. Итоговый тест]()

> ### [Глава №9. Перегрузка операторов в C++]()
> * [Урок №130. Введение в перегрузку операторов]()
> * [Урок №131. Перегрузка операторов через дружественные функции]()
> * [Урок №132. Перегрузка операторов через обычные функции]()
> * [Урок №133. Перегрузка операторов ввода и вывода]()
> * [Урок №134. Перегрузка операторов через методы класса]()
> * [Урок №135. Перегрузка унарных операторов +, — и логического НЕ]()
> * [Урок №136. Перегрузка операторов сравнения]()
> * [Урок №137. Перегрузка операторов инкремента и декремента]()
> * [Урок №138. Перегрузка оператора индексации []]()
> * [Урок №139. Перегрузка оператора ()]()
> * [Урок №140. Перегрузка операций преобразования типов данных]()
> * [Урок №141. Конструктор копирования]()
> * [Урок №142. Копирующая инициализация]()
> * [Урок №143. Конструкторы преобразования, ключевые слова explicit и delete]()
> * [Урок №144. Перегрузка оператора присваивания]()
> * [Урок №145. Поверхностное и глубокое копирование]()
> * [Глава №9. Итоговый тест]()

> ### [Глава №10. Введение в связи между объектами в C++]()
> * [Урок №146. Типы связей между объектами]()
> * [Урок №147. Композиция объектов]()
> * [Урок №148. Агрегация]()
> * [Урок №149. Ассоциация]()
> * [Урок №150. Зависимость]()
> * [Урок №151. Контейнерные классы]()
> * [Урок №152. Список инициализации std::initializer_list]()
> * [Глава №10. Итоговый тест]()

> ### [Глава №11. Наследование в C++]()
> * [Урок №153. Введение в Наследование]()
> * [Урок №154. Базовое наследование]()
> * [Урок №155. Порядок построения дочерних классов]()
> * [Урок №156. Конструкторы и инициализация дочерних классов]()
> * [Урок №157. Наследование и спецификатор доступа protected]()
> * [Урок №158. Добавление нового функционала в дочерний класс]()
> * [Урок №159. Переопределение методов родительского класса]()
> * [Урок №160. Сокрытие методов родительского класса]()
> * [Урок №161. Множественное наследование]()
> * [Глава №11. Итоговый тест]()

> ### [Глава №12. Виртуальные функции в C++]()
> * [Урок №162. Указатели, Ссылки и Наследование]()
> * [Урок №163. Виртуальные функции и Полиморфизм]()
> * [Урок №164. Модификаторы override и final]()
> * [Урок №165. Виртуальные деструкторы и Виртуальное присваивание]()
> * [Урок №166. Раннее и Позднее Связывания]()
> * [Урок №167. Виртуальные таблицы]()
> * [Урок №168. Чистые виртуальные функции, Интерфейсы и Абстрактные классы]()
> * [Урок №169. Виртуальный базовый класс]()
> * [Урок №170. Обрезка объектов]()
> * [Урок №171. Динамическое приведение типов. Оператор dynamic_cast]()
> * [Урок №172. Вывод объектов классов через оператор вывода]()
> * [Глава №12. Итоговый тест]()

> ### [Глава №13. Шаблоны в C++]()
> * [Урок №173. Шаблоны функций]()
> * [Урок №174. Экземпляры шаблонов функций]()
> * [Урок №175. Шаблоны классов]()
> * [Урок №176. Параметр non-type в шаблоне]()
> * [Урок №177. Явная специализация шаблона функции]()
> * [Урок №178. Явная специализация шаблона класса]()
> * [Урок №179. Частичная специализация шаблона]()
> * [Урок №180. Частичная специализация шаблонов и Указатели]()
> * [Глава №13. Итоговый тест]()


> ### [Глава №14. Исключения в C++]()
> * [Урок №181. Исключения. Зачем они нужны?]()
> * [Урок №182. Обработка исключений. Операторы throw, try и catch]()
> * [Урок №183. Исключения, Функции и Раскручивание стека]()
> * [Урок №184. Непойманные исключения и обработчики catch-all]()
> * [Урок №185. Классы-Исключения и Наследование]()
> * [Урок №186. Повторная генерация исключений]()
> * [Урок №187. Функциональный try-блок]()
> * [Урок №188. Недостатки и опасности использования исключений]()
> * [Глава №14. Итоговый тест]()

> ### [Глава №15. Умные указатели и Семантика перемещения в C++]()
> * [Урок №189. Умные указатели и Семантика перемещения]()
> * [Урок №190. Ссылки r-value]()
> * [Урок №191. Конструктор перемещения и Оператор присваивания перемещением]()
> * [Урок №192. Функция std::move()]()
> * [Урок №193. Умный указатель std::unique_ptr]()
> * [Урок №194. Умный указатель std::shared_ptr]()
> * [Урок №195. Умный указатель std::weak_ptr]()
> * [Глава №15. Итоговый тест]()

> ### [Глава №16. Стандартная библиотека шаблонов (STL) в С++]()
> * [Урок №196. Стандартная библиотека шаблонов (STL)]()
> * [Урок №197. Контейнеры STL]()
> * [Урок №198. Итераторы STL]()
> * [Урок №199. Алгоритмы STL]()

> ### [Глава №17. std::string в С++]()
> * [Урок №200. Строковые классы std::string и std::wstring]()
> * [Урок №201. Создание, уничтожение и конвертация std::string]()
> * [Урок №202. Длина и ёмкость std::string]()
> * [Урок №203. Доступ к символам std::string. Конвертация std::string в строки C-style]()
> * [Урок №204. Присваивание и перестановка значений с std::string]()
> * [Урок №205. Добавление к std::string]()
> * [Урок №206. Вставка символов и строк в std::string]()

> ### [Глава №18. Ввод/Вывод в С++]()
> * [Урок №207. Потоки ввода и вывода]()
> * [Урок №208. Функционал класса istream]()
> * [Урок №209. Функционал классов ostream и ios. Форматирование вывода]()
> * [Урок №210. Потоковые классы и Строки]()
> * [Урок №211. Состояния потока и валидация пользовательского ввода]()
> * [Урок №212. Базовый файловый ввод и вывод]()
> * [Урок №213. Рандомный файловый ввод и вывод]()

> ### [Дополнительные уроки]()
> * [Статические и динамические библиотеки]()
> * [Подключение и использование библиотек в Visual Studio]()
> * [C++11. Нововведения]()
> * [C++14. Нововведения]()
> * [C++17. Нововведения]()
> * [Спецификации исключений и спецификатор noexcept в С++]()
> * [Функция std::move_if_noexcept() в С++]()
> * [C++20. Нововведения]()
> * [Оператор трехстороннего сравнения в С++]()
> * [C++20. Два новых ключевых слова: consteval и constinit]()
> * [C++20. Библиотека chrono и Время суток]()

> ## [Финал]
> * [Конец? Что дальше?]()


> ### [Пошаговое создание игры на С++/MFC]
> * [Урок №1: Введение в создание игры «SameGame» на C++/MFC]()
> * [Урок №2: Архитектура и хранение данных в игре «SameGame» на C++/MFC]()
> * [Урок №3: Отрисовка игры «SameGame» на C++/MFC]()
> * [Урок №4: Обработка событий в игре «SameGame» на C++/MFC]()
> * [Урок №5: Работа с алгоритмом в игре «SameGame» на C++/MFC]()
> * [Урок №6: Работа с меню в игре «SameGame» на C++/MFC]()
> * [Урок №7: Добавление уровней сложности в игре «SameGame» на C++/MFC]()
> * [Урок №8: Размеры и количество блоков в игре «SameGame» на C++/MFC]()
> * [Урок №9: Финальные штрихи в создании игры «SameGame» на C++/MFC]()

> ### [Практические задания по С++](
> * [Часть №1: Практические задания по С++]()
> * [Часть №2: Практические задания по С++]()
> * [Часть №3: Практические задания по С++]()
> * [Часть №4: Практические задания по С++]()
> * [Часть №5: Практические задания по С++]()
> * [Часть №6: Практические задания по С++]()
> * [Часть №7: Практические задания по С++]()
> * [Часть №8: Практические задания по С++]()
> * [Часть №9: Практические задания по С++]()
> * [Часть №10: Практические задания по С++]()
> * [Часть №11: Практические задания по С++]()
> * [Часть №12: Практические задания по С++]()
> * [Часть №13: Практические задания по С++]()
> * [Часть №14: Практические задания по С++]()
> * [Часть №15: Практические задания по С++]()
> * [Часть №16: Практические задания по С++]()
> * [Часть №17: Практические задания по С++]()
> * [Часть №18: Практические задания по С++]()
> * [Часть №19: Практические задания по С++]()
> * [Часть №20: Практические задания по С++]()
> * [Часть №21: Практические задания по С++]()
> * [Часть №22: Практические задания по С++]()
> * [Часть №23: Практические задания по С++]()
> * [Часть №24: Практические задания по С++]()

> ### [Уроки по графической библиотеке SFML]()
> * [Вступление и установка графической библиотеки SFML в C++]()
> * [Создание простых геометрических фигур в C++/SFML]()
> * [Спрайты и текстуры в C++/SFML]()
> * [Часть №1: Создание игры «Тетрис» на С++/SFML]()
> * [Часть №2: Создание игры «Тетрис» на С++/SFML]()
> * [Часть №3: Создание игры «Тетрис» на С++/SFML]()
> * [Создание игры «Сапер» на С++/SFML]()
> * [Создание игры «Пятнашки» на C++/SFML]()

**Примечание: Это авторские уроки Дмитрия Бушуева!**



___
___
___

# Глава №0. Введение. Начало работы
---
# Урок №1. Введение в программирование

> Компьютеры понимают только очень ограниченный набор инструкций, и чтобы заставить их что-то делать, нужно четко сформулировать задание, используя эти же инструкции. Программа (также «приложение» или «программное обеспечение», или «софт») — это набор инструкций, которые указывают компьютеру, что ему нужно делать. Физическая часть компьютера, которая выполняет эти инструкции, называется «железом» или аппаратной частью (например, процессор, материнская плата и т.д.). Данный урок является началом серии уроков по программированию на языке С++ для начинающих.


> Оглавление:
>
> 1. [Машинный язык]()
> 2. [Язык ассемблера]()
> 3. [Высокоуровневые языки программирования]()
> 4. [Преимущества высокоуровневых языков программирования]()

# Машинный язык

> Процессор компьютера не способен понимать напрямую языки программирования, такие как C++, Java, Python и т.д. Очень ограниченный набор инструкций, которые изначально понимает процессор, называется машинным кодом (или «машинным языком»). То, как эти инструкции организованы, выходит за рамки данного введения, но стоит отметить две вещи.

> Во-первых, каждая команда (инструкция) состоит только из определенной последовательности (набора) цифр: 0 и 1. Эти числа называются битами (сокр. от «binary digit») или двоичным кодом.

> Например, одна команда машинного кода архитектуры ×86 выглядит следующим образом:

`10110000 01100001`

> Во-вторых, каждый набор бит переводится процессором в инструкции для выполнения определенного задания (например, сравнить два числа или переместить число в определенную ячейку памяти). Разные типы процессоров обычно имеют разные наборы инструкций, поэтому инструкции, которые будут работать на процессорах Intel (используются в персональных компьютерах), с большей долей вероятности, не будут работать на процессорах Xenon (используются в игровых приставках Xbox). Раньше, когда компьютеры только начинали массово распространяться, программисты должны были писать программы непосредственно на машинном языке, что было очень неудобно, сложно и занимало намного больше времени, чем сейчас.

# Язык ассемблера

> Так как программировать на машинном языке — удовольствие специфическое, то программисты изобрели язык ассемблера. В этом языке каждая команда идентифицируется коротким именем (а не набором единиц с нулями), и переменными можно управлять через их имена. Таким образом, писать/читать код стало гораздо легче. Тем не менее, процессор все равно не понимает язык ассемблера напрямую. Его также нужно переводить, с помощью ассемблера, в машинный код. Ассемблер — это транслятор (переводчик), который переводит код, написанный на языке ассемблера, в машинный язык. В Интернете язык ассемблера часто называют просто «Ассемблер».

> Преимуществом Ассемблера является его производительность (точнее скорость выполнения) и он до сих пор используется, когда это имеет решающее значение. Тем не менее, причина подобного преимущества заключается в том, что программирование на этом языке адаптируется к конкретному процессору. Программы, адаптированные под один процессор, не будут работать с другим. Кроме того, чтобы программировать на Ассемблере, по-прежнему нужно знать очень много не очень читабельных инструкций для выполнения даже простого задания.

Например, вот вышеприведенная команда, но уже на языке ассемблера:

`mov al, 061h`

# Высокоуровневые языки программирования

> Для решения проблем читабельности кода и чрезмерной сложности были разработаны высокоуровневые языки программирования. C, C++, Pascal, Java, JavaScript и Perl — это всё языки высокого уровня. Они позволяют писать и выполнять программы, не переживая о совместимости кода с разными архитектурами процессоров. Программы, написанные на языках высокого уровня, также должны быть переведены в машинный код перед выполнением. Есть два варианта:
> 
>   * компиляция, которая выполняется компилятором;
>
>   * интерпретация, которая выполняется интерпретатором.

> **Компилятор** — это программа, которая читает код и создает автономную (способную работать независимо от другого аппаратного или программного обеспечения) исполняемую программу, которую процессор понимает напрямую. При запуске программы весь код компилируется целиком, а затем создается исполняемый файл и уже при повторном запуске программы компиляция не выполняется.

> Проще говоря, процесс компиляции выглядит следующим образом:

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/sxemagotovoOk.jpg)

> **Интерпретатор** — это программа, которая напрямую выполняет код, без его предыдущей компиляции в исполняемый файл. Интерпретаторы более гибкие, но менее эффективные, так как процесс интерпретации выполняется повторно при каждом запуске программы.

Процесс интерпретации: 

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/sxemagotovo22Ok.jpg)

> Любой язык программирования может быть компилируемым или интерпретируемым, однако, такие языки, как C, C++ и Pascal — компилируются, в то время как «скриптовые» языки, такие, как Perl и JavaScript — интерпретируются. Некоторые языки программирования (например, Java) могут как компилироваться, так и интерпретироваться.


# Преимущества высокоуровневых языков программирования

* ***Преимущество №1***: Легче писать/читать код. Вот вышеприведенная команда, но уже на языке C++:

`а = 97;`

* ***Преимущество №2***: Требуется меньше инструкций для выполнения определенного задания. В языке C++ вы можете сделать что-то вроде а = Ь * 2 + 5; в одной строке. В языке ассемблера вам пришлось бы использовать 5 или 6 инструкций.

* ***Преимущество №3***: Вы не должны заботиться о таких деталях, как загрузка переменных в регистры процессора. Компилятор или интерпретатор берёт это на себя.

* ***Преимущество №4***: Высокоуровневые языки программирования более портируемые под различные архитектуры (но есть один нюанс).

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/sxemagotovo33.jpg)

> Нюанс заключается в том, что многие платформы, такие как Microsoft Windows, имеют свои собственные специфические функции, с помощью которых писать код намного легче. Но в таком случае приходится жертвовать портируемостью, так как функции, специфические для одной платформы, с большей долей вероятности, не будут работать на другой платформе. Обо всем этом мы детально поговорим на следующих уроках.

___
# Урок №2. Введение в языки программирования C и С++

> Перед C++ был C. C (произносится как «Си») был разработан в 1972 году Деннисом Ритчи в Bell Telephone Laboratories как системный язык программирования, т.е. язык для написания операционных систем. Основной задачей Ритчи было создание легко компилируемого минималистического языка, который предоставлял бы эффективный доступ к памяти, относительно быстро выполнялся, и на котором можно было бы писать эффективный код. Таким образом, при разработке высокоуровневого языка, был создан язык Си, который во многом относился к языкам низкого уровня, оставаясь при этом независимым от платформ, для которых мог быть написан код.

> Cи в конечном итоге стал настолько эффективным и гибким, что в 1973 году Ритчи и Кен Томпсон переписали больше половины операционной системы UNIX, используя этот язык. Многие предыдущие операционные системы были написаны на языке ассемблера. В отличие от Ассемблера, на котором пишутся программы под конкретные процессоры, высокая портируемость языка Cи позволила перекомпилировать UNIX и на другие типы компьютеров, ускоряя его популяризацию. Язык Cи и операционная система UNIX тесно связаны между собой, и популярность первого отчасти связана с успехом второго.

> В 1978 году Брайан Керниган и Деннис Ритчи опубликовали книгу под названием «Язык программирования Cи». Эта книга, более известна как «K&R» (первые буквы фамилий авторов), стала стандартом и своеобразной инструкцией к Си. Когда требовалась максимальная портируемость, то программисты придерживались рекомендаций в «K&R», поскольку большинство компиляторов в то время были реализованы в соответствии со стандартами, присутствующими в этой книге.

> В 1983 году Американский национальный институт стандартов (сокр. «ANSI» от англ. «American National Standards Institute») сформировал комитет для утверждения официального стандарта языка Cи. В 1989 году они закончили и выпустили стандарт C89, более широко известный, как ANSI C. В 1990 году Международная организация по стандартизации (сокр. «ISO» от англ. «International Organization for Standardization») приняла ANSI C (с небольшими изменениями). Эта версия языка Cи стала известна как C90. В конечном счете, компиляторы адаптировались под требования ANSI C/C90 и программы, в которых требовалась максимальная портируемость, писались в соответствие с этими стандартами.

> В 1999 году комитет ANSI выпустил новую версию языка Cи, которая получила название C99. Она приняла много особенностей, которые были реализованы в компиляторах (в виде различных расширений) или уже в языке C++.

## Язык C++
> C++ (произносится как «Си плюс плюс») был разработан Бьёрном Страуструпом в Bell Labs в качестве дополнения к Cи в 1979 г. Он добавил множество новых фич в язык Си. Его популярность была вызвана объектно-ориентированностью языка. Об объектно-ориентированном программировании (ООП) и его отличиях от традиционных методов программирования мы поговорим несколько позже.

> Язык C++ был ратифицирован (одобрен) комитетом ISO в 1998 году и потом снова в 2003 году (под названием C++03). Потом были еще три обновления (C++11, C++14 и C++17, ратифицированные в 2011, 2014 и 2017 годах, соответственно), которые добавили больше функциональных возможностей.

> Философия С и С++

> Смысл философии языков С и C++ можно определить выражением «доверять программисту». Например, компилятор не будет вам мешать сделать что-то новое, что имеет смысл, но также не будет мешать вам сделать что-то такое, что может привести к сбою. Это одна из главных причин, почему так важно знать то, что вы не должны делать, как и то, что вы должны делать, создавая программы на языках С/С++.

___
# Урок №3. Введение в разработку программного обеспечения

> Перед написанием и выполнением нашей первой программы, мы должны понять, как вообще выполняется разработка программного обеспечения на языке C++.

Схема разработки ПО (сокр. от «Программное Обеспечение»):

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/Razrabotka-programmnyh-produktov.jpg)

> ## Оглавление:
> 1. [Шаг №1: Определите проблему, которую хотели бы решить]()
> 2. [Шаг №2: Определитесь, как вы собираетесь решить эту проблему]()
> 3. [Шаг №3: Напишите программу]()
> 4. [Шаг №4: Компиляция]()
> 5. [Шаг №5: Линкинг (связывание объектных файлов)]()
> 6. [Шаг №6: Тестирование и отладка]()

* ## Шаг №1: Определите проблему, которую хотели бы решить

> Это шаг «Что?». Здесь вы должны понять, что же вы хотите, чтобы ваша программа делала. Этот шаг может быть, как самым простым, так и самым сложным. Всё, что вам нужно — это четко сформулировать идею. Только после этого вы сможете приступать к следующему шагу.

> Вот несколько примеров выполнения шага №1:
> 
>  * «Я хочу написать программу, которая вычисляла бы среднее арифметическое чисел, которые я введу».
> 
>  * «Я хочу написать программу, в которой будет 2D-лабиринт, по которому сможет передвигаться пользователь».
>
>  * «Я хочу написать программу, которая будет анализировать цены акций на бирже и давать предсказания по поводу скачков этих цен вверх или вниз».

* ## Шаг №2: Определитесь, как вы собираетесь решить эту проблему

> Здесь мы уже отвечаем на вопрос «Как?». Каким образом можно решить проблему, обозначенную на шаге №1? Этим шагом довольно часто пренебрегают при разработке программного обеспечения. Суть в том, что способов решения задачи может быть много, только часть из них — хорошие решения, а часть — плохие. Вы должны научиться отделять первые от вторых. Очень часто можно наблюдать ситуацию, когда у программиста возникает идея и он сразу же садится программировать. Как вы уже могли догадаться, такой сценарий далеко не всегда приводит к эффективным результатам.

> Как правило, хорошие решения имеют следующие характеристики:
> 
> *   простота;
> 
> *   хорошая документация (с инструкциями и комментариями);
> 
> *   модульный принцип: любая часть программы может быть повторно использована или изменена позже, не затрагивая другие части кода;
> 
> *   надежность: соответствующая обработка ошибок и экстренных ситуаций.

> Когда вы садитесь и начинаете сразу программировать, вы думаете: «Я хочу сделать это, вот это и еще вот это!». Таким образом вы принимаете решения, которые позволят вам поскорее выполнить задание. Однако это может привести к тому, что вы получите программу, которую позже будет трудно изменить/модифицировать, добавить что-то новое или вам попросту придется разбираться с большим количеством багов.

> Согласно закону Парето, программист тратит примерно 20% времени на написание программы и 80% на отладку (исправление ошибок) или поддержку (добавление новых функциональных возможностей) кода. Следовательно, лучше потратить дополнительное время на обдумывание лучшего способа решения проблемы перед процессом написания кода, нежели потом тратить оставшиеся 80% времени на поиск и исправление ошибок.

* ## Шаг №3: Напишите программу

> **Для того, чтобы написать программу, необходимы две вещи:**
> 
> *  знание определенного **языка программирования** (этому мы вас научим);
> 
> *   **редактор кода**.

> Программу можно написать, используя любой редактор, даже тот же Блокнот в Windows или текстовый редактор Vi в Unix. Тем не менее, я настоятельно рекомендую использовать редактор, предназначенный для программирования. Не беспокойтесь, если у вас его еще нет. На следующем уроке мы рассмотрим процесс установки такого приложения.

> **Редактор типичного программиста, как правило, имеет следующие особенности, которые облегчают программирование:**
> 
> * **Нумерация строк**. Это функция чрезвычайно полезна при отладке программ, когда компилятор выдаёт нам сообщения об ошибках. Типичная ошибка компиляции состоит из наименования ошибки и номера строки, где эта ошибка произошла (например, «ошибка переопределения переменной x, строка 90»). Без нумерации строк искать ту самую 90-ю строку кода было бы несколько затруднительно, не так ли?
> 
> * **Подсветка синтаксиса**. Подсветка синтаксиса изменяет цвет разных частей программы и кода, что улучшает восприятие как целой программы, так и её отдельных частей.
> 
> * **Специальный шрифт**. В обычных шрифтах очень часто возникает путаница между определенными символами, когда непонятно, какой символ перед вами. Например: цифра 0 или буква O, цифра 1 или буква l (нижний регистр L), или может буква I (верхний регистр i). Вот для этого и нужен специальный шрифт, в котором будет легко различить эти символы, предотвращая случайное использование одного символа вместо другого.

> Программы на языке C++ следует называть name.cpp, где name заменяется именем вашей программы, а расширение .cpp сообщает компилятору (и вам тоже), что это исходный файл кода, который содержит инструкции на языке программирования C++. Следует обратить внимание, что некоторые программисты используют расширение .cc вместо .cpp, но я рекомендую использовать именно .cpp.

> Также стоит отметить, что много программ, написанных на языке C++, могут состоять из нескольких файлов .cpp. Хотя большинство программ, которые вы будете создавать на протяжении этих уроков, не будут слишком большими, в дальнейшем вы научитесь писать программы, которые будут включать десятки, если не сотни отдельных файлов .cpp.


* ## Шаг №4: Компиляция

> Для того, чтобы скомпилировать программу нам нужен компилятор. Работа компилятора состоит из двух частей:
>
> * Проверка программы на соответствие правилам языка C++ (проверка синтаксиса). Если она будет неудачной, то компилятор выдаст сообщения об ошибках, которые нужно будет исправить.
>
> * Конвертация каждого исходного файла с кодом в объектный файл (или «объектный модуль») на машинном языке. Объектные файлы, как правило, имеют названия name.o или name.obj, где name должно быть такое же как и имя вашего исходного файла .cpp. Если ваша программа состоит из 3-х файлов .cpp, то компилятор сгенерирует 3 объектных файла.

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/compile.jpg)

> Стоит отметить, что такие операционные системы как Linux и macOS имеют уже встроенный компилятор C++, который называется g++. Для компиляции файлов из командной строки с помощью g++ вам нужно будет прописать следующее:

`g++ -c file1.cpp file2.cpp file3.cpp`

> Таким образом мы создадим file1.o, file2.o и file3.o. -c означает «только скомпилировать», т.е. просто создать .o (объектные) файлы. Кроме g++, существует множество компиляторов для различных операционных систем: Linux, Windows, macOS и других.



* ## Шаг №5: Линкинг (связывание объектных файлов)

> Линкинг — это процесс связывания всех объектных файлов, генерируемых компилятором, в единую исполняемую программу, которую вы затем сможете запустить/выполнить. Это делается с помощью программы, которая называется линкер (или «компоновщик»).

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/linker.jpg)

> Кроме объектных файлов, линкер также подключает файлы из Стандартной библиотеки С++ (или любой другой библиотеки, которую вы используете, например, библиотеки графики или звука). Сам по себе язык С++ довольно маленький и простой. Тем не менее, к нему подключается большая библиотека дополнительных функций, которые могут использовать ваши программы, и эти функции находятся в Стандартной библиотеке C++. Например, если вы хотите вывести что-либо на экран, то у вас в коде должна быть специальная команда, которая сообщит компилятору, что вы хотите использовать функцию вывода информации на экран из Стандартной библиотеки C++.

> После того, как компоновщик закончит линкинг всех объектных файлов (при условии, что не будет ошибок), вы получите исполняемый файл. Опять же, в целях наглядности, чтобы связать .o файлы, которые мы создали выше в Linux или macOS, мы можем снова использовать g++:

`g++ -o prog file1.o file2.o file3.o`

> Команда -o сообщает g++, что мы хотим получить исполняемый файл с именем prog из следующих файлов: file1.o, file2.o и file3.o. При желании, компиляцию и линкинг можно объединить в один шаг:

`g++ -o prog file1.cpp file2.cpp file3.cpp`

> sРезультатом будет исполняемый файл с именем prog.


* ## Шаг №6: Тестирование и отладка

> Здесь начинается самое веселое! Вы уже можете запустить исполняемый файл и посмотреть, работает ли всё так, как надо. Если нет, то пришло время отладки. Более подробно об отладке мы поговорим чуть позже.

> Обратите внимание, для выполнения шагов №3-№6 вам потребуется специальное программное обеспечение. Хотя вы можете использовать отдельные программы на каждом из этих шагов, один пакет программного обеспечения («IDE» от англ. «Integrated Development Environment») объединяет в себе все эти программы. Обычно с IDE вы получаете редактор кода с нумерацией строк и подсветкой синтаксиса, а также компилятор и линкер. А когда вам нужно будет провести отладку программы, вы сможете использовать встроенный отладчик. Кроме того, IDE объединяет и ряд других полезных возможностей: комплексная помощь, дополнение кода, в некоторых случаях еще и система контроля версий.

___






















