# Все про С++ из сайта ravesli.com

Сдесь я собрал всю информацию про С++ (на 2021 год) из онлайн-учебника ravesli. Цель: удобство, а также [pdf файл](http://github.com/bozich/bozich/raw/master/articles/ravesli-cpp/index.pdf) в репозитории [GitHub](http://github.com/bozich/bozich/tree/master/articles/ravesli-cpp/)

Веб-Сайт автора: [bozich.github.io](http://bozich.github.io).

Что-ж, начнем!

# Оглавление:

> ### [Глава №0. Введение. Начало работы]()
> * [Урок №1. Введение в программирование]()
> * [Урок №2. Введение в языки программирования C и С++]()
> * [Урок №3. Введение в разработку программного обеспечения]()
> * [Урок №4. Установка IDE (Интегрированной Среды Разработки)]()
> * [Урок №5. Компиляция вашей первой программы]()
> * [Урок №6. Режимы конфигурации «Debug» и «Release»]()
> * [Конфигурация компилятора: Расширения компилятора]()
> * [Конфигурация компилятора: Уровни предупреждений и ошибки]()
> * [Конфигурация компилятора: Выбор стандарта языка С++]()
> * [Урок №7. Решения самых распространенных проблем]()

> ### [Глава №1. Основы C++]()
> * [Урок №8. Структура программ]()
> * [Урок №9. Комментарии]()
> * [Урок №10. Переменные, Инициализация и Присваивание]()
> * [Урок №11. cout, cin и endl]()
> * [Урок №12. Функции и оператор возврата return]()
> * [Урок №13. Параметры и аргументы функций]()
> * [Урок №14. Почему функции — полезны, и как их эффективно использовать?]()
> * [Урок №15. Локальная область видимости]()
> * [Урок №16. Ключевые слова и идентификаторы]()
> * [Урок №17. Операторы]()
> * [Урок №18. Базовое форматирование кода]()
> * [Урок №19. Прототип функции и Предварительное объявление]()
> * [Урок №20. Многофайловые программы]()
> * [Урок №21. Заголовочные файлы]()
> * [Урок №22. Директивы препроцессора]()
> * [Урок №23. Header guards и #pragma once]()
> * [Урок №24. Конфликт имен и std namespace]()
> * [Урок №25. Разработка ваших первых программ]()
> * [Урок №26. Отладка программ: степпинг и точки останова]()
> * [Урок №27. Отладка программ: стек вызовов и отслеживание переменных]()
> * [Глава №1. Итоговый тест]()

> ### [Глава №2. Переменные и основные типы данных в C++]()
> * [Урок №28. Инициализация, присваивание и объявление переменных]()
> * [Урок №29. Тип данных void]()
> * [Урок №30. Размер типов данных]()
> * [Урок №31. Целочисленные типы данных: short, int и long]()
> * [Урок №32. Фиксированный размер целочисленных типов данных]()
> * [Урок №33. Типы данных с плавающей точкой: float, double и long double]()
> * [Урок №34. Логический тип данных bool]()
> * [Урок №35. Символьный тип данных char]()
> * [Урок №36. Литералы и магические числа]()
> * [Урок №37. const, constexpr и символьные константы]()
> * [Глава №2. Итоговый тест]()

> ### [Глава №3. Операторы в C++]()
> * [Урок №38. Приоритет операций и правила ассоциативности]()
> * [Урок №39. Арифметические операторы]()
> * [Урок №40. Инкремент, декремент и побочные эффекты]()
> * [Урок №41. Условный тернарный оператор, оператор sizeof и Запятая]()
> * [Урок №42. Операторы сравнения]()
> * [Урок №43. Логические операторы: И, ИЛИ, НЕ]()
> * [Урок №44. Конвертация чисел из двоичной системы в десятичную и наоборот]()
> * [Урок №45. Побитовые операторы]()
> * [Урок №46. Битовые флаги и битовые маски]()
> * [Глава №3. Итоговый тест]()

> ### [Глава №4. Область видимости и другие типы переменных в C++]()
> * [Урок №47. Блоки стейтментов (составные операторы)]()
> * [Урок №48. Локальные переменные, область видимости и продолжительность жизни]()
> * [Урок №49. Глобальные переменные]()
> * [Урок №50. Почему глобальные переменные – зло?]()
> * [Урок №51. Статические переменные]()
> * [Урок №52. Связи, область видимости и продолжительность жизни]()
> * [Урок №53. Пространства имен]()
> * [Урок №54. using-стейтменты]()
> * [Урок №55. Неявное преобразование типов данных]()
> * [Урок №56. Явное преобразование типов данных]()
> * [Урок №57. Введение в std::string]()
> * [Урок №58. Перечисления]()
> * [Урок №59. Классы enum]()
> * [Урок №60. Псевдонимы типов: typedef и type alias]()
> * [Урок №61. Структуры]()
> * [Урок №62. Вывод типов: ключевое слово auto]()
> * [Глава №4. Итоговый тест]()

> ### [Глава №5. Порядок выполнения кода в программе. Циклы, ветвления в C++]()
> * [Урок №63. Операторы управления потоком выполнения программ]()
> * [Урок №64. Операторы условного ветвления if/else]()
> * [Урок №65. Оператор switch]()
> * [Урок №66. Оператор goto]()
> * [Урок №67. Цикл while]()
> * [Урок №68. Цикл do while]()
> * [Урок №69. Цикл for]()
> * [Урок №70. Операторы break и continue]()
> * [Урок №71. Генерация случайных чисел]()
> * [Урок №72. Обработка некорректного пользовательского ввода]()
> * [Урок №73. Введение в тестирование кода]()
> * [Глава №5. Итоговый тест]()

> ### [Глава №6. Массивы, Строки, Указатели и Ссылки в C++]()
> * [Урок №74. Массивы]()
> * [Урок №75. Фиксированные массивы]()
> * [Урок №76. Массивы и циклы]()
> * [Урок №77. Сортировка массивов методом выбора]()
> * [Урок №78. Многомерные массивы]()
> * [Урок №79. Строки C-style]()
> * [Введение в класс std::string_view в С++]()
> * [Урок №80. Указатели]()
> * [Урок №81. Нулевые указатели]()
> * [Урок №82. Указатели и массивы]()
> * [Урок №83. Адресная арифметика и индексация массивов]()
> * [Урок №84. Символьные константы строк C-style]()
> * [Урок №85. Динамическое выделение памяти]()
> * [Урок №86. Динамические массивы]()
> * [Урок №87. Указатели и const]()
> * [Урок №88. Ссылки]()
> * [Урок №89. Ссылки и const]()
> * [Урок №90. Оператор доступа к членам через указатель]()
> * [Урок №91. Цикл foreach]()
> * [Урок №92. Указатели типа void]()
> * [Урок №93. Указатели на указатели]()
> * [Урок №94. Введение в std::array]()
> * [Урок №95. Введение в std::vector]()
> * [Введение в итераторы в С++]()
> * [Алгоритмы в Стандартной библиотеке С++]()
> * [Глава №6. Итоговый тест]()


> ### [Глава №7. Функции в C++]()
> * [Урок №96. Параметры и аргументы функций]()
> * [Урок №97. Передача по значению]()
> * [Урок №98. Передача по ссылке]()
> * [Урок №99. Передача по адресу]()
> * [Урок №100. Возврат значений по ссылке, по адресу и по значению]()
> * [Урок №101. Встроенные функции]()
> * [Урок №102. Перегрузка функций]()
> * [Урок №103. Параметры по умолчанию]()
> * [Урок №104. Указатели на функции]()
> * [Урок №105. Стек и Куча]()
> * [Урок №106. Ёмкость вектора]()
> * [Урок №107. Рекурсия и Числа Фибоначчи]()
> * [Урок №108. Обработка ошибок, cerr и exit()]()
> * [Урок №109. assert и static_assert]()
> * [Урок №110. Аргументы командной строки]()
> * [Урок №111. Эллипсис]()
> * [Лямбда-выражения в С++]()
> * [Лямбда-захваты в С++]()
> * [Глава №7. Итоговый тест]()


> ### [Глава №8. Основы ООП в C++]()
Урок №112. Введение в ООП> * []()
> * [Урок №113. Классы, Объекты и Методы]()
> * [Урок №114. Спецификаторы доступа public и private]()
> * [Урок №115. Инкапсуляция, Геттеры и Сеттеры]()
> * [Урок №116. Конструкторы]()
> * [Урок №117. Список инициализации членов класса]()
> * [Урок №118. Инициализация нестатических членов класса]()
> * [Урок №119. Делегирующие конструкторы]()
> * [Урок №120. Деструкторы]()
> * [Урок №121. Скрытый указатель *this]()
> * [Урок №122. Классы и заголовочные файлы]()
> * [Урок №123. Классы и const]()
> * [Урок №124. Статические переменные-члены класса]()
> * [Урок №125. Статические методы класса]()
> * [Урок №126. Дружественные функции и классы]()
> * [Урок №127. Анонимные объекты]()
> * [Урок №128. Вложенные типы данных в классах]()
> * [Урок №129. Измерение времени выполнения (тайминг) кода]()
> * [Глава №8. Итоговый тест]()

> ### [Глава №9. Перегрузка операторов в C++]()
> * [Урок №130. Введение в перегрузку операторов]()
> * [Урок №131. Перегрузка операторов через дружественные функции]()
> * [Урок №132. Перегрузка операторов через обычные функции]()
> * [Урок №133. Перегрузка операторов ввода и вывода]()
> * [Урок №134. Перегрузка операторов через методы класса]()
> * [Урок №135. Перегрузка унарных операторов +, — и логического НЕ]()
> * [Урок №136. Перегрузка операторов сравнения]()
> * [Урок №137. Перегрузка операторов инкремента и декремента]()
> * [Урок №138. Перегрузка оператора индексации []]()
> * [Урок №139. Перегрузка оператора ()]()
> * [Урок №140. Перегрузка операций преобразования типов данных]()
> * [Урок №141. Конструктор копирования]()
> * [Урок №142. Копирующая инициализация]()
> * [Урок №143. Конструкторы преобразования, ключевые слова explicit и delete]()
> * [Урок №144. Перегрузка оператора присваивания]()
> * [Урок №145. Поверхностное и глубокое копирование]()
> * [Глава №9. Итоговый тест]()

> ### [Глава №10. Введение в связи между объектами в C++]()
> * [Урок №146. Типы связей между объектами]()
> * [Урок №147. Композиция объектов]()
> * [Урок №148. Агрегация]()
> * [Урок №149. Ассоциация]()
> * [Урок №150. Зависимость]()
> * [Урок №151. Контейнерные классы]()
> * [Урок №152. Список инициализации std::initializer_list]()
> * [Глава №10. Итоговый тест]()

> ### [Глава №11. Наследование в C++]()
> * [Урок №153. Введение в Наследование]()
> * [Урок №154. Базовое наследование]()
> * [Урок №155. Порядок построения дочерних классов]()
> * [Урок №156. Конструкторы и инициализация дочерних классов]()
> * [Урок №157. Наследование и спецификатор доступа protected]()
> * [Урок №158. Добавление нового функционала в дочерний класс]()
> * [Урок №159. Переопределение методов родительского класса]()
> * [Урок №160. Сокрытие методов родительского класса]()
> * [Урок №161. Множественное наследование]()
> * [Глава №11. Итоговый тест]()

> ### [Глава №12. Виртуальные функции в C++]()
> * [Урок №162. Указатели, Ссылки и Наследование]()
> * [Урок №163. Виртуальные функции и Полиморфизм]()
> * [Урок №164. Модификаторы override и final]()
> * [Урок №165. Виртуальные деструкторы и Виртуальное присваивание]()
> * [Урок №166. Раннее и Позднее Связывания]()
> * [Урок №167. Виртуальные таблицы]()
> * [Урок №168. Чистые виртуальные функции, Интерфейсы и Абстрактные классы]()
> * [Урок №169. Виртуальный базовый класс]()
> * [Урок №170. Обрезка объектов]()
> * [Урок №171. Динамическое приведение типов. Оператор dynamic_cast]()
> * [Урок №172. Вывод объектов классов через оператор вывода]()
> * [Глава №12. Итоговый тест]()

> ### [Глава №13. Шаблоны в C++]()
> * [Урок №173. Шаблоны функций]()
> * [Урок №174. Экземпляры шаблонов функций]()
> * [Урок №175. Шаблоны классов]()
> * [Урок №176. Параметр non-type в шаблоне]()
> * [Урок №177. Явная специализация шаблона функции]()
> * [Урок №178. Явная специализация шаблона класса]()
> * [Урок №179. Частичная специализация шаблона]()
> * [Урок №180. Частичная специализация шаблонов и Указатели]()
> * [Глава №13. Итоговый тест]()


> ### [Глава №14. Исключения в C++]()
> * [Урок №181. Исключения. Зачем они нужны?]()
> * [Урок №182. Обработка исключений. Операторы throw, try и catch]()
> * [Урок №183. Исключения, Функции и Раскручивание стека]()
> * [Урок №184. Непойманные исключения и обработчики catch-all]()
> * [Урок №185. Классы-Исключения и Наследование]()
> * [Урок №186. Повторная генерация исключений]()
> * [Урок №187. Функциональный try-блок]()
> * [Урок №188. Недостатки и опасности использования исключений]()
> * [Глава №14. Итоговый тест]()

> ### [Глава №15. Умные указатели и Семантика перемещения в C++]()
> * [Урок №189. Умные указатели и Семантика перемещения]()
> * [Урок №190. Ссылки r-value]()
> * [Урок №191. Конструктор перемещения и Оператор присваивания перемещением]()
> * [Урок №192. Функция std::move()]()
> * [Урок №193. Умный указатель std::unique_ptr]()
> * [Урок №194. Умный указатель std::shared_ptr]()
> * [Урок №195. Умный указатель std::weak_ptr]()
> * [Глава №15. Итоговый тест]()

> ### [Глава №16. Стандартная библиотека шаблонов (STL) в С++]()
> * [Урок №196. Стандартная библиотека шаблонов (STL)]()
> * [Урок №197. Контейнеры STL]()
> * [Урок №198. Итераторы STL]()
> * [Урок №199. Алгоритмы STL]()

> ### [Глава №17. std::string в С++]()
> * [Урок №200. Строковые классы std::string и std::wstring]()
> * [Урок №201. Создание, уничтожение и конвертация std::string]()
> * [Урок №202. Длина и ёмкость std::string]()
> * [Урок №203. Доступ к символам std::string. Конвертация std::string в строки C-style]()
> * [Урок №204. Присваивание и перестановка значений с std::string]()
> * [Урок №205. Добавление к std::string]()
> * [Урок №206. Вставка символов и строк в std::string]()

> ### [Глава №18. Ввод/Вывод в С++]()
> * [Урок №207. Потоки ввода и вывода]()
> * [Урок №208. Функционал класса istream]()
> * [Урок №209. Функционал классов ostream и ios. Форматирование вывода]()
> * [Урок №210. Потоковые классы и Строки]()
> * [Урок №211. Состояния потока и валидация пользовательского ввода]()
> * [Урок №212. Базовый файловый ввод и вывод]()
> * [Урок №213. Рандомный файловый ввод и вывод]()

> ### [Дополнительные уроки]()
> * [Статические и динамические библиотеки]()
> * [Подключение и использование библиотек в Visual Studio]()
> * [C++11. Нововведения]()
> * [C++14. Нововведения]()
> * [C++17. Нововведения]()
> * [Спецификации исключений и спецификатор noexcept в С++]()
> * [Функция std::move_if_noexcept() в С++]()
> * [C++20. Нововведения]()
> * [Оператор трехстороннего сравнения в С++]()
> * [C++20. Два новых ключевых слова: consteval и constinit]()
> * [C++20. Библиотека chrono и Время суток]()

> ## [Финал]
> * [Конец? Что дальше?]()


> ### [Пошаговое создание игры на С++/MFC]
> * [Урок №1: Введение в создание игры «SameGame» на C++/MFC]()
> * [Урок №2: Архитектура и хранение данных в игре «SameGame» на C++/MFC]()
> * [Урок №3: Отрисовка игры «SameGame» на C++/MFC]()
> * [Урок №4: Обработка событий в игре «SameGame» на C++/MFC]()
> * [Урок №5: Работа с алгоритмом в игре «SameGame» на C++/MFC]()
> * [Урок №6: Работа с меню в игре «SameGame» на C++/MFC]()
> * [Урок №7: Добавление уровней сложности в игре «SameGame» на C++/MFC]()
> * [Урок №8: Размеры и количество блоков в игре «SameGame» на C++/MFC]()
> * [Урок №9: Финальные штрихи в создании игры «SameGame» на C++/MFC]()

> ### [Практические задания по С++](
> * [Часть №1: Практические задания по С++]()
> * [Часть №2: Практические задания по С++]()
> * [Часть №3: Практические задания по С++]()
> * [Часть №4: Практические задания по С++]()
> * [Часть №5: Практические задания по С++]()
> * [Часть №6: Практические задания по С++]()
> * [Часть №7: Практические задания по С++]()
> * [Часть №8: Практические задания по С++]()
> * [Часть №9: Практические задания по С++]()
> * [Часть №10: Практические задания по С++]()
> * [Часть №11: Практические задания по С++]()
> * [Часть №12: Практические задания по С++]()
> * [Часть №13: Практические задания по С++]()
> * [Часть №14: Практические задания по С++]()
> * [Часть №15: Практические задания по С++]()
> * [Часть №16: Практические задания по С++]()
> * [Часть №17: Практические задания по С++]()
> * [Часть №18: Практические задания по С++]()
> * [Часть №19: Практические задания по С++]()
> * [Часть №20: Практические задания по С++]()
> * [Часть №21: Практические задания по С++]()
> * [Часть №22: Практические задания по С++]()
> * [Часть №23: Практические задания по С++]()
> * [Часть №24: Практические задания по С++]()

> ### [Уроки по графической библиотеке SFML]()
> * [Вступление и установка графической библиотеки SFML в C++]()
> * [Создание простых геометрических фигур в C++/SFML]()
> * [Спрайты и текстуры в C++/SFML]()
> * [Часть №1: Создание игры «Тетрис» на С++/SFML]()
> * [Часть №2: Создание игры «Тетрис» на С++/SFML]()
> * [Часть №3: Создание игры «Тетрис» на С++/SFML]()
> * [Создание игры «Сапер» на С++/SFML]()
> * [Создание игры «Пятнашки» на C++/SFML]()

**Примечание: Это авторские уроки Дмитрия Бушуева!**



___
___
___

# Глава №0. Введение. Начало работы
---
# Урок №1. Введение в программирование

> Компьютеры понимают только очень ограниченный набор инструкций, и чтобы заставить их что-то делать, нужно четко сформулировать задание, используя эти же инструкции. Программа (также «приложение» или «программное обеспечение», или «софт») — это набор инструкций, которые указывают компьютеру, что ему нужно делать. Физическая часть компьютера, которая выполняет эти инструкции, называется «железом» или аппаратной частью (например, процессор, материнская плата и т.д.). Данный урок является началом серии уроков по программированию на языке С++ для начинающих.


> Оглавление:
>
> 1. [Машинный язык]()
> 2. [Язык ассемблера]()
> 3. [Высокоуровневые языки программирования]()
> 4. [Преимущества высокоуровневых языков программирования]()

# Машинный язык

> Процессор компьютера не способен понимать напрямую языки программирования, такие как C++, Java, Python и т.д. Очень ограниченный набор инструкций, которые изначально понимает процессор, называется машинным кодом (или «машинным языком»). То, как эти инструкции организованы, выходит за рамки данного введения, но стоит отметить две вещи.

> Во-первых, каждая команда (инструкция) состоит только из определенной последовательности (набора) цифр: 0 и 1. Эти числа называются битами (сокр. от «binary digit») или двоичным кодом.

> Например, одна команда машинного кода архитектуры ×86 выглядит следующим образом:

`10110000 01100001`

> Во-вторых, каждый набор бит переводится процессором в инструкции для выполнения определенного задания (например, сравнить два числа или переместить число в определенную ячейку памяти). Разные типы процессоров обычно имеют разные наборы инструкций, поэтому инструкции, которые будут работать на процессорах Intel (используются в персональных компьютерах), с большей долей вероятности, не будут работать на процессорах Xenon (используются в игровых приставках Xbox). Раньше, когда компьютеры только начинали массово распространяться, программисты должны были писать программы непосредственно на машинном языке, что было очень неудобно, сложно и занимало намного больше времени, чем сейчас.

# Язык ассемблера

> Так как программировать на машинном языке — удовольствие специфическое, то программисты изобрели язык ассемблера. В этом языке каждая команда идентифицируется коротким именем (а не набором единиц с нулями), и переменными можно управлять через их имена. Таким образом, писать/читать код стало гораздо легче. Тем не менее, процессор все равно не понимает язык ассемблера напрямую. Его также нужно переводить, с помощью ассемблера, в машинный код. Ассемблер — это транслятор (переводчик), который переводит код, написанный на языке ассемблера, в машинный язык. В Интернете язык ассемблера часто называют просто «Ассемблер».

> Преимуществом Ассемблера является его производительность (точнее скорость выполнения) и он до сих пор используется, когда это имеет решающее значение. Тем не менее, причина подобного преимущества заключается в том, что программирование на этом языке адаптируется к конкретному процессору. Программы, адаптированные под один процессор, не будут работать с другим. Кроме того, чтобы программировать на Ассемблере, по-прежнему нужно знать очень много не очень читабельных инструкций для выполнения даже простого задания.

Например, вот вышеприведенная команда, но уже на языке ассемблера:

`mov al, 061h`

# Высокоуровневые языки программирования

> Для решения проблем читабельности кода и чрезмерной сложности были разработаны высокоуровневые языки программирования. C, C++, Pascal, Java, JavaScript и Perl — это всё языки высокого уровня. Они позволяют писать и выполнять программы, не переживая о совместимости кода с разными архитектурами процессоров. Программы, написанные на языках высокого уровня, также должны быть переведены в машинный код перед выполнением. Есть два варианта:
> 
>   * компиляция, которая выполняется компилятором;
>
>   * интерпретация, которая выполняется интерпретатором.

> **Компилятор** — это программа, которая читает код и создает автономную (способную работать независимо от другого аппаратного или программного обеспечения) исполняемую программу, которую процессор понимает напрямую. При запуске программы весь код компилируется целиком, а затем создается исполняемый файл и уже при повторном запуске программы компиляция не выполняется.

> Проще говоря, процесс компиляции выглядит следующим образом:

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/sxemagotovoOk.jpg)

> **Интерпретатор** — это программа, которая напрямую выполняет код, без его предыдущей компиляции в исполняемый файл. Интерпретаторы более гибкие, но менее эффективные, так как процесс интерпретации выполняется повторно при каждом запуске программы.

Процесс интерпретации: 

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/sxemagotovo22Ok.jpg)

> Любой язык программирования может быть компилируемым или интерпретируемым, однако, такие языки, как C, C++ и Pascal — компилируются, в то время как «скриптовые» языки, такие, как Perl и JavaScript — интерпретируются. Некоторые языки программирования (например, Java) могут как компилироваться, так и интерпретироваться.


# Преимущества высокоуровневых языков программирования

* ***Преимущество №1***: Легче писать/читать код. Вот вышеприведенная команда, но уже на языке C++:

`а = 97;`

* ***Преимущество №2***: Требуется меньше инструкций для выполнения определенного задания. В языке C++ вы можете сделать что-то вроде а = Ь * 2 + 5; в одной строке. В языке ассемблера вам пришлось бы использовать 5 или 6 инструкций.

* ***Преимущество №3***: Вы не должны заботиться о таких деталях, как загрузка переменных в регистры процессора. Компилятор или интерпретатор берёт это на себя.

* ***Преимущество №4***: Высокоуровневые языки программирования более портируемые под различные архитектуры (но есть один нюанс).

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/sxemagotovo33.jpg)

> Нюанс заключается в том, что многие платформы, такие как Microsoft Windows, имеют свои собственные специфические функции, с помощью которых писать код намного легче. Но в таком случае приходится жертвовать портируемостью, так как функции, специфические для одной платформы, с большей долей вероятности, не будут работать на другой платформе. Обо всем этом мы детально поговорим на следующих уроках.

___
# Урок №2. Введение в языки программирования C и С++

> Перед C++ был C. C (произносится как «Си») был разработан в 1972 году Деннисом Ритчи в Bell Telephone Laboratories как системный язык программирования, т.е. язык для написания операционных систем. Основной задачей Ритчи было создание легко компилируемого минималистического языка, который предоставлял бы эффективный доступ к памяти, относительно быстро выполнялся, и на котором можно было бы писать эффективный код. Таким образом, при разработке высокоуровневого языка, был создан язык Си, который во многом относился к языкам низкого уровня, оставаясь при этом независимым от платформ, для которых мог быть написан код.

> Cи в конечном итоге стал настолько эффективным и гибким, что в 1973 году Ритчи и Кен Томпсон переписали больше половины операционной системы UNIX, используя этот язык. Многие предыдущие операционные системы были написаны на языке ассемблера. В отличие от Ассемблера, на котором пишутся программы под конкретные процессоры, высокая портируемость языка Cи позволила перекомпилировать UNIX и на другие типы компьютеров, ускоряя его популяризацию. Язык Cи и операционная система UNIX тесно связаны между собой, и популярность первого отчасти связана с успехом второго.

> В 1978 году Брайан Керниган и Деннис Ритчи опубликовали книгу под названием «Язык программирования Cи». Эта книга, более известна как «K&R» (первые буквы фамилий авторов), стала стандартом и своеобразной инструкцией к Си. Когда требовалась максимальная портируемость, то программисты придерживались рекомендаций в «K&R», поскольку большинство компиляторов в то время были реализованы в соответствии со стандартами, присутствующими в этой книге.

> В 1983 году Американский национальный институт стандартов (сокр. «ANSI» от англ. «American National Standards Institute») сформировал комитет для утверждения официального стандарта языка Cи. В 1989 году они закончили и выпустили стандарт C89, более широко известный, как ANSI C. В 1990 году Международная организация по стандартизации (сокр. «ISO» от англ. «International Organization for Standardization») приняла ANSI C (с небольшими изменениями). Эта версия языка Cи стала известна как C90. В конечном счете, компиляторы адаптировались под требования ANSI C/C90 и программы, в которых требовалась максимальная портируемость, писались в соответствие с этими стандартами.

> В 1999 году комитет ANSI выпустил новую версию языка Cи, которая получила название C99. Она приняла много особенностей, которые были реализованы в компиляторах (в виде различных расширений) или уже в языке C++.

## Язык C++
> C++ (произносится как «Си плюс плюс») был разработан Бьёрном Страуструпом в Bell Labs в качестве дополнения к Cи в 1979 г. Он добавил множество новых фич в язык Си. Его популярность была вызвана объектно-ориентированностью языка. Об объектно-ориентированном программировании (ООП) и его отличиях от традиционных методов программирования мы поговорим несколько позже.

> Язык C++ был ратифицирован (одобрен) комитетом ISO в 1998 году и потом снова в 2003 году (под названием C++03). Потом были еще три обновления (C++11, C++14 и C++17, ратифицированные в 2011, 2014 и 2017 годах, соответственно), которые добавили больше функциональных возможностей.

> Философия С и С++

> Смысл философии языков С и C++ можно определить выражением «доверять программисту». Например, компилятор не будет вам мешать сделать что-то новое, что имеет смысл, но также не будет мешать вам сделать что-то такое, что может привести к сбою. Это одна из главных причин, почему так важно знать то, что вы не должны делать, как и то, что вы должны делать, создавая программы на языках С/С++.

___
# Урок №3. Введение в разработку программного обеспечения

> Перед написанием и выполнением нашей первой программы, мы должны понять, как вообще выполняется разработка программного обеспечения на языке C++.

Схема разработки ПО (сокр. от «Программное Обеспечение»):

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/Razrabotka-programmnyh-produktov.jpg)

> ## Оглавление:
> 1. [Шаг №1: Определите проблему, которую хотели бы решить]()
> 2. [Шаг №2: Определитесь, как вы собираетесь решить эту проблему]()
> 3. [Шаг №3: Напишите программу]()
> 4. [Шаг №4: Компиляция]()
> 5. [Шаг №5: Линкинг (связывание объектных файлов)]()
> 6. [Шаг №6: Тестирование и отладка]()

* ## Шаг №1: Определите проблему, которую хотели бы решить

> Это шаг «Что?». Здесь вы должны понять, что же вы хотите, чтобы ваша программа делала. Этот шаг может быть, как самым простым, так и самым сложным. Всё, что вам нужно — это четко сформулировать идею. Только после этого вы сможете приступать к следующему шагу.

> Вот несколько примеров выполнения шага №1:
> 
>  * «Я хочу написать программу, которая вычисляла бы среднее арифметическое чисел, которые я введу».
> 
>  * «Я хочу написать программу, в которой будет 2D-лабиринт, по которому сможет передвигаться пользователь».
>
>  * «Я хочу написать программу, которая будет анализировать цены акций на бирже и давать предсказания по поводу скачков этих цен вверх или вниз».

* ## Шаг №2: Определитесь, как вы собираетесь решить эту проблему

> Здесь мы уже отвечаем на вопрос «Как?». Каким образом можно решить проблему, обозначенную на шаге №1? Этим шагом довольно часто пренебрегают при разработке программного обеспечения. Суть в том, что способов решения задачи может быть много, только часть из них — хорошие решения, а часть — плохие. Вы должны научиться отделять первые от вторых. Очень часто можно наблюдать ситуацию, когда у программиста возникает идея и он сразу же садится программировать. Как вы уже могли догадаться, такой сценарий далеко не всегда приводит к эффективным результатам.

> Как правило, хорошие решения имеют следующие характеристики:
> 
> *   простота;
> 
> *   хорошая документация (с инструкциями и комментариями);
> 
> *   модульный принцип: любая часть программы может быть повторно использована или изменена позже, не затрагивая другие части кода;
> 
> *   надежность: соответствующая обработка ошибок и экстренных ситуаций.

> Когда вы садитесь и начинаете сразу программировать, вы думаете: «Я хочу сделать это, вот это и еще вот это!». Таким образом вы принимаете решения, которые позволят вам поскорее выполнить задание. Однако это может привести к тому, что вы получите программу, которую позже будет трудно изменить/модифицировать, добавить что-то новое или вам попросту придется разбираться с большим количеством багов.

> Согласно закону Парето, программист тратит примерно 20% времени на написание программы и 80% на отладку (исправление ошибок) или поддержку (добавление новых функциональных возможностей) кода. Следовательно, лучше потратить дополнительное время на обдумывание лучшего способа решения проблемы перед процессом написания кода, нежели потом тратить оставшиеся 80% времени на поиск и исправление ошибок.

* ## Шаг №3: Напишите программу

> **Для того, чтобы написать программу, необходимы две вещи:**
> 
> *  знание определенного **языка программирования** (этому мы вас научим);
> 
> *   **редактор кода**.

> Программу можно написать, используя любой редактор, даже тот же Блокнот в Windows или текстовый редактор Vi в Unix. Тем не менее, я настоятельно рекомендую использовать редактор, предназначенный для программирования. Не беспокойтесь, если у вас его еще нет. На следующем уроке мы рассмотрим процесс установки такого приложения.

> **Редактор типичного программиста, как правило, имеет следующие особенности, которые облегчают программирование:**
> 
> * **Нумерация строк**. Это функция чрезвычайно полезна при отладке программ, когда компилятор выдаёт нам сообщения об ошибках. Типичная ошибка компиляции состоит из наименования ошибки и номера строки, где эта ошибка произошла (например, «ошибка переопределения переменной x, строка 90»). Без нумерации строк искать ту самую 90-ю строку кода было бы несколько затруднительно, не так ли?
> 
> * **Подсветка синтаксиса**. Подсветка синтаксиса изменяет цвет разных частей программы и кода, что улучшает восприятие как целой программы, так и её отдельных частей.
> 
> * **Специальный шрифт**. В обычных шрифтах очень часто возникает путаница между определенными символами, когда непонятно, какой символ перед вами. Например: цифра 0 или буква O, цифра 1 или буква l (нижний регистр L), или может буква I (верхний регистр i). Вот для этого и нужен специальный шрифт, в котором будет легко различить эти символы, предотвращая случайное использование одного символа вместо другого.

> Программы на языке C++ следует называть name.cpp, где name заменяется именем вашей программы, а расширение .cpp сообщает компилятору (и вам тоже), что это исходный файл кода, который содержит инструкции на языке программирования C++. Следует обратить внимание, что некоторые программисты используют расширение .cc вместо .cpp, но я рекомендую использовать именно .cpp.

> Также стоит отметить, что много программ, написанных на языке C++, могут состоять из нескольких файлов .cpp. Хотя большинство программ, которые вы будете создавать на протяжении этих уроков, не будут слишком большими, в дальнейшем вы научитесь писать программы, которые будут включать десятки, если не сотни отдельных файлов .cpp.


* ## Шаг №4: Компиляция

> Для того, чтобы скомпилировать программу нам нужен компилятор. Работа компилятора состоит из двух частей:
>
> * Проверка программы на соответствие правилам языка C++ (проверка синтаксиса). Если она будет неудачной, то компилятор выдаст сообщения об ошибках, которые нужно будет исправить.
>
> * Конвертация каждого исходного файла с кодом в объектный файл (или «объектный модуль») на машинном языке. Объектные файлы, как правило, имеют названия name.o или name.obj, где name должно быть такое же как и имя вашего исходного файла .cpp. Если ваша программа состоит из 3-х файлов .cpp, то компилятор сгенерирует 3 объектных файла.

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/compile.jpg)

> Стоит отметить, что такие операционные системы как Linux и macOS имеют уже встроенный компилятор C++, который называется g++. Для компиляции файлов из командной строки с помощью g++ вам нужно будет прописать следующее:

`g++ -c file1.cpp file2.cpp file3.cpp`

> Таким образом мы создадим file1.o, file2.o и file3.o. -c означает «только скомпилировать», т.е. просто создать .o (объектные) файлы. Кроме g++, существует множество компиляторов для различных операционных систем: Linux, Windows, macOS и других.



* ## Шаг №5: Линкинг (связывание объектных файлов)

> Линкинг — это процесс связывания всех объектных файлов, генерируемых компилятором, в единую исполняемую программу, которую вы затем сможете запустить/выполнить. Это делается с помощью программы, которая называется линкер (или «компоновщик»).

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/linker.jpg)

> Кроме объектных файлов, линкер также подключает файлы из Стандартной библиотеки С++ (или любой другой библиотеки, которую вы используете, например, библиотеки графики или звука). Сам по себе язык С++ довольно маленький и простой. Тем не менее, к нему подключается большая библиотека дополнительных функций, которые могут использовать ваши программы, и эти функции находятся в Стандартной библиотеке C++. Например, если вы хотите вывести что-либо на экран, то у вас в коде должна быть специальная команда, которая сообщит компилятору, что вы хотите использовать функцию вывода информации на экран из Стандартной библиотеки C++.

> После того, как компоновщик закончит линкинг всех объектных файлов (при условии, что не будет ошибок), вы получите исполняемый файл. Опять же, в целях наглядности, чтобы связать .o файлы, которые мы создали выше в Linux или macOS, мы можем снова использовать g++:

`g++ -o prog file1.o file2.o file3.o`

> Команда -o сообщает g++, что мы хотим получить исполняемый файл с именем prog из следующих файлов: file1.o, file2.o и file3.o. При желании, компиляцию и линкинг можно объединить в один шаг:

`g++ -o prog file1.cpp file2.cpp file3.cpp`

> sРезультатом будет исполняемый файл с именем prog.


* ## Шаг №6: Тестирование и отладка

> Здесь начинается самое веселое! Вы уже можете запустить исполняемый файл и посмотреть, работает ли всё так, как надо. Если нет, то пришло время отладки. Более подробно об отладке мы поговорим чуть позже.

> Обратите внимание, для выполнения шагов №3-№6 вам потребуется специальное программное обеспечение. Хотя вы можете использовать отдельные программы на каждом из этих шагов, один пакет программного обеспечения («IDE» от англ. «Integrated Development Environment») объединяет в себе все эти программы. Обычно с IDE вы получаете редактор кода с нумерацией строк и подсветкой синтаксиса, а также компилятор и линкер. А когда вам нужно будет провести отладку программы, вы сможете использовать встроенный отладчик. Кроме того, IDE объединяет и ряд других полезных возможностей: комплексная помощь, дополнение кода, в некоторых случаях еще и система контроля версий.

___

# Урок №4. Установка IDE (Интегрированной Среды Разработки)

> Интегрированная Среда Разработки («IDE» от «Integrated Development Environment») — это программное обеспечение, которое содержит всё необходимое для разработки, компиляции, линкинга и отладки кода. Нам нужно установить одну такую IDE для написания программ на языке С++.

Но какую именно? Я рекомендую Visual Studio от Microsoft (для пользователей Windows) или Code::Blocks (для пользователей Linux/Windows). Также вы можете установить и любую другую IDE. Основные концепции, рассматриваемые в данных уроках, должны работать во всех средах разработки. Впрочем, иногда код может частично отличаться в разных IDE, поэтому вам придется самостоятельно искать более подробную информацию о работе в выбранной вами IDE.
___
> ## Оглавление:
> 1. [IDE для пользователей Windows]()
> 2. [IDE для пользователей Linux/Windows]()
> 3. [IDE для пользователей macOS]()
> 4. [Веб-компиляторы]()
___

## IDE для пользователей Windows

Если вы пользователь Windows (как и большинство из нас), то установите Visual Studio 2019 версию «Community», которая является бесплатной (все остальные версии — платные):

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/05/download-IDE.jpg)

После того, как вы скачаете и запустите установщик, вам нужно будет выбрать "Разработка классических приложений на C++". Пункты, выбранные по умолчанию в правой части экрана, трогать не нужно — там всё хорошо, только убедитесь, что поставлена галочка возле пункта "Пакет SDK для Windows 10". Этот пакет может использоваться и в ранних версиях Windows, поэтому не переживайте, если у вас Windows 7 или Windows 8 — всё будет работать. Затем нажимаем "Установить":

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/05/install-IDE.jpg)

При желании вы можете указать галочки и возле других пунктов для скачивания, но учтите, что тогда размер вашей IDE будет увеличен.


## IDE для пользователей Linux/Windows

> Если вы пользователь Linux (или Windows, но хотите писать программы, которые затем можно будет легко портировать в Linux), то установите Code::Blocks. Это бесплатная, кроссплатформенная IDE, которая работает как в Linux, так и в Windows.

Пользователям Windows нужно загружать версию с MinGW в комплекте: 

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/05/download_Code-Blocks.jpg)

Установка простая: просто соглашаетесь со всем, о чём вас спрашивают. Функционал C++11/C++14 в Code::Blocks по умолчанию может быть отключен. Чтобы его использовать, вам нужно перейти в "Settings" > "Compiler":

![](https://ravesli.com/wp-content/uploads/2016/05/compiler-CodeBlocks.jpg)

И во вкладке "Compiler Flags" поставить галочку возле пункта "Have g++ follow the C++14 ISO C++ language standard [-std=c++14]", затем нажать "OK":

![](https://ravesli.com/wp-content/uploads/2016/05/screen2.jpg)

> Примечание: После установки Code::Blocks у некоторых пользователей может появиться следующее сообщение об ошибке: Can’t find compiler executable in your configured search paths for GNU GCC Compiler. Если вы столкнулись с этим, то попробуйте выполнить следующее:
> *   Если вы пользователь Windows, убедитесь, что вы загрузили версию Code::Blocks с MinGW (в названии скачиваемого установщика должно быть слово mingw).
> *   Попробуйте полностью удалить Code::Blocks, а затем установите его заново.
>    Перейдите в "Settings" > "Compiler" и выберите "Reset to defaults".
> *  Если ничего из вышеуказанного не помогло, попробуйте установить другую IDE.
>
> В качестве альтернативы подойдет Bloodshed’s Dev-C++, который также работает как в Windows, так и в Linux.

## IDE для пользователей macOS

Пользователи техники Apple могут использовать Xcode или Eclipse. Eclipse по умолчанию не настроен на использование языка C++, поэтому вам нужно будет дополнительно установить компоненты для C++.
Пользователи техники Apple могут использовать Xcode или Eclipse. Eclipse по умолчанию не настроен на использование языка C++, поэтому вам нужно будет дополнительно установить компоненты для C++.
## Веб-компиляторы

Веб-компиляторы подходят для написания простых, небольших программ. Их функционал ограничен: вы не сможете сохранять проекты, создавать исполняемые файлы или эффективно проводить отладку программ, поэтому лучше скачать полноценную IDE, если у вас действительно серьезные намерения по поводу программирования. А веб-компиляторы используйте разве что для быстрого запуска небольших программ.

**Популярные веб-компиляторы:**
   * OnlineGDB
   * TutorialsPoint
   * C++ Shell
   * Repl.it

Теперь, когда вы установили IDE, пора написать нашу первую программу!

___

## Урок №5. Компиляция вашей первой программы

Перед написанием нашей первой программы мы еще должны кое-что узнать.

> ## Оглавление:
> * [Теория]()
> * [Пользователям Visual Studio]()
> * [Пользователям Code::Blocks]()
> * [Пользователям командной строки]()
> * [Пользователям веб-компиляторов]()
> * [Пользователям других IDE]()
> * [Если компиляция прошла неудачно]()
> * [Заключение]()

## Теория

Во-первых, несмотря на то, что код ваших программ находится в файлах .cpp, эти файлы добавляются в проект. Проект содержит все необходимые файлы вашей программы, а также сохраняет указанные вами настройки вашей IDE. Каждый раз, при открытии проекта, он запускается с того момента, на котором вы остановились в прошлый раз. При компиляции программы, проект говорит компилятору и линкеру, какие файлы нужно скомпилировать, а какие связать. Стоит отметить, что файлы проекта одной IDE не будут работать в другой IDE. Вам придется создать новый проект (в другой IDE).

Во-вторых, есть разные типы проектов. При создании нового проекта, вам нужно будет выбрать его тип. Все проекты, которые мы будем создавать на данных уроках, будут консольного типа. Это означает, что они запускаются в консоли (аналог командной строки). По умолчанию, консольные приложения не имеют графического интерфейса пользователя — GUI (сокр. от «Graphical User Interface») и компилируются в автономные исполняемые файлы. Это идеальный вариант для изучения языка C++, так как он сводит всю сложность к минимуму.

В-третьих, при создании нового проекта большинство IDE автоматически добавят ваш проект в рабочее пространство. Рабочее пространство — это своеобразный контейнер, который может содержать один или несколько связанных проектов. Несмотря на то, что вы можете добавить несколько проектов в одно рабочее пространство, все же рекомендуется создавать отдельное рабочее пространство для каждой программы. Это намного упрощает работу для новичков.

Традиционно, первой программой на новом языке программирования является всеми известная программа «Hello, world!». Мы не будем нарушать традиции 🙂

Пользователям Visual Studio

Для создания нового проекта в Visual Studio 2019, вам нужно сначала запустить эту IDE, затем выбрать `"Файл" > "Создать" > "Проект"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen1.jpg)

Дальше появится диалоговое окно, где вам нужно будет выбрать `"Консольное приложение Windows"` из вкладки `"Visual C++"` и нажать `"ОК"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen2.jpg)

Также вы можете указать имя проекта (любое) и его расположение (рекомендую ничего не менять) в соответствующих полях.

В текстовом редакторе вы увидите, что уже есть некоторый текст и код — удалите его, а затем напечатайте или скопируйте следующий код:

``` cpp
#include <iostream>
 
int main()
{
	std::cout << "Hello, world!" << std::endl;
	return 0;
}
```

Вот, что у вас должно получиться:

![](https://ravesli.com/wp-content/uploads/2016/07/screen4.jpg)

>**ВАЖНОЕ ПРИМЕЧАНИЕ:**
>
> Строка #include "pch.h" требуется только для пользователей Visual Studio 2017. Если вы используете Visual Studio 2019 (или более новую версию), то не нужно писать эту строку вообще.

Чтобы запустить программу в Visual Studio, нажмите комбинацию Ctrl+F5. Если всё хорошо, то вы увидите следующее:

![](https://ravesli.com/wp-content/uploads/2016/07/screen5.jpg)

Это означает, что компиляция прошла успешно и результат выполнения вашей программы следующий:

`Hello, world!`

Чтобы убрать строку «…завершает работу с кодом 0…», вам нужно перейти в `"Отладка" > "Параметры"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen6.jpg)

Затем `"Отладка" > "Общие"` и поставить галочку возле `"Автоматически закрыть консоль при остановке отладки"` и нажать `"ОК"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen7.jpg)

Тогда ваше консольное окно будет выглядеть следующим образом:

![](https://ravesli.com/wp-content/uploads/2016/07/screen8.jpg)

Готово! Мы научились компилировать программу в Visual Studio.

## Пользователям Code::Blocks

Чтобы создать новый проект, запустите Code::Blocks, выберите `"File"` > `"New"` > `"Project"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen9.jpg)

Затем появится диалоговое окно, где вам нужно будет выбрать `"Console application"` и нажать `"Go"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen10.jpg)

Затем выберите язык `"C++"` и нажмите `"Next"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen11.jpg)

Затем нужно указать имя проекта и его расположение (можете создать отдельную папку Projects) и нажать `"Next"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen12.jpg)

В следующем диалоговом окне нужно будет нажать `"Finish"`.

После всех этих манипуляций, вы увидите пустое рабочее пространство. Вам нужно будет открыть папку Sources в левой части экрана и дважды кликнуть по main.cpp:

![](https://ravesli.com/wp-content/uploads/2016/07/screen13.jpg)

Вы увидите, что программа «Hello, world!» уже написана!

Для того, чтобы скомпилировать ваш проект в Code::Blocks, нажмите `Ctrl+F9`, либо перейдите в меню `"Build"` и выберите `"Build"`. Если всё пройдет хорошо, то вы увидете следующее во вкладке `"Build log"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen14.jpg)

Это означает, что компиляция прошла успешно!

Чтобы запустить скомпилированную программу, нажмите `Ctrl+F10`, либо перейдите в меню `"Build"` и выберите `"Run"`. Вы увидите следующее окно:

![](https://ravesli.com/wp-content/uploads/2016/07/screen15.jpg)

Это результат выполнения вашей программы.

Пользователям командной строки

Вставьте следующий код в текстовый файл с именем `HelloWorld.cpp`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen16.jpg)


## Пользователям командной строки

Вставьте следующий код в текстовый файл с именем HelloWorld.cpp:

``` cpp
#include <iostream>
 
int main()
{
	std::cout << "Hello, world!" << std::endl;
	return 0;
}
```

В командной строке напишите:

`g++ -o HelloWorld HelloWorld.cpp`

Эта команда выполнит компиляцию и линкинг файла HelloWorld.cpp. Для запуска программы напишите:

`HelloWorld`

Или:

`./HelloWorld`

И вы увидите результат выполнения вашей программы (`Hello, World!`)

## Пользователям веб-компиляторов

Вставьте следующий код в рабочее пространство:

``` cpp
#include <iostream>
 
int main()
{
	std::cout << "Hello, world!" << std::endl;
	return 0;
}
```

Затем нажмите `"Run"`. Вы должны увидеть результат в окне выполнения.

Пользователям других IDE

Вам нужно:

* Шаг №1: Создать консольный проект.

* Шаг №2: Добавить файл `.cpp` в проект (если нужно).

* Шаг №3: Вставить следующий код в файл `.cpp`:

```cpp
#include <iostream>
 
int main()
{
	std::cout << "Hello, world!" << std::endl;
	return 0;
}
```

* Шаг №4: Скомпилировать проект.

* Шаг №5: Запустить проект.

Если компиляция прошла неудачно (a.k.a. «О Боже, что-то пошло не так!»)
Всё нормально, без паники. Скорее всего, это какой-то пустяк.

*  Во-первых, убедитесь, что вы написали код правильно: без ошибок и опечаток. Сообщение об ошибке компилятора может дать вам ключ к пониманию того, где и какие ошибки случились.
*   Во-вторых, просмотрите Урок №7 — там есть решения наиболее распространенных проблем.
*   Если всё вышесказанное не помогло — «загуглите» проблему. С вероятностью 90% кто-то уже сталкивался с этим раньше и нашел решение.

## Заключение

Поздравляем, вы написали, скомпилировали и запустили свою первую программу на языке C++! Не беспокойтесь, если вы не понимаете, что означает весь этот код, приведенный выше. Мы детально всё это рассмотрим на следующих уроках.

___

## Урок №6. Режимы конфигурации «Debug» и «Release»

Конфигурация сборки (англ. «build configuration») — это набор настроек проекта, которые определяют принцип его построения. Конфигурация сборки состоит из:

   * имени исполняемого файла;

   * имени директории исполняемого файла;

   * имён директорий, в которых IDE будет искать другой код и файлы библиотек;

   * информации об отладке и параметрах оптимизации вашего проекта.

Интегрированная среда разработки имеет две конфигурации сборки: «Release» (Релиз) и «Debug» (Отладка).

  * Конфигурация «Debug» предназначена для отладки вашей программы. Эта конфигурация отключает все настройки по оптимизации, включает информацию об отладке, что делает ваши программы больше и медленнее, но упрощает проведение отладки. Режим «Debug» обычно используется в качестве конфигурации по умолчанию.

  * Конфигурация «Release» используется во время сборки программы для её дальнейшего выпуска. Программа оптимизируется по размеру и производительности и не содержит дополнительную информацию об отладке.

Например, исполняемый файл программы «Hello, World!» из предыдущего урока, созданный в конфигурации «Debug», у меня занимал 65КБ, в то время как исполняемый файл, построенный в конфигурации «Release», занимал всего лишь 12КБ.

## Переключение между режимами «Debug» и «Release» в Visual Studio

Самый простой способ изменить конфигурацию проекта — выбрать соответствующую из выпадающего списка на панели быстрого доступа:

![](https://ravesli.com/wp-content/uploads/2016/07/screenDebugVisual.jpg)

## Переключение между режимами «Debug» и «Release» в Code::Blocks

В Code::Blocks на панели быстрого доступа есть также выпадающий список, где вы можете выбрать соответствующий режим конфигурации:

![](https://ravesli.com/wp-content/uploads/2016/07/screenCode.jpg)

## Заключение
Используйте конфигурацию «Debug» при разработке программ, а конфигурацию «Release» при их релизе.

___

## Конфигурация компилятора: Расширения компилятора

На этом уроке мы поговорим о том, что такое расширения компилятора, полезны ли они и как их выключить.

> ## Оглавление:
> * [Расширения компилятора]()
> * [Отключение расширений компилятора]()
> * [Пользователям Visual Studio]()
> * [Пользователям Code::Blocks]()
> * [Пользователям GCC/G++]()

## Расширения компилятора
Стандарт языка C++ определяет правила поведения программ при определенных обстоятельствах. И в большинстве случаев компиляторы также будут следовать этим правилам. Однако многие компиляторы вносят свои собственные изменения в язык программирования, часто для улучшения совместимости с другими версиями языка (например, C99), или по историческим причинам. Эти специфичные для компилятора варианты поведения называются расширениями компилятора.

Используя расширения компилятора, вы получаете возможность писать программы, несовместимые со стандартом языка C++. Программы, использующие нестандартные расширения, обычно не компилируются другими компиляторами (которые не поддерживают эти же расширения), или вообще могут работать не так, как нужно.

К сожалению, расширения компилятора часто включены по умолчанию. Это особенно вредно для новичков в программировании, которые могут подумать, что специфическое поведение, вызванное расширениями компилятора, является частью официального стандарта языка C++ (когда, на самом деле, это не так).

Поскольку расширения компилятора очень редко требуются для решения большинства задач, и приводят к тому, что ваши программы не соответствуют стандарту языка C++, то рекомендуется отключать расширения компилятора.

> ***Совет***: Отключите расширения компилятора, чтобы ваши программы оставались совместимыми со стандартами языка C++ и работали в любой системе.

> ***Примечание***: Настройки, приведенные ниже, применяются для каждого проекта отдельно. Вам нужно будет это всё проделывать при создании нового проекта, либо создать шаблон с этими настройками и уже по этому шаблону создавать новые проекты.

## Отключение расширений компилятора


## Пользователям Visual Studio

> Чтобы отключить расширения компилятора в Visual Studio, щелкните правой кнопкой мыши по названию вашего проекта в меню `"Обозреватель решений" > "Свойства"`:

![](https://ravesli.com/wp-content/uploads/2020/04/1.jpg)

В диалоговом окне вашего проекта убедитесь, что в пункте `"Конфигурация"` установлено значение `"Все конфигурации"`. Затем перейдите на вкладку `"C/C++" > "Язык"` и в пункте `"Отключить расширения языка"` выберите значение `"Да (/Za)"`:

![](https://ravesli.com/wp-content/uploads/2020/04/2-3.png)

После этого нажмите "Применить" и "ОК".

## Пользователям Code::Blocks

Отключить расширения компилятора можно через меню `"Settings" > "Compiler"`:

![](https://ravesli.com/wp-content/uploads/2020/04/3-1.png)

Затем на вкладке `"Compiler Flags"` найдите пункт `"Treat as errors the warnings demanded by strict ISO C and ISO C++ [-pedantic-errors]"` и поставьте возле него галочку, после чего нажмите `"OK"`:

![](https://ravesli.com/wp-content/uploads/2020/04/4-1.png)

## Пользователям GCC/G++
Вы можете отключить расширения компилятора, добавив флаг `-pedantic-errors` в командную строку компиляции.

___

## Конфигурация компилятора: Уровни предупреждений и ошибки

На этом уроке мы поговорим о том, как повысить уровень предупреждений в компиляторах и заставить их обрабатывать предупреждения так, как если бы это были ошибки.

> ## Оглавление:
> * [Предупреждения в языке С++]()
> * [Изменение уровня предупреждений]()
> * [Пользователям Visual Studio]()
> * [Пользователям Code::Blocks]()
> * [Пользователям GCC/G++]()
> * [Обрабатывать предупреждения как ошибки]()
> * [Пользователям Visual Studio]()
> * [Пользователям Code::Blocks]()
> * [Пользователям GCC/G++]()

## Предупреждения в языке С++
На этапе компиляции компилятор проверяет, соответствует ли ваш код правилам языка C++. Если вы сделали что-то запрещенное, что нарушило синтаксис языка С++, то компилятор выдаст ошибку, предоставив вам как номер строки, содержащий ошибку, так и некоторый текст о содержании самой ошибки. Фактически, ошибка может находиться как в этой строке (которую сообщил вам компилятор), так и в строке перед ней. После того, как вы определили и исправили ошибочные строки кода, вы можете попробовать скомпилировать вашу программу еще раз.

Еще могут быть ситуации, когда компилятор видит ошибочный код, но не до конца в этом уверен (помните, что философия языка С++ заключается в выражении «Доверяй программисту!»). В таких случаях компилятор может выдать предупреждение. Предупреждения не останавливают процесс компиляции, но сообщают программисту, что что-то пошло не так.

> ***Совет***: Не позволяйте предупреждениям накапливаться. Решайте их по мере возникновения (так, как будто бы это были ошибки).

В большинстве случаев предупреждения могут быть устранены либо путем исправления ошибки, на которую указывает предупреждение, либо путем переписывания строки кода, генерирующей предупреждение, таким образом, чтобы предупреждение больше не генерировалось.

В редких случаях может потребоваться явно указать компилятору не генерировать конкретное предупреждение для рассматриваемой строки кода. Язык C++ не поддерживает такой способ решения предупреждений, но многие отдельные компиляторы (включая Visual Studio и GCC) предоставляют возможность (через не портативные директивы #pragma) временного отключения предупреждений.

По умолчанию большинство компиляторов генерируют только предупреждения о наиболее очевидных проблемах. Однако вы можете попросить ваш компилятор быть более настойчивым в предоставлении предупреждений о вещах, которые он считает странными.

> ***Совет***: Сделайте максимальным уровень предупреждений от компилятора (особенно во время обучения). Это поможет вам определить возможные проблемы.

## Изменение уровня предупреждений


## Пользователям Visual Studio
Чтобы повысить уровень предупреждений в Visual Studio, щелкните правой кнопкой мышки по названию вашего проекта в меню `"Обозреватель решений" > "Свойства"`:


![](https://ravesli.com/wp-content/uploads/2020/04/1.jpg)

В диалоговом окне вашего проекта убедитесь, что в пункте `"Конфигурация"` установлено значение `"Все конфигурации"`. Затем перейдите на вкладку `"C/C++" > "Общие"` и в пункте `"Уровень предупреждений"` выберите значение `"Уровень4 (/W4)"`:

![](https://ravesli.com/wp-content/uploads/2020/04/1-2.png)

Затем нажмите "Применить" и "ОК".

> ***Примечание***: Не выбирайте пункт "Включить все предупреждения (/Wall)", иначе вы будете погребены в предупреждениях, генерируемых Стандартной библиотекой C++.

## Пользователям Code::Blocks
Перейдите в меню `"Settings" > "Compiler"`:

![](https://ravesli.com/wp-content/uploads/2020/04/3-1.png)

И на вкладке `"Compiler settings" > "Compiler flags"` поставьте галочки возле следующих пунктов:

   * Enable all common compiler warnings (overrides many other settings) [-Wall]

   * Enable Effective-C++ warnings (thanks Scott Meyers) [-Weffc++]

   * Enable extra compiler warnings [-Wextra]

Смотрим:

![](https://ravesli.com/wp-content/uploads/2020/04/4-2.pngs)

Нажмите `"ОК"` и затем перейдите на вкладку `"Other compiler options"` и добавьте в область редактирования текст `-Wsign-conversion –Werror`:

![](https://ravesli.com/wp-content/uploads/2020/04/5-1.png)

И нажмите `"Ок"`.

> ***Примечание***: О параметре `-Werror` мы поговорим чуть позже.


## Пользователям GCC/G++
Добавьте следующие флаги в вашу командную строку:

`-Wall -Weffc++ -Wextra -Wsign-conversion`

## Обрабатывать предупреждения как ошибки
Вы также можете указать вашему компилятору обрабатывать все предупреждения так, как если бы они были ошибками (в таком случае, компилятор будет останавливать процесс компиляции, если обнаружит какие-либо предупреждения). Это хороший вариант заставить себя исправлять все предупреждения, особенно, если вам не хватает самодисциплины (как, впрочем, большинству из нас).

## Пользователям Visual Studio

Чтобы обрабатывать все предупреждения как ошибки, щелкните правой кнопкой мышки по названию вашего проекта в меню `"Обозреватель решений" > "Свойства"`:

![](https://ravesli.com/wp-content/uploads/2020/04/1.jpg)

В диалоговом окне вашего проекта убедитесь, что в поле `"Конфигурация"` установлено значение `"Все конфигурации"`. Затем перейдите на вкладку `"C/C++" > "Общие"` и в пункте `"Обрабатывать предупреждения как ошибки"` выберите значение `"Да(/WX)"`:

![](https://ravesli.com/wp-content/uploads/2020/04/7-1.png)

Затем нажмите `"Применить"` и `"ОК"`.

## Пользователям Code::Blocks
Перейдите в меню `"Settings"` > `"Compiler"`:

![](https://ravesli.com/wp-content/uploads/2020/04/3-1.png)

Затем `"Compiler settings"` > `"Other compiler options"` и добавьте `-Werror` в область редактирования:

![](https://ravesli.com/wp-content/uploads/2020/04/5-1.png)

Затем нажмите `"ОК"`.

## Пользователям GCC/G++
Добавьте следующий флаг в вашу командную строку:

`-Werror`

___
## Конфигурация компилятора: Выбор стандарта языка С++

Как с огромным количеством различных версий языка C++ (C++98, C++03, C++11, C++14, C++17, C++20) компилятор понимает, какую из них ему следует использовать? Как правило, компилятор выбирает стандарт языка по умолчанию (часто не самый последний языковой стандарт). Если вы хотите использовать другой стандарт, то вам придется внести изменения в настройки вашей IDE/компилятора. Эти настройки применяются только к текущему проекту. При создании нового проекта вам придется всё делать заново.

> Оглавление:
> * [Кодовые имена для версий языка С++]()
> * [Установка стандарта языка С++ в Visual Studio]()
> * [Установка стандарта языка C++ в Code::Blocks]()
> * [Установка стандарта языка С++ в GCC/G++]()
> * [Тестирование вашего компилятора]()

## Кодовые имена для версий языка С++
Обратите внимание на то, что каждый языковый стандарт имеет название, указывающее на год его принятия/утверждения (например, C++17 был принят/утвержден в 2017 году).

Однако, когда согласовывается новый языковой стандарт, неясно, в каком году удастся его принять, поэтому действующим языковым стандартам присваиваются кодовые имена, которые затем заменяются фактическими именами при доработке стандарта. Например, C++11 назывался c++1x, пока над ним вели работу. Вы можете по-прежнему видеть на просторах Интернета подобные кодовые имена (особенно, когда речь заходит о будущей версии языкового стандарта, у которого еще нет окончательного названия).

Вот сопоставление кодовых имен версий С++ с их окончательными названиями:

  * c++1x = C++11

  * c++1y = C++14

  * c++1z = C++17

  * c++2a = C++20

Например, если вы видите c++1z, то знайте, что речь идет о стандарте C++17.

## Установка стандарта языка С++ в Visual Studio

На момент написания данной статьи, Visual Studio 2019 по умолчанию использует возможности C++14, что не позволяет использовать более новые фичи, представленные в C++17 и в C++20.

Чтобы использовать новый функционал, вам необходимо подключить новый языковой стандарт. К сожалению, сейчас нет способа сделать это глобально — вы должны делать это к каждому проекту индивидуально.

Чтобы использовать новый языковый стандарт в Visual Studio, откройте ваш проект, затем щелкните правой кнопкой мышки по названию вашего проекта в меню "Обозреватель решений" > "Свойства":

![](https://ravesli.com/wp-content/uploads/2020/04/1.jpg)


В диалоговом окне вашего проекта убедитесь, что в пункте "Конфигурация" установлено значение "Все конфигурации". Затем перейдите на вкладку "C/C++" > "Язык" и в пункте "Стандарт языка С++" выберите ту версию языка С++, которую хотели бы использовать:

![](https://ravesli.com/wp-content/uploads/2020/04/1-3.png)

На момент написания данной статьи, я рекомендую выбрать "Стандарт ISO C++17 (/std:c++17)", который является последним стабильным стандартом.

Если вы хотите поэкспериментировать с возможностями грядущего стандарта языка C++ — C++20, то вы можете выбрать пункт "Предварительная версия ... (/std:c++latest)". Просто помните, что его поддержка может иметь баги.

## Установка стандарта языка C++ в Code::Blocks
Code::Blocks по умолчанию может использовать стандарт C++11. Хорошей новостью является то, что Code::Blocks позволяет устанавливать ваш стандарт языка С++ глобально, поэтому вы можете установить его один раз и сразу на все проекты (а не для каждого проекта в индивидуальном порядке). Для этого перейдите в меню `"Settings" > "Compiler"`:

![](https://ravesli.com/wp-content/uploads/2020/04/3-1.png)


Затем на вкладке "Compiler flags" найдите следующие пункты меню:

![](https://ravesli.com/wp-content/uploads/2016/07/screen1-1.png)

Отметьте тот пункт, у которого число обозначает ближайший (к текущему) год утверждения стабильной версии и нажмите "ОК" (на вышеприведенном скриншоте этим пунктом является "Have g++ follow the C++17 ISO C++ language standard [-std=c++17]").

> ***Примечание***: Если вы не нашли в ваших настройках опцию с C++17, то вам следует обновить вашу версию Code::Blocks.


## Установка стандарта языка С++ в GCC/G++

В GCC/G++ вы можете прописать соответствующие флаги `-std=c++11`, `-std=c++14`, `-std=c++17`или `-std=c++2a`, чтобы подключить функционал C++11/14/17/20, соответственно.

## Тестирование вашего компилятора
После подключения версии C++17 или выше, вы можете провести тест, который позволит понять, всё ли верно сделано и действительно ли подключена новая версия языка С++. Следующая программа в С++17 должна выполниться без каких-либо предупреждений или ошибок:

``` cpp
#include <array>
#include <iostream>
#include <string_view>
#include <tuple>
#include <type_traits>
 
namespace a::b::c
{
    inline constexpr std::string_view str{ "hello" };
}
 
template <class... T>
std::tuple<std::size_t, std::common_type_t<T...>> sum(T... args)
{
    return { sizeof...(T), (args + ...) };
}
 
int main()
{
    auto [iNumbers, iSum]{ sum(1, 2, 3) };
    std::cout << a::b::c::str << ' ' << iNumbers << ' ' << iSum << '\n';
 
    std::array arr{ 1, 2, 3 };
 
    std::cout << std::size(arr) << '\n';
 
    return 0;
}
```

Если вы не можете скомпилировать этот код, то либо вы не подключили C++17, либо ваш компилятор не полностью поддерживает C++17. В последнем случае обновите версию IDE или компилятора.

___

## Урок №7. Решения самых распространенных проблем

На этом уроке мы рассмотрим наиболее частые проблемы, с которыми сталкиваются новички при написании программ на языке C++.

> Оглавление:
> * [Проблема №1]()
> * [Проблема №2]()
> * [Проблема №3]()
> * [Проблема №4]()
> * [Проблема №5]()
> * [Проблема №6]()
> * [Проблема №7]()
> * [Проблема №8]()
> * [Проблема №9]()
> * [Проблема №10]()
> * [У меня есть другая проблема]()

## Проблема №1
> Как использовать кириллицу в программах C++?

**Ответ №1**

Чтобы выводить кириллицу в языке C++ нужно подключить заголовочный файл <Windows.h>:

`#include <Windows.h>`

И прописать следующие две строки в функции `main()`:

``` cpp
SetConsoleCP(1251);  
SetConsoleOutputCP(1251);
```

В качестве альтернативного варианта можно использовать следующую строку в функции `main()`:

`setlocale(LC_ALL, "Russian");`


## Проблема №2

> При выполнении программы появляется черное консольное окно, а затем сразу пропадает.

**Ответ №2**

Некоторые компиляторы (например, Bloodshed’s Dev C++) автоматически не задерживают консольное окно после того, как программа завершила свое выполнение. Если проблема в компиляторе, то следующие два шага решат эту проблему:

* Шаг №1: Добавьте следующую строку кода в верхнюю часть вашей программы:

`#include <iostream>`

* Шаг №2: Добавьте следующий код в конец функции main() (прямо перед оператором return):

``` cpp
std::cin.clear(); 
std::cin.ignore(32767, '\n');
std::cin.get();
```

Таким образом, программа будет ожидать нажатия клавиши, чтобы закрыть консольное окно. Вы получите дополнительное время, чтобы хорошенько всё рассмотреть/изучить. После нажатия любой клавиши, консольное окно закроется.

Другие решения, такие как system("pause");, могут работать только на определенных операционных системах, поэтому вариант, приведенный выше, предпочтительнее.

> ***Примечание***: Visual Studio не задерживает консольное окно, если выполнение запущено с отладкой (`"Отладка" > "Начать отладку"` или `F5`). Если вы хотите, чтобы была пауза — воспользуйтесь решением выше или запустите программу без отладки (`"Отладка" > "Запуск без отладки"` или `Ctrl+F5`).

### Проблема №3
> При использовании `cin`, `cout` или `endl` компилятор говорит, что `cin`, `cout` или `endl` являются `«undeclared identifier»` (необъявленными идентификаторами).

**Ответ №3**

Во-первых, убедитесь, что у вас присутствует следующая строка кода в верхней части вашей программы:

``` cpp
#include <iostream>
```

Во-вторых, убедитесь, что `cin`, `cout` или `endl` имеют префикс `std::`, например:

``` cpp
std::cout << "Hello world!" << std::endl;
```

## Проблема №4

> При использовании `endl` для перехода на новую строку, появляется ошибка, что `end1 является «undeclared identifier»`.

**Ответ №4**

Убедитесь, что вы не перепутали букву `l` (нижний регистр L) в `endl` с цифрой 1. В endl все символы являются буквами. Также легко можно перепутать заглавную букву `О` с цифрой `0` (ноль).

## Проблема №5
> Моя программа компилируется, но работает не так, как нужно. Что мне делать?

**Ответ №5**

Выполните отладку программы. Детально об этом читайте на уроке №26 и на уроке №27.

## Проблема №6

> Как включить нумерацию строк в Visual Studio?

**Ответ №6**

Перейдите в меню `"Средства" > "Параметры"`:


![](https://ravesli.com/wp-content/uploads/2016/07/screen1-1.jpg)

Затем откройте вкладку "Текстовый редактор" > "Все языки" > "Общие" и поставьте галочку возле "Номера строк", затем нажмите "ОК":

![](https://ravesli.com/wp-content/uploads/2016/07/screen2-1.jpg)


## Проблема №7
> При компиляции программы я получаю следующую ошибку: «unresolved external symbol _main or _WinMain@16».

**Ответ №7**

Это означает, что ваш компилятор не может найти главную функцию main(). Все программы должны содержать эту функцию.

Здесь есть несколько пунктов, которые нужно проверить:

  * Есть ли в вашей программе функция main()?

  * Слово main написано правильно?

  * Подключен ли файл, который содержит функцию main(), к вашему проекту? (если нет, то переместите функцию main() в файл, который является частью вашего проекта, либо добавьте этот файл в ваш проект)

  * Подключен ли файл, содержащий функцию main(), к компиляции?

## Проблема №8

> При компиляции программы я получаю следующее предупреждение: «Cannot find or open the PDB file».

**Ответ №8**

Это не ошибка, а предупреждение. На работоспособность вашей программы оно не повлияет. Тем не менее, в Visual Studio вы можете решить всё следующим образом: перейдите в меню `"Отладка" > "Параметры" > "Отладка" > "Символы"` и поставьте галочку возле `"Серверы символов (Майкрософт)"`, затем нажмите `"ОК"`.

## Проблема №9
> Я использую Code::Blocks или G++, но функционал C++11/C++14 не работает.

**Ответ №9**

В Code::Blocks перейдите в `"Project" > "Build options" > "Compiler settings" > "Compiler flags"` и поставьте галочку возле пункта `"Have g++ follow C++14 ISO C++ language standard"`. Смотрите урок №4 — там есть скриншоты, как это сделать.

При компиляции в g++, добавьте следующий код в командную строку:

`-std=c++14`

## Проблема №10
> Я запустил программу, появилось консольное окно, но ничего не выводится.

**Ответ №10**

Ваш антивирус может блокировать выполнение вашей программы. Попробуйте отключить его на время и запустите программу еще раз.


## У меня есть другая проблема, с которой я не могу разобраться. Как и где я могу получить ответ?
По мере прохождения данных уроков, у вас, несомненно, появятся вопросы или вы столкнетесь с проблемами. Что делать?

Во-первых, спросите у Google. Четко сформулируйте вашу проблему и просто «погуглите». Если у вас есть сообщение об ошибке — скопируйте его и вставьте в поиск Google, используя кавычки. Скорее всего, кто-то уже задавал такой же вопрос, как у вас, и получил на него ответ.

Если Google не помог, то спросите на специализированных сервисах вопросов/ответов, либо на форумах, посвященным тематике программирования/IT. Вот самые популярные из них:

   [Stack Overflow](http://stackoverflow.com)

   [CyberForum](http://cyberforum.ru)

   [Хабр Q&A (раньше Toster)](http://qna.habr.com)

Но будьте внимательны и старайтесь максимально конкретизировать свою проблему, укажите, какую операционную систему и IDE вы используете, а также то, что вы пробовали сделать самостоятельно для решения своей проблемы.

___
___

# Основы C++


































