# Все про С++ из сайта ravesli.com

Сдесь я собрал всю информацию про С++ (на 2021 год) из онлайн-учебника **ravesli**. Цель: удобство, а также [pdf файл](http://github.com/bozich/bozich/raw/master/articles/ravesli-cpp/index.pdf) в репозитории [GitHub](http://github.com/bozich/bozich/tree/master/articles/ravesli-cpp/)

Хочу сказать большое спасибо авторам урокв на ravesli.com (по ним даже ребенок сможет выучить С++!)

Конечно, на сайте оффициальная платная .pdf может и лучше, но всё же...

> # **Примечание: Это авторские уроки Дмитрия Бушуева!**


Веб-Сайт автора: [bozich.github.io](http://bozich.github.io).

# Оглавление:

> ### [Глава №0. Введение. Начало работы](#глава-0-введение-начало-работы-1)
> * [Урок №1. Введение в программирование](#урок-1-введение-в-программирование)
> * [Урок №2. Введение в языки программирования C и С++](#урок-2-введение-в-языки-программирования-c-и-с)
> * [Урок №3. Введение в разработку программного обеспечения](#урок-3-введение-в-разработку-программного-обеспечения)
> * [Урок №4. Установка IDE (Интегрированной Среды Разработки)](#урок-4-установка-ide-интегрированной-среды-разработки)
> * [Урок №5. Компиляция вашей первой программы](#урок-5-компиляция-вашей-первой-программы)
> * [Урок №6. Режимы конфигурации «Debug» и «Release»](#урок-6-режимы-конфигурации-debug-и-release)
> * [Конфигурация компилятора: Расширения компилятора](#конфигурация-компилятора-уровни-предупреждений-и-ошибки)
> * [Конфигурация компилятора: Уровни предупреждений и ошибки](#конфигурация-компилятора-уровни-предупреждений-и-ошибки)
> * [Конфигурация компилятора: Выбор стандарта языка С++](#конфигурация-компилятора-выбор-стандарта-языка-с)
> * [Урок №7. Решения самых распространенных проблем](#конфигурация-компилятора-уровни-предупреждений-и-ошибки)

> ### [Глава №1. Основы C++](#глава-1-основы-c-1)
> * [Урок №8. Структура программ](#урок-8-структура-программ)
> * [Урок №9. Комментарии](#урок-9-комментарии)
> * [Урок №10. Переменные, Инициализация и Присваивание](#урок-10-переменные-инициализация-и-присваивание)
> * [Урок №11. cout, cin и endl](#урок-11-cout-cin-и-endl)
> * [Урок №12. Функции и оператор возврата return](#урок-12-функции-и-оператор-возврата-return)
> * [Урок №13. Параметры и аргументы функций](#урок-13-параметры-и-аргументы-функций)
> * [Урок №14. Почему функции — полезны, и как их эффективно использовать?](#урок-14-почему-функции--полезны-и-как-их-эффективно-использовать)
> * [Урок №15. Локальная область видимости](#урок-15-локальная-область-видимости)
> * [Урок №16. Ключевые слова и идентификаторы](#урок-16-ключевые-слова-и-идентификаторы)
> * [Урок №17. Операторы](#урок-17-операторы)
> * [Урок №18. Базовое форматирование кода](#урок-18-базовое-форматирование-кода)
> * [Урок №19. Прототип функции и Предварительное объявление](#урок-19-прототип-функции-и-предварительное-объявление)
> * [Урок №20. Многофайловые программы](#урок-20-многофайловые-программы)
> * [Урок №21. Заголовочные файлы](#урок-21-заголовочные-файлы)
> * [Урок №22. Директивы препроцессора](#урок-22-директивы-препроцессора)
> * [Урок №23. Header guards и #pragma once](#урок-23-header-guards-и-pragma-once)
> * [Урок №24. Конфликт имен и std namespace](#урок-24-конфликт-имен-и-std-namespace)
> * [Урок №25. Разработка ваших первых программ](#урок-25-разработка-ваших-первых-программ)
> * [Урок №26. Отладка программ: степпинг и точки останова](#урок-26-отладка-программ-степпинг-и-точки-останова)
> * [Урок №27. Отладка программ: стек вызовов и отслеживание переменных](#урок-27-отладка-программ-стек-вызовов-и-отслеживание-переменных)
> * [Глава №1. Итоговый тест](#глава-1-итоговый-тест)

> ### [Глава №2. Переменные и основные типы данных в C++]() // Coming soon!
> * [Урок №28. Инициализация, присваивание и объявление переменных]()
> * [Урок №29. Тип данных void]()
> * [Урок №30. Размер типов данных]()
> * [Урок №31. Целочисленные типы данных: short, int и long]()
> * [Урок №32. Фиксированный размер целочисленных типов данных]()
> * [Урок №33. Типы данных с плавающей точкой: float, double и long double]()
> * [Урок №34. Логический тип данных bool]()
> * [Урок №35. Символьный тип данных char]()
> * [Урок №36. Литералы и магические числа]()
> * [Урок №37. const, constexpr и символьные константы]()
> * [Глава №2. Итоговый тест]()

> ### [Глава №3. Операторы в C++]() // Coming soon!
> * [Урок №38. Приоритет операций и правила ассоциативности]()
> * [Урок №39. Арифметические операторы]()
> * [Урок №40. Инкремент, декремент и побочные эффекты]()
> * [Урок №41. Условный тернарный оператор, оператор sizeof и Запятая]()
> * [Урок №42. Операторы сравнения]()
> * [Урок №43. Логические операторы: И, ИЛИ, НЕ]()
> * [Урок №44. Конвертация чисел из двоичной системы в десятичную и наоборот]()
> * [Урок №45. Побитовые операторы]()
> * [Урок №46. Битовые флаги и битовые маски]()
> * [Глава №3. Итоговый тест]()

> ### [Глава №4. Область видимости и другие типы переменных в C++]() // Coming soon!
> * [Урок №47. Блоки стейтментов (составные операторы)]()
> * [Урок №48. Локальные переменные, область видимости и продолжительность жизни]()
> * [Урок №49. Глобальные переменные]()
> * [Урок №50. Почему глобальные переменные – зло?]()
> * [Урок №51. Статические переменные]()
> * [Урок №52. Связи, область видимости и продолжительность жизни]()
> * [Урок №53. Пространства имен]()
> * [Урок №54. using-стейтменты]()
> * [Урок №55. Неявное преобразование типов данных]()
> * [Урок №56. Явное преобразование типов данных]()
> * [Урок №57. Введение в std::string]()
> * [Урок №58. Перечисления]()
> * [Урок №59. Классы enum]()
> * [Урок №60. Псевдонимы типов: typedef и type alias]()
> * [Урок №61. Структуры]()
> * [Урок №62. Вывод типов: ключевое слово auto]()
> * [Глава №4. Итоговый тест]()

> ### [Глава №5. Порядок выполнения кода в программе. Циклы, ветвления в C++]() // Coming soon!
> * [Урок №63. Операторы управления потоком выполнения программ]()
> * [Урок №64. Операторы условного ветвления if/else]()
> * [Урок №65. Оператор switch]()
> * [Урок №66. Оператор goto]()
> * [Урок №67. Цикл while]()
> * [Урок №68. Цикл do while]()
> * [Урок №69. Цикл for]()
> * [Урок №70. Операторы break и continue]()
> * [Урок №71. Генерация случайных чисел]()
> * [Урок №72. Обработка некорректного пользовательского ввода]()
> * [Урок №73. Введение в тестирование кода]()
> * [Глава №5. Итоговый тест]()

> ### [Глава №6. Массивы, Строки, Указатели и Ссылки в C++]() // Coming soon!
> * [Урок №74. Массивы]()
> * [Урок №75. Фиксированные массивы]()
> * [Урок №76. Массивы и циклы]()
> * [Урок №77. Сортировка массивов методом выбора]()
> * [Урок №78. Многомерные массивы]()
> * [Урок №79. Строки C-style]()
> * [Введение в класс std::string_view в С++]()
> * [Урок №80. Указатели]()
> * [Урок №81. Нулевые указатели]()
> * [Урок №82. Указатели и массивы]()
> * [Урок №83. Адресная арифметика и индексация массивов]()
> * [Урок №84. Символьные константы строк C-style]()
> * [Урок №85. Динамическое выделение памяти]()
> * [Урок №86. Динамические массивы]()
> * [Урок №87. Указатели и const]()
> * [Урок №88. Ссылки]()
> * [Урок №89. Ссылки и const]()
> * [Урок №90. Оператор доступа к членам через указатель]()
> * [Урок №91. Цикл foreach]()
> * [Урок №92. Указатели типа void]()
> * [Урок №93. Указатели на указатели]()
> * [Урок №94. Введение в std::array]()
> * [Урок №95. Введение в std::vector]()
> * [Введение в итераторы в С++]()
> * [Алгоритмы в Стандартной библиотеке С++]()
> * [Глава №6. Итоговый тест]()


> ### [Глава №7. Функции в C++]() // Coming soon!
> * [Урок №96. Параметры и аргументы функций]()
> * [Урок №97. Передача по значению]()
> * [Урок №98. Передача по ссылке]()
> * [Урок №99. Передача по адресу]()
> * [Урок №100. Возврат значений по ссылке, по адресу и по значению]()
> * [Урок №101. Встроенные функции]()
> * [Урок №102. Перегрузка функций]()
> * [Урок №103. Параметры по умолчанию]()
> * [Урок №104. Указатели на функции]()
> * [Урок №105. Стек и Куча]()
> * [Урок №106. Ёмкость вектора]()
> * [Урок №107. Рекурсия и Числа Фибоначчи]()
> * [Урок №108. Обработка ошибок, cerr и exit()]()
> * [Урок №109. assert и static_assert]()
> * [Урок №110. Аргументы командной строки]()
> * [Урок №111. Эллипсис]()
> * [Лямбда-выражения в С++]()
> * [Лямбда-захваты в С++]()
> * [Глава №7. Итоговый тест]()


> ### [Глава №8. Основы ООП в C++]() // Coming soon!
> * [Урок №112. Введение в ООП>]()
> * [Урок №113. Классы, Объекты и Методы]()
> * [Урок №114. Спецификаторы доступа public и private]()
> * [Урок №115. Инкапсуляция, Геттеры и Сеттеры]()
> * [Урок №116. Конструкторы]()
> * [Урок №117. Список инициализации членов класса]()
> * [Урок №118. Инициализация нестатических членов класса]()
> * [Урок №119. Делегирующие конструкторы]()
> * [Урок №120. Деструкторы]()
> * [Урок №121. Скрытый указатель *this]()
> * [Урок №122. Классы и заголовочные файлы]()
> * [Урок №123. Классы и const]()
> * [Урок №124. Статические переменные-члены класса]()
> * [Урок №125. Статические методы класса]()
> * [Урок №126. Дружественные функции и классы]()
> * [Урок №127. Анонимные объекты]()
> * [Урок №128. Вложенные типы данных в классах]()
> * [Урок №129. Измерение времени выполнения (тайминг) кода]()
> * [Глава №8. Итоговый тест]()

> ### [Глава №9. Перегрузка операторов в C++]() // Coming soon!
> * [Урок №130. Введение в перегрузку операторов]()
> * [Урок №131. Перегрузка операторов через дружественные функции]()
> * [Урок №132. Перегрузка операторов через обычные функции]()
> * [Урок №133. Перегрузка операторов ввода и вывода]()
> * [Урок №134. Перегрузка операторов через методы класса]()
> * [Урок №135. Перегрузка унарных операторов +, — и логического НЕ]()
> * [Урок №136. Перегрузка операторов сравнения]()
> * [Урок №137. Перегрузка операторов инкремента и декремента]()
> * [Урок №138. Перегрузка оператора индексации []]()
> * [Урок №139. Перегрузка оператора ()]()
> * [Урок №140. Перегрузка операций преобразования типов данных]()
> * [Урок №141. Конструктор копирования]()
> * [Урок №142. Копирующая инициализация]()
> * [Урок №143. Конструкторы преобразования, ключевые слова explicit и delete]()
> * [Урок №144. Перегрузка оператора присваивания]()
> * [Урок №145. Поверхностное и глубокое копирование]()
> * [Глава №9. Итоговый тест]()

> ### [Глава №10. Введение в связи между объектами в C++]() // Coming soon!
> * [Урок №146. Типы связей между объектами]()
> * [Урок №147. Композиция объектов]()
> * [Урок №148. Агрегация]()
> * [Урок №149. Ассоциация]()
> * [Урок №150. Зависимость]()
> * [Урок №151. Контейнерные классы]()
> * [Урок №152. Список инициализации std::initializer_list]()
> * [Глава №10. Итоговый тест]()

> ### [Глава №11. Наследование в C++]() // Coming soon!
> * [Урок №153. Введение в Наследование]()
> * [Урок №154. Базовое наследование]()
> * [Урок №155. Порядок построения дочерних классов]()
> * [Урок №156. Конструкторы и инициализация дочерних классов]()
> * [Урок №157. Наследование и спецификатор доступа protected]()
> * [Урок №158. Добавление нового функционала в дочерний класс]()
> * [Урок №159. Переопределение методов родительского класса]()
> * [Урок №160. Сокрытие методов родительского класса]()
> * [Урок №161. Множественное наследование]()
> * [Глава №11. Итоговый тест]()

> ### [Глава №12. Виртуальные функции в C++]() // Coming soon!
> * [Урок №162. Указатели, Ссылки и Наследование]()
> * [Урок №163. Виртуальные функции и Полиморфизм]()
> * [Урок №164. Модификаторы override и final]()
> * [Урок №165. Виртуальные деструкторы и Виртуальное присваивание]()
> * [Урок №166. Раннее и Позднее Связывания]()
> * [Урок №167. Виртуальные таблицы]()
> * [Урок №168. Чистые виртуальные функции, Интерфейсы и Абстрактные классы]()
> * [Урок №169. Виртуальный базовый класс]()
> * [Урок №170. Обрезка объектов]()
> * [Урок №171. Динамическое приведение типов. Оператор dynamic_cast]()
> * [Урок №172. Вывод объектов классов через оператор вывода]()
> * [Глава №12. Итоговый тест]()

> ### [Глава №13. Шаблоны в C++]() // Coming soon!
> * [Урок №173. Шаблоны функций]()
> * [Урок №174. Экземпляры шаблонов функций]()
> * [Урок №175. Шаблоны классов]()
> * [Урок №176. Параметр non-type в шаблоне]()
> * [Урок №177. Явная специализация шаблона функции]()
> * [Урок №178. Явная специализация шаблона класса]()
> * [Урок №179. Частичная специализация шаблона]()
> * [Урок №180. Частичная специализация шаблонов и Указатели]()
> * [Глава №13. Итоговый тест]()


> ### [Глава №14. Исключения в C++]() // Coming soon!
> * [Урок №181. Исключения. Зачем они нужны?]()
> * [Урок №182. Обработка исключений. Операторы throw, try и catch]()
> * [Урок №183. Исключения, Функции и Раскручивание стека]()
> * [Урок №184. Непойманные исключения и обработчики catch-all]()
> * [Урок №185. Классы-Исключения и Наследование]()
> * [Урок №186. Повторная генерация исключений]()
> * [Урок №187. Функциональный try-блок]()
> * [Урок №188. Недостатки и опасности использования исключений]()
> * [Глава №14. Итоговый тест]()

> ### [Глава №15. Умные указатели и Семантика перемещения в C++]() // Coming soon!
> * [Урок №189. Умные указатели и Семантика перемещения]()
> * [Урок №190. Ссылки r-value]()
> * [Урок №191. Конструктор перемещения и Оператор присваивания перемещением]()
> * [Урок №192. Функция std::move()]()
> * [Урок №193. Умный указатель std::unique_ptr]()
> * [Урок №194. Умный указатель std::shared_ptr]()
> * [Урок №195. Умный указатель std::weak_ptr]()
> * [Глава №15. Итоговый тест]()

> ### [Глава №16. Стандартная библиотека шаблонов (STL) в С++]() // Coming soon!
> * [Урок №196. Стандартная библиотека шаблонов (STL)]()
> * [Урок №197. Контейнеры STL]()
> * [Урок №198. Итераторы STL]()
> * [Урок №199. Алгоритмы STL]()

> ### [Глава №17. std::string в С++]() // Coming soon!
> * [Урок №200. Строковые классы std::string и std::wstring]()
> * [Урок №201. Создание, уничтожение и конвертация std::string]()
> * [Урок №202. Длина и ёмкость std::string]()
> * [Урок №203. Доступ к символам std::string. Конвертация std::string в строки C-style]()
> * [Урок №204. Присваивание и перестановка значений с std::string]()
> * [Урок №205. Добавление к std::string]()
> * [Урок №206. Вставка символов и строк в std::string]()

> ### [Глава №18. Ввод/Вывод в С++]() // Coming soon!
> * [Урок №207. Потоки ввода и вывода]()
> * [Урок №208. Функционал класса istream]()
> * [Урок №209. Функционал классов ostream и ios. Форматирование вывода]()
> * [Урок №210. Потоковые классы и Строки]()
> * [Урок №211. Состояния потока и валидация пользовательского ввода]()
> * [Урок №212. Базовый файловый ввод и вывод]()
> * [Урок №213. Рандомный файловый ввод и вывод]()

> ### [Дополнительные уроки]() // Coming soon!
> * [Статические и динамические библиотеки]()
> * [Подключение и использование библиотек в Visual Studio]()
> * [C++11. Нововведения]()
> * [C++14. Нововведения]()
> * [C++17. Нововведения]()
> * [Спецификации исключений и спецификатор noexcept в С++]()
> * [Функция std::move_if_noexcept() в С++]()
> * [C++20. Нововведения]()
> * [Оператор трехстороннего сравнения в С++]()
> * [C++20. Два новых ключевых слова: consteval и constinit]()
> * [C++20. Библиотека chrono и Время суток]()

> ### [Финал]() // Coming soon!
> * [Конец? Что дальше?]()


> ### [Пошаговое создание игры на С++/MFC]() // Coming soon!
> * [Урок №1: Введение в создание игры «SameGame» на C++/MFC]()
> * [Урок №2: Архитектура и хранение данных в игре «SameGame» на C++/MFC]()
> * [Урок №3: Отрисовка игры «SameGame» на C++/MFC]()
> * [Урок №4: Обработка событий в игре «SameGame» на C++/MFC]()
> * [Урок №5: Работа с алгоритмом в игре «SameGame» на C++/MFC]()
> * [Урок №6: Работа с меню в игре «SameGame» на C++/MFC]()
> * [Урок №7: Добавление уровней сложности в игре «SameGame» на C++/MFC]()
> * [Урок №8: Размеры и количество блоков в игре «SameGame» на C++/MFC]()
> * [Урок №9: Финальные штрихи в создании игры «SameGame» на C++/MFC]()

> ### [Практические задания по С++]() // Coming soon!
> * [Часть №1: Практические задания по С++]()
> * [Часть №2: Практические задания по С++]()
> * [Часть №3: Практические задания по С++]()
> * [Часть №4: Практические задания по С++]()
> * [Часть №5: Практические задания по С++]()
> * [Часть №6: Практические задания по С++]()
> * [Часть №7: Практические задания по С++]()
> * [Часть №8: Практические задания по С++]()
> * [Часть №9: Практические задания по С++]()
> * [Часть №10: Практические задания по С++]()
> * [Часть №11: Практические задания по С++]()
> * [Часть №12: Практические задания по С++]()
> * [Часть №13: Практические задания по С++]()
> * [Часть №14: Практические задания по С++]()
> * [Часть №15: Практические задания по С++]()
> * [Часть №16: Практические задания по С++]()
> * [Часть №17: Практические задания по С++]()
> * [Часть №18: Практические задания по С++]()
> * [Часть №19: Практические задания по С++]()
> * [Часть №20: Практические задания по С++]()
> * [Часть №21: Практические задания по С++]()
> * [Часть №22: Практические задания по С++]()
> * [Часть №23: Практические задания по С++]()
> * [Часть №24: Практические задания по С++]()

> ### [Уроки по графической библиотеке SFML]() // Coming soon!
> * [Вступление и установка графической библиотеки SFML в C++]()
> * [Создание простых геометрических фигур в C++/SFML]()
> * [Спрайты и текстуры в C++/SFML]()
> * [Часть №1: Создание игры «Тетрис» на С++/SFML]()
> * [Часть №2: Создание игры «Тетрис» на С++/SFML]()
> * [Часть №3: Создание игры «Тетрис» на С++/SFML]()
> * [Создание игры «Сапер» на С++/SFML]()
> * [Создание игры «Пятнашки» на C++/SFML]()

# **Примечание: Это авторские уроки Дмитрия Бушуева!**



___
___
___

# **Глава №0. Введение. Начало работы**
___
# Урок №1. Введение в программирование

Компьютеры понимают только очень ограниченный набор инструкций, и чтобы заставить их что-то делать, нужно четко сформулировать задание, используя эти же инструкции. Программа (также «приложение» или «программное обеспечение», или «софт») — это набор инструкций, которые указывают компьютеру, что ему нужно делать. Физическая часть компьютера, которая выполняет эти инструкции, называется «железом» или аппаратной частью (например, процессор, материнская плата и т.д.). Данный урок является началом серии уроков по программированию на языке С++ для начинающих.


> Оглавление:
>
> 1. [Машинный язык]()
> 2. [Язык ассемблера]()
> 3. [Высокоуровневые языки программирования]()
> 4. [Преимущества высокоуровневых языков программирования]()

## Машинный язык

Процессор компьютера не способен понимать напрямую языки программирования, такие как C++, Java, Python и т.д. Очень ограниченный набор инструкций, которые изначально понимает процессор, называется машинным кодом (или «машинным языком»). То, как эти инструкции организованы, выходит за рамки данного введения, но стоит отметить две вещи.

Во-первых, каждая команда (инструкция) состоит только из определенной последовательности (набора) цифр: 0 и 1. Эти числа называются битами (сокр. от «binary digit») или двоичным кодом.

Например, одна команда машинного кода архитектуры ×86 выглядит следующим образом:

`10110000 01100001`

Во-вторых, каждый набор бит переводится процессором в инструкции для выполнения определенного задания (например, сравнить два числа или переместить число в определенную ячейку памяти). Разные типы процессоров обычно имеют разные наборы инструкций, поэтому инструкции, которые будут работать на процессорах Intel (используются в персональных компьютерах), с большей долей вероятности, не будут работать на процессорах Xenon (используются в игровых приставках Xbox). Раньше, когда компьютеры только начинали массово распространяться, программисты должны были писать программы непосредственно на машинном языке, что было очень неудобно, сложно и занимало намного больше времени, чем сейчас.

## Язык ассемблера

Так как программировать на машинном языке — удовольствие специфическое, то программисты изобрели язык ассемблера. В этом языке каждая команда идентифицируется коротким именем (а не набором единиц с нулями), и переменными можно управлять через их имена. Таким образом, писать/читать код стало гораздо легче. Тем не менее, процессор все равно не понимает язык ассемблера напрямую. Его также нужно переводить, с помощью ассемблера, в машинный код. Ассемблер — это транслятор (переводчик), который переводит код, написанный на языке ассемблера, в машинный язык. В Интернете язык ассемблера часто называют просто «Ассемблер».

Преимуществом Ассемблера является его производительность (точнее скорость выполнения) и он до сих пор используется, когда это имеет решающее значение. Тем не менее, причина подобного преимущества заключается в том, что программирование на этом языке адаптируется к конкретному процессору. Программы, адаптированные под один процессор, не будут работать с другим. Кроме того, чтобы программировать на Ассемблере, по-прежнему нужно знать очень много не очень читабельных инструкций для выполнения даже простого задания.

Например, вот вышеприведенная команда, но уже на языке ассемблера:

`mov al, 061h`

## Высокоуровневые языки программирования

Для решения проблем читабельности кода и чрезмерной сложности были разработаны высокоуровневые языки программирования. C, C++, Pascal, Java, JavaScript и Perl — это всё языки высокого уровня. Они позволяют писать и выполнять программы, не переживая о совместимости кода с разными архитектурами процессоров. Программы, написанные на языках высокого уровня, также должны быть переведены в машинный код перед выполнением. Есть два варианта:
> 
>   * компиляция, которая выполняется компилятором;
>
>   * интерпретация, которая выполняется интерпретатором.

> **Компилятор** — это программа, которая читает код и создает автономную (способную работать независимо от другого аппаратного или программного обеспечения) исполняемую программу, которую процессор понимает напрямую. При запуске программы весь код компилируется целиком, а затем создается исполняемый файл и уже при повторном запуске программы компиляция не выполняется.

Проще говоря, процесс компиляции выглядит следующим образом:

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/sxemagotovoOk.jpg)

> **Интерпретатор** — это программа, которая напрямую выполняет код, без его предыдущей компиляции в исполняемый файл. Интерпретаторы более гибкие, но менее эффективные, так как процесс интерпретации выполняется повторно при каждом запуске программы.

Процесс интерпретации: 

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/sxemagotovo22Ok.jpg)

Любой язык программирования может быть компилируемым или интерпретируемым, однако, такие языки, как C, C++ и Pascal — компилируются, в то время как «скриптовые» языки, такие, как Perl и JavaScript — интерпретируются. Некоторые языки программирования (например, Java) могут как компилироваться, так и интерпретироваться.


## Преимущества высокоуровневых языков программирования

* ***Преимущество №1***: Легче писать/читать код. Вот вышеприведенная команда, но уже на языке C++:

`а = 97;`

* ***Преимущество №2***: Требуется меньше инструкций для выполнения определенного задания. В языке C++ вы можете сделать что-то вроде а = Ь * 2 + 5; в одной строке. В языке ассемблера вам пришлось бы использовать 5 или 6 инструкций.

* ***Преимущество №3***: Вы не должны заботиться о таких деталях, как загрузка переменных в регистры процессора. Компилятор или интерпретатор берёт это на себя.

* ***Преимущество №4***: Высокоуровневые языки программирования более портируемые под различные архитектуры (но есть один нюанс).

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/sxemagotovo33.jpg)

Нюанс заключается в том, что многие платформы, такие как Microsoft Windows, имеют свои собственные специфические функции, с помощью которых писать код намного легче. Но в таком случае приходится жертвовать портируемостью, так как функции, специфические для одной платформы, с большей долей вероятности, не будут работать на другой платформе. Обо всем этом мы детально поговорим на следующих уроках.

___
# Урок №2. Введение в языки программирования C и С++

Перед C++ был C. C (произносится как «Си») был разработан в 1972 году Деннисом Ритчи в Bell Telephone Laboratories как системный язык программирования, т.е. язык для написания операционных систем. Основной задачей Ритчи было создание легко компилируемого минималистического языка, который предоставлял бы эффективный доступ к памяти, относительно быстро выполнялся, и на котором можно было бы писать эффективный код. Таким образом, при разработке высокоуровневого языка, был создан язык Си, который во многом относился к языкам низкого уровня, оставаясь при этом независимым от платформ, для которых мог быть написан код.

Cи в конечном итоге стал настолько эффективным и гибким, что в 1973 году Ритчи и Кен Томпсон переписали больше половины операционной системы UNIX, используя этот язык. Многие предыдущие операционные системы были написаны на языке ассемблера. В отличие от Ассемблера, на котором пишутся программы под конкретные процессоры, высокая портируемость языка Cи позволила перекомпилировать UNIX и на другие типы компьютеров, ускоряя его популяризацию. Язык Cи и операционная система UNIX тесно связаны между собой, и популярность первого отчасти связана с успехом второго.

В 1978 году Брайан Керниган и Деннис Ритчи опубликовали книгу под названием «Язык программирования Cи». Эта книга, более известна как «K&R» (первые буквы фамилий авторов), стала стандартом и своеобразной инструкцией к Си. Когда требовалась максимальная портируемость, то программисты придерживались рекомендаций в «K&R», поскольку большинство компиляторов в то время были реализованы в соответствии со стандартами, присутствующими в этой книге.

В 1983 году Американский национальный институт стандартов (сокр. «ANSI» от англ. «American National Standards Institute») сформировал комитет для утверждения официального стандарта языка Cи. В 1989 году они закончили и выпустили стандарт C89, более широко известный, как ANSI C. В 1990 году Международная организация по стандартизации (сокр. «ISO» от англ. «International Organization for Standardization») приняла ANSI C (с небольшими изменениями). Эта версия языка Cи стала известна как C90. В конечном счете, компиляторы адаптировались под требования ANSI C/C90 и программы, в которых требовалась максимальная портируемость, писались в соответствие с этими стандартами.

В 1999 году комитет ANSI выпустил новую версию языка Cи, которая получила название C99. Она приняла много особенностей, которые были реализованы в компиляторах (в виде различных расширений) или уже в языке C++.

## Язык C++
C++ (произносится как «Си плюс плюс») был разработан Бьёрном Страуструпом в Bell Labs в качестве дополнения к Cи в 1979 г. Он добавил множество новых фич в язык Си. Его популярность была вызвана объектно-ориентированностью языка. Об объектно-ориентированном программировании (ООП) и его отличиях от традиционных методов программирования мы поговорим несколько позже.

Язык C++ был ратифицирован (одобрен) комитетом ISO в 1998 году и потом снова в 2003 году (под названием C++03). Потом были еще три обновления (C++11, C++14 и C++17, ратифицированные в 2011, 2014 и 2017 годах, соответственно), которые добавили больше функциональных возможностей.

## Философия С и С++

Смысл философии языков С и C++ можно определить выражением «доверять программисту». Например, компилятор не будет вам мешать сделать что-то новое, что имеет смысл, но также не будет мешать вам сделать что-то такое, что может привести к сбою. Это одна из главных причин, почему так важно знать то, что вы не должны делать, как и то, что вы должны делать, создавая программы на языках С/С++.

___
# Урок №3. Введение в разработку программного обеспечения

Перед написанием и выполнением нашей первой программы, мы должны понять, как вообще выполняется разработка программного обеспечения на языке C++.

Схема разработки ПО (сокр. от «Программное Обеспечение»):

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/Razrabotka-programmnyh-produktov.jpg)

> ## Оглавление:
> 1. [Шаг №1: Определите проблему, которую хотели бы решить]()
> 2. [Шаг №2: Определитесь, как вы собираетесь решить эту проблему]()
> 3. [Шаг №3: Напишите программу]()
> 4. [Шаг №4: Компиляция]()
> 5. [Шаг №5: Линкинг (связывание объектных файлов)]()
> 6. [Шаг №6: Тестирование и отладка]()

* ## Шаг №1: Определите проблему, которую хотели бы решить

Это шаг «Что?». Здесь вы должны понять, что же вы хотите, чтобы ваша программа делала. Этот шаг может быть, как самым простым, так и самым сложным. Всё, что вам нужно — это четко сформулировать идею. Только после этого вы сможете приступать к следующему шагу.

Вот несколько примеров выполнения шага №1:

 * «Я хочу написать программу, которая вычисляла бы среднее арифметическое чисел, которые я введу».
 
  * «Я хочу написать программу, в которой будет 2D-лабиринт, по которому сможет передвигаться пользователь».

  * «Я хочу написать программу, которая будет анализировать цены акций на бирже и давать предсказания по поводу скачков этих цен вверх или вниз».

* ## Шаг №2: Определитесь, как вы собираетесь решить эту проблему

Здесь мы уже отвечаем на вопрос «Как?». Каким образом можно решить проблему, обозначенную на шаге №1? Этим шагом довольно часто пренебрегают при разработке программного обеспечения. Суть в том, что способов решения задачи может быть много, только часть из них — хорошие решения, а часть — плохие. Вы должны научиться отделять первые от вторых. Очень часто можно наблюдать ситуацию, когда у программиста возникает идея и он сразу же садится программировать. Как вы уже могли догадаться, такой сценарий далеко не всегда приводит к эффективным результатам.

 Как правило, хорошие решения имеют следующие характеристики:
 
 *   простота;
 
 *   хорошая документация (с инструкциями и комментариями);
 
 *   модульный принцип: любая часть программы может быть повторно использована или изменена позже, не затрагивая другие части кода;
 
 *   надежность: соответствующая обработка ошибок и экстренных ситуаций.

Когда вы садитесь и начинаете сразу программировать, вы думаете: «Я хочу сделать это, вот это и еще вот это!». Таким образом вы принимаете решения, которые позволят вам поскорее выполнить задание. Однако это может привести к тому, что вы получите программу, которую позже будет трудно изменить/модифицировать, добавить что-то новое или вам попросту придется разбираться с большим количеством багов.

Согласно закону Парето, программист тратит примерно 20% времени на написание программы и 80% на отладку (исправление ошибок) или поддержку (добавление новых функциональных возможностей) кода. Следовательно, лучше потратить дополнительное время на обдумывание лучшего способа решения проблемы перед процессом написания кода, нежели потом тратить оставшиеся 80% времени на поиск и исправление ошибок.

* ## Шаг №3: Напишите программу

**Для того, чтобы написать программу, необходимы две вещи:**
 
*  знание определенного **языка программирования** (этому мы вас научим);
 
*   **редактор кода**.

Программу можно написать, используя любой редактор, даже тот же Блокнот в Windows или текстовый редактор Vi в Unix. Тем не менее, я настоятельно рекомендую использовать редактор, предназначенный для программирования. Не беспокойтесь, если у вас его еще нет. На следующем уроке мы рассмотрим процесс установки такого приложения.

**Редактор типичного программиста, как правило, имеет следующие особенности, которые облегчают программирование:**

* **Нумерация строк**. Это функция чрезвычайно полезна при отладке программ, когда компилятор выдаёт нам сообщения об ошибках. Типичная ошибка компиляции состоит из наименования ошибки и номера строки, где эта ошибка произошла (например, «ошибка переопределения переменной x, строка 90»). Без нумерации строк искать ту самую 90-ю строку кода было бы несколько затруднительно, не так ли?

* **Подсветка синтаксиса**. Подсветка синтаксиса изменяет цвет разных частей программы и кода, что улучшает восприятие как целой программы, так и её отдельных частей.

* **Специальный шрифт**. В обычных шрифтах очень часто возникает путаница между определенными символами, когда непонятно, какой символ перед вами. Например: цифра 0 или буква O, цифра 1 или буква l (нижний регистр L), или может буква I (верхний регистр i). Вот для этого и нужен специальный шрифт, в котором будет легко различить эти символы, предотвращая случайное использование одного символа вместо другого.

Программы на языке C++ следует называть name.cpp, где name заменяется именем вашей программы, а расширение .cpp сообщает компилятору (и вам тоже), что это исходный файл кода, который содержит инструкции на языке программирования C++. Следует обратить внимание, что некоторые программисты используют расширение .cc вместо .cpp, но я рекомендую использовать именно .cpp.

Также стоит отметить, что много программ, написанных на языке C++, могут состоять из нескольких файлов .cpp. Хотя большинство программ, которые вы будете создавать на протяжении этих уроков, не будут слишком большими, в дальнейшем вы научитесь писать программы, которые будут включать десятки, если не сотни отдельных файлов .cpp.


* ## Шаг №4: Компиляция

Для того, чтобы скомпилировать программу нам нужен компилятор. Работа компилятора состоит из двух частей:

* Проверка программы на соответствие правилам языка C++ (проверка синтаксиса). Если она будет неудачной, то компилятор выдаст сообщения об ошибках, которые нужно будет исправить.

 * Конвертация каждого исходного файла с кодом в объектный файл (или «объектный модуль») на машинном языке. Объектные файлы, как правило, имеют названия name.o или name.obj, где name должно быть такое же как и имя вашего исходного файла .cpp. Если ваша программа состоит из 3-х файлов .cpp, то компилятор сгенерирует 3 объектных файла.

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/compile.jpg)

Стоит отметить, что такие операционные системы как Linux и macOS имеют уже встроенный компилятор C++, который называется g++. Для компиляции файлов из командной строки с помощью g++ вам нужно будет прописать следующее:

`g++ -c file1.cpp file2.cpp file3.cpp`

Таким образом мы создадим file1.o, file2.o и file3.o. -c означает «только скомпилировать», т.е. просто создать .o (объектные) файлы. Кроме g++, существует множество компиляторов для различных операционных систем: Linux, Windows, macOS и других.



* ## Шаг №5: Линкинг (связывание объектных файлов)

**Линкинг** — это процесс связывания всех объектных файлов, генерируемых компилятором, в единую исполняемую программу, которую вы затем сможете запустить/выполнить. Это делается с помощью программы, которая называется линкер (или «компоновщик»).

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/04/linker.jpg)

Кроме объектных файлов, линкер также подключает файлы из Стандартной библиотеки С++ (или любой другой библиотеки, которую вы используете, например, библиотеки графики или звука). Сам по себе язык С++ довольно маленький и простой. Тем не менее, к нему подключается большая библиотека дополнительных функций, которые могут использовать ваши программы, и эти функции находятся в Стандартной библиотеке C++. Например, если вы хотите вывести что-либо на экран, то у вас в коде должна быть специальная команда, которая сообщит компилятору, что вы хотите использовать функцию вывода информации на экран из Стандартной библиотеки C++.

После того, как компоновщик закончит линкинг всех объектных файлов (при условии, что не будет ошибок), вы получите исполняемый файл. Опять же, в целях наглядности, чтобы связать .o файлы, которые мы создали выше в Linux или macOS, мы можем снова использовать g++:

`g++ -o prog file1.o file2.o file3.o`

Команда -o сообщает g++, что мы хотим получить исполняемый файл с именем prog из следующих файлов: `file1.o`, `file2.o` и `file3.o`. При желании, компиляцию и линкинг можно объединить в один шаг:

`g++ -o prog file1.cpp file2.cpp file3.cpp`

Результатом будет исполняемый файл с именем prog.


* ## Шаг №6: Тестирование и отладка

Здесь начинается самое веселое! Вы уже можете запустить исполняемый файл и посмотреть, работает ли всё так, как надо. Если нет, то пришло время отладки. Более подробно об отладке мы поговорим чуть позже.

Обратите внимание, для выполнения шагов №3-№6 вам потребуется специальное программное обеспечение. Хотя вы можете использовать отдельные программы на каждом из этих шагов, один пакет программного обеспечения («IDE» от англ. «Integrated Development Environment») объединяет в себе все эти программы. Обычно с IDE вы получаете редактор кода с нумерацией строк и подсветкой синтаксиса, а также компилятор и линкер. А когда вам нужно будет провести отладку программы, вы сможете использовать встроенный отладчик. Кроме того, IDE объединяет и ряд других полезных возможностей: комплексная помощь, дополнение кода, в некоторых случаях еще и система контроля версий.

___

# Урок №4. Установка IDE (Интегрированной Среды Разработки)

Интегрированная Среда Разработки («IDE» от «Integrated Development Environment») — это программное обеспечение, которое содержит всё необходимое для разработки, компиляции, линкинга и отладки кода. Нам нужно установить одну такую IDE для написания программ на языке С++.

Но какую именно? Я рекомендую Visual Studio от Microsoft (для пользователей Windows) или Code::Blocks (для пользователей Linux/Windows). Также вы можете установить и любую другую IDE. Основные концепции, рассматриваемые в данных уроках, должны работать во всех средах разработки. Впрочем, иногда код может частично отличаться в разных IDE, поэтому вам придется самостоятельно искать более подробную информацию о работе в выбранной вами IDE.

> ## Оглавление:
> 1. [IDE для пользователей Windows]()
> 2. [IDE для пользователей Linux/Windows]()
> 3. [IDE для пользователей macOS]()
> 4. [Веб-компиляторы]()


## IDE для пользователей Windows

Если вы пользователь Windows (как и большинство из нас), то установите Visual Studio 2019 версию «Community», которая является бесплатной (все остальные версии — платные):

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/05/download-IDE.jpg)

После того, как вы скачаете и запустите установщик, вам нужно будет выбрать "Разработка классических приложений на C++". Пункты, выбранные по умолчанию в правой части экрана, трогать не нужно — там всё хорошо, только убедитесь, что поставлена галочка возле пункта "Пакет SDK для Windows 10". Этот пакет может использоваться и в ранних версиях Windows, поэтому не переживайте, если у вас Windows 7 или Windows 8 — всё будет работать. Затем нажимаем "Установить":

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/05/install-IDE.jpg)

При желании вы можете указать галочки и возле других пунктов для скачивания, но учтите, что тогда размер вашей IDE будет увеличен.


## IDE для пользователей Linux/Windows

Если вы пользователь Linux (или Windows, но хотите писать программы, которые затем можно будет легко портировать в Linux), то установите Code::Blocks. Это бесплатная, кроссплатформенная IDE, которая работает как в Linux, так и в Windows.

Пользователям Windows нужно загружать версию с MinGW в комплекте: 

![Image is not loaded](https://ravesli.com/wp-content/uploads/2016/05/download_Code-Blocks.jpg)

Установка простая: просто соглашаетесь со всем, о чём вас спрашивают. Функционал C++11/C++14 в Code::Blocks по умолчанию может быть отключен. Чтобы его использовать, вам нужно перейти в "Settings" > "Compiler":

![](https://ravesli.com/wp-content/uploads/2016/05/compiler-CodeBlocks.jpg)

И во вкладке "Compiler Flags" поставить галочку возле пункта "Have g++ follow the C++14 ISO C++ language standard [-std=c++14]", затем нажать "OK":

![](https://ravesli.com/wp-content/uploads/2016/05/screen2.jpg)

> ***Примечание***: После установки Code::Blocks у некоторых пользователей может появиться следующее сообщение об ошибке: Can’t find compiler executable in your configured search paths for GNU GCC Compiler. Если вы столкнулись с этим, то попробуйте выполнить следующее:
*   Если вы пользователь Windows, убедитесь, что вы загрузили версию Code::Blocks с MinGW (в названии скачиваемого установщика должно быть слово mingw).
*   Попробуйте полностью удалить Code::Blocks, а затем установите его заново.
*   Перейдите в "Settings" > "Compiler" и выберите "Reset to defaults".
*  Если ничего из вышеуказанного не помогло, попробуйте установить другую IDE.

В качестве альтернативы подойдет Bloodshed’s Dev-C++, который также работает как в Windows, так и в Linux.

## IDE для пользователей macOS

Пользователи техники Apple могут использовать Xcode или Eclipse. Eclipse по умолчанию не настроен на использование языка C++, поэтому вам нужно будет дополнительно установить компоненты для C++.
Пользователи техники Apple могут использовать Xcode или Eclipse. Eclipse по умолчанию не настроен на использование языка C++, поэтому вам нужно будет дополнительно установить компоненты для C++.
## Веб-компиляторы

Веб-компиляторы подходят для написания простых, небольших программ. Их функционал ограничен: вы не сможете сохранять проекты, создавать исполняемые файлы или эффективно проводить отладку программ, поэтому лучше скачать полноценную IDE, если у вас действительно серьезные намерения по поводу программирования. А веб-компиляторы используйте разве что для быстрого запуска небольших программ.

**Популярные веб-компиляторы:**
   * OnlineGDB
   * TutorialsPoint
   * C++ Shell
   * Repl.it

Теперь, когда вы установили IDE, пора написать нашу первую программу!

___

# Урок №5. Компиляция вашей первой программы

Перед написанием нашей первой программы мы еще должны кое-что узнать.

> ## Оглавление:
> * [Теория]()
> * [Пользователям Visual Studio]()
> * [Пользователям Code::Blocks]()
> * [Пользователям командной строки]()
> * [Пользователям веб-компиляторов]()
> * [Пользователям других IDE]()
> * [Если компиляция прошла неудачно]()
> * [Заключение]()

## Теория

Во-первых, несмотря на то, что код ваших программ находится в файлах .cpp, эти файлы добавляются в проект. Проект содержит все необходимые файлы вашей программы, а также сохраняет указанные вами настройки вашей IDE. Каждый раз, при открытии проекта, он запускается с того момента, на котором вы остановились в прошлый раз. При компиляции программы, проект говорит компилятору и линкеру, какие файлы нужно скомпилировать, а какие связать. Стоит отметить, что файлы проекта одной IDE не будут работать в другой IDE. Вам придется создать новый проект (в другой IDE).

Во-вторых, есть разные типы проектов. При создании нового проекта, вам нужно будет выбрать его тип. Все проекты, которые мы будем создавать на данных уроках, будут консольного типа. Это означает, что они запускаются в консоли (аналог командной строки). По умолчанию, консольные приложения не имеют графического интерфейса пользователя — GUI (сокр. от «Graphical User Interface») и компилируются в автономные исполняемые файлы. Это идеальный вариант для изучения языка C++, так как он сводит всю сложность к минимуму.

В-третьих, при создании нового проекта большинство IDE автоматически добавят ваш проект в рабочее пространство. Рабочее пространство — это своеобразный контейнер, который может содержать один или несколько связанных проектов. Несмотря на то, что вы можете добавить несколько проектов в одно рабочее пространство, все же рекомендуется создавать отдельное рабочее пространство для каждой программы. Это намного упрощает работу для новичков.

Традиционно, первой программой на новом языке программирования является всеми известная программа «Hello, world!». Мы не будем нарушать традиции 🙂

Пользователям Visual Studio

Для создания нового проекта в Visual Studio 2019, вам нужно сначала запустить эту IDE, затем выбрать `"Файл" > "Создать" > "Проект"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen1.jpg)

Дальше появится диалоговое окно, где вам нужно будет выбрать `"Консольное приложение Windows"` из вкладки `"Visual C++"` и нажать `"ОК"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen2.jpg)

Также вы можете указать имя проекта (любое) и его расположение (рекомендую ничего не менять) в соответствующих полях.

В текстовом редакторе вы увидите, что уже есть некоторый текст и код — удалите его, а затем напечатайте или скопируйте следующий код:

``` cpp
#include <iostream>
 
int main()
{
	std::cout << "Hello, world!" << std::endl;
	return 0;
}
```

Вот, что у вас должно получиться:

![](https://ravesli.com/wp-content/uploads/2016/07/screen4.jpg)

>**ВАЖНОЕ ПРИМЕЧАНИЕ:**
>
> Строка #include "pch.h" требуется только для пользователей Visual Studio 2017. Если вы используете Visual Studio 2019 (или более новую версию), то не нужно писать эту строку вообще.

Чтобы запустить программу в Visual Studio, нажмите комбинацию Ctrl+F5. Если всё хорошо, то вы увидите следующее:

![](https://ravesli.com/wp-content/uploads/2016/07/screen5.jpg)

Это означает, что компиляция прошла успешно и результат выполнения вашей программы следующий:

`Hello, world!`

Чтобы убрать строку «…завершает работу с кодом 0…», вам нужно перейти в `"Отладка" > "Параметры"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen6.jpg)

Затем `"Отладка" > "Общие"` и поставить галочку возле `"Автоматически закрыть консоль при остановке отладки"` и нажать `"ОК"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen7.jpg)

Тогда ваше консольное окно будет выглядеть следующим образом:

![](https://ravesli.com/wp-content/uploads/2016/07/screen8.jpg)

Готово! Мы научились компилировать программу в Visual Studio.

## Пользователям Code::Blocks

Чтобы создать новый проект, запустите Code::Blocks, выберите `"File"` > `"New"` > `"Project"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen9.jpg)

Затем появится диалоговое окно, где вам нужно будет выбрать `"Console application"` и нажать `"Go"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen10.jpg)

Затем выберите язык `"C++"` и нажмите `"Next"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen11.jpg)

Затем нужно указать имя проекта и его расположение (можете создать отдельную папку Projects) и нажать `"Next"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen12.jpg)

В следующем диалоговом окне нужно будет нажать `"Finish"`.

После всех этих манипуляций, вы увидите пустое рабочее пространство. Вам нужно будет открыть папку Sources в левой части экрана и дважды кликнуть по main.cpp:

![](https://ravesli.com/wp-content/uploads/2016/07/screen13.jpg)

Вы увидите, что программа «Hello, world!» уже написана!

Для того, чтобы скомпилировать ваш проект в Code::Blocks, нажмите `Ctrl+F9`, либо перейдите в меню `"Build"` и выберите `"Build"`. Если всё пройдет хорошо, то вы увидете следующее во вкладке `"Build log"`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen14.jpg)

Это означает, что компиляция прошла успешно!

Чтобы запустить скомпилированную программу, нажмите `Ctrl+F10`, либо перейдите в меню `"Build"` и выберите `"Run"`. Вы увидите следующее окно:

![](https://ravesli.com/wp-content/uploads/2016/07/screen15.jpg)

Это результат выполнения вашей программы.

Пользователям командной строки

Вставьте следующий код в текстовый файл с именем `HelloWorld.cpp`:

![](https://ravesli.com/wp-content/uploads/2016/07/screen16.jpg)


## Пользователям командной строки

Вставьте следующий код в текстовый файл с именем HelloWorld.cpp:

``` cpp
#include <iostream>
 
int main()
{
	std::cout << "Hello, world!" << std::endl;
	return 0;
}
```

В командной строке напишите:

`g++ -o HelloWorld HelloWorld.cpp`

Эта команда выполнит компиляцию и линкинг файла HelloWorld.cpp. Для запуска программы напишите:

`HelloWorld`

Или:

`./HelloWorld`

И вы увидите результат выполнения вашей программы (`Hello, World!`)

## Пользователям веб-компиляторов

Вставьте следующий код в рабочее пространство:

``` cpp
#include <iostream>
 
int main()
{
	std::cout << "Hello, world!" << std::endl;
	return 0;
}
```

Затем нажмите `"Run"`. Вы должны увидеть результат в окне выполнения.

Пользователям других IDE

Вам нужно:

* Шаг №1: Создать консольный проект.

* Шаг №2: Добавить файл `.cpp` в проект (если нужно).

* Шаг №3: Вставить следующий код в файл `.cpp`:

```cpp
#include <iostream>
 
int main()
{
	std::cout << "Hello, world!" << std::endl;
	return 0;
}
```

* Шаг №4: Скомпилировать проект.

* Шаг №5: Запустить проект.

Если компиляция прошла неудачно (a.k.a. «О Боже, что-то пошло не так!»)
Всё нормально, без паники. Скорее всего, это какой-то пустяк.

*  Во-первых, убедитесь, что вы написали код правильно: без ошибок и опечаток. Сообщение об ошибке компилятора может дать вам ключ к пониманию того, где и какие ошибки случились.
*   Во-вторых, просмотрите Урок №7 — там есть решения наиболее распространенных проблем.
*   Если всё вышесказанное не помогло — «загуглите» проблему. С вероятностью 90% кто-то уже сталкивался с этим раньше и нашел решение.

## Заключение

Поздравляем, вы написали, скомпилировали и запустили свою первую программу на языке C++! Не беспокойтесь, если вы не понимаете, что означает весь этот код, приведенный выше. Мы детально всё это рассмотрим на следующих уроках.

___

# Урок №6. Режимы конфигурации «Debug» и «Release»

Конфигурация сборки (англ. «build configuration») — это набор настроек проекта, которые определяют принцип его построения. Конфигурация сборки состоит из:

   * имени исполняемого файла;

   * имени директории исполняемого файла;

   * имён директорий, в которых IDE будет искать другой код и файлы библиотек;

   * информации об отладке и параметрах оптимизации вашего проекта.

Интегрированная среда разработки имеет две конфигурации сборки: «Release» (Релиз) и «Debug» (Отладка).

  * Конфигурация «Debug» предназначена для отладки вашей программы. Эта конфигурация отключает все настройки по оптимизации, включает информацию об отладке, что делает ваши программы больше и медленнее, но упрощает проведение отладки. Режим «Debug» обычно используется в качестве конфигурации по умолчанию.

  * Конфигурация «Release» используется во время сборки программы для её дальнейшего выпуска. Программа оптимизируется по размеру и производительности и не содержит дополнительную информацию об отладке.

Например, исполняемый файл программы «Hello, World!» из предыдущего урока, созданный в конфигурации «Debug», у меня занимал 65КБ, в то время как исполняемый файл, построенный в конфигурации «Release», занимал всего лишь 12КБ.

## Переключение между режимами «Debug» и «Release» в Visual Studio

Самый простой способ изменить конфигурацию проекта — выбрать соответствующую из выпадающего списка на панели быстрого доступа:

![](https://ravesli.com/wp-content/uploads/2016/07/screenDebugVisual.jpg)

## Переключение между режимами «Debug» и «Release» в Code::Blocks

В Code::Blocks на панели быстрого доступа есть также выпадающий список, где вы можете выбрать соответствующий режим конфигурации:

![](https://ravesli.com/wp-content/uploads/2016/07/screenCode.jpg)

## Заключение
Используйте конфигурацию «Debug» при разработке программ, а конфигурацию «Release» при их релизе.

___

# Конфигурация компилятора: Расширения компилятора

На этом уроке мы поговорим о том, что такое расширения компилятора, полезны ли они и как их выключить.

> ## Оглавление:
> * [Расширения компилятора]()
> * [Отключение расширений компилятора]()
> * [Пользователям Visual Studio]()
> * [Пользователям Code::Blocks]()
> * [Пользователям GCC/G++]()

## Расширения компилятора
Стандарт языка C++ определяет правила поведения программ при определенных обстоятельствах. И в большинстве случаев компиляторы также будут следовать этим правилам. Однако многие компиляторы вносят свои собственные изменения в язык программирования, часто для улучшения совместимости с другими версиями языка (например, C99), или по историческим причинам. Эти специфичные для компилятора варианты поведения называются расширениями компилятора.

Используя расширения компилятора, вы получаете возможность писать программы, несовместимые со стандартом языка C++. Программы, использующие нестандартные расширения, обычно не компилируются другими компиляторами (которые не поддерживают эти же расширения), или вообще могут работать не так, как нужно.

К сожалению, расширения компилятора часто включены по умолчанию. Это особенно вредно для новичков в программировании, которые могут подумать, что специфическое поведение, вызванное расширениями компилятора, является частью официального стандарта языка C++ (когда, на самом деле, это не так).

Поскольку расширения компилятора очень редко требуются для решения большинства задач, и приводят к тому, что ваши программы не соответствуют стандарту языка C++, то рекомендуется отключать расширения компилятора.

> ***Совет***: Отключите расширения компилятора, чтобы ваши программы оставались совместимыми со стандартами языка C++ и работали в любой системе.

> ***Примечание***: Настройки, приведенные ниже, применяются для каждого проекта отдельно. Вам нужно будет это всё проделывать при создании нового проекта, либо создать шаблон с этими настройками и уже по этому шаблону создавать новые проекты.

## Отключение расширений компилятора


## Пользователям Visual Studio

> Чтобы отключить расширения компилятора в Visual Studio, щелкните правой кнопкой мыши по названию вашего проекта в меню `"Обозреватель решений" > "Свойства"`:

![](https://ravesli.com/wp-content/uploads/2020/04/1.jpg)

В диалоговом окне вашего проекта убедитесь, что в пункте `"Конфигурация"` установлено значение `"Все конфигурации"`. Затем перейдите на вкладку `"C/C++" > "Язык"` и в пункте `"Отключить расширения языка"` выберите значение `"Да (/Za)"`:

![](https://ravesli.com/wp-content/uploads/2020/04/2-3.png)

После этого нажмите "Применить" и "ОК".

## Пользователям Code::Blocks

Отключить расширения компилятора можно через меню `"Settings" > "Compiler"`:

![](https://ravesli.com/wp-content/uploads/2020/04/3-1.png)

Затем на вкладке `"Compiler Flags"` найдите пункт `"Treat as errors the warnings demanded by strict ISO C and ISO C++ [-pedantic-errors]"` и поставьте возле него галочку, после чего нажмите `"OK"`:

![](https://ravesli.com/wp-content/uploads/2020/04/4-1.png)

## Пользователям GCC/G++
Вы можете отключить расширения компилятора, добавив флаг `-pedantic-errors` в командную строку компиляции.

___

# Конфигурация компилятора: Уровни предупреждений и ошибки

На этом уроке мы поговорим о том, как повысить уровень предупреждений в компиляторах и заставить их обрабатывать предупреждения так, как если бы это были ошибки.

> ## Оглавление:
> * [Предупреждения в языке С++]()
> * [Изменение уровня предупреждений]()
> * [Пользователям Visual Studio]()
> * [Пользователям Code::Blocks]()
> * [Пользователям GCC/G++]()
> * [Обрабатывать предупреждения как ошибки]()
> * [Пользователям Visual Studio]()
> * [Пользователям Code::Blocks]()
> * [Пользователям GCC/G++]()

## Предупреждения в языке С++
На этапе компиляции компилятор проверяет, соответствует ли ваш код правилам языка C++. Если вы сделали что-то запрещенное, что нарушило синтаксис языка С++, то компилятор выдаст ошибку, предоставив вам как номер строки, содержащий ошибку, так и некоторый текст о содержании самой ошибки. Фактически, ошибка может находиться как в этой строке (которую сообщил вам компилятор), так и в строке перед ней. После того, как вы определили и исправили ошибочные строки кода, вы можете попробовать скомпилировать вашу программу еще раз.

Еще могут быть ситуации, когда компилятор видит ошибочный код, но не до конца в этом уверен (помните, что философия языка С++ заключается в выражении «Доверяй программисту!»). В таких случаях компилятор может выдать предупреждение. Предупреждения не останавливают процесс компиляции, но сообщают программисту, что что-то пошло не так.

> ***Совет***: Не позволяйте предупреждениям накапливаться. Решайте их по мере возникновения (так, как будто бы это были ошибки).

В большинстве случаев предупреждения могут быть устранены либо путем исправления ошибки, на которую указывает предупреждение, либо путем переписывания строки кода, генерирующей предупреждение, таким образом, чтобы предупреждение больше не генерировалось.

В редких случаях может потребоваться явно указать компилятору не генерировать конкретное предупреждение для рассматриваемой строки кода. Язык C++ не поддерживает такой способ решения предупреждений, но многие отдельные компиляторы (включая Visual Studio и GCC) предоставляют возможность (через не портативные директивы #pragma) временного отключения предупреждений.

По умолчанию большинство компиляторов генерируют только предупреждения о наиболее очевидных проблемах. Однако вы можете попросить ваш компилятор быть более настойчивым в предоставлении предупреждений о вещах, которые он считает странными.

> ***Совет***: Сделайте максимальным уровень предупреждений от компилятора (особенно во время обучения). Это поможет вам определить возможные проблемы.

## Изменение уровня предупреждений


## Пользователям Visual Studio
Чтобы повысить уровень предупреждений в Visual Studio, щелкните правой кнопкой мышки по названию вашего проекта в меню `"Обозреватель решений" > "Свойства"`:


![](https://ravesli.com/wp-content/uploads/2020/04/1.jpg)

В диалоговом окне вашего проекта убедитесь, что в пункте `"Конфигурация"` установлено значение `"Все конфигурации"`. Затем перейдите на вкладку `"C/C++" > "Общие"` и в пункте `"Уровень предупреждений"` выберите значение `"Уровень4 (/W4)"`:

![](https://ravesli.com/wp-content/uploads/2020/04/1-2.png)

Затем нажмите "Применить" и "ОК".

> ***Примечание***: Не выбирайте пункт "Включить все предупреждения (/Wall)", иначе вы будете погребены в предупреждениях, генерируемых Стандартной библиотекой C++.

## Пользователям Code::Blocks
Перейдите в меню `"Settings" > "Compiler"`:

![](https://ravesli.com/wp-content/uploads/2020/04/3-1.png)

И на вкладке `"Compiler settings" > "Compiler flags"` поставьте галочки возле следующих пунктов:

   * Enable all common compiler warnings (overrides many other settings) [-Wall]

   * Enable Effective-C++ warnings (thanks Scott Meyers) [-Weffc++]

   * Enable extra compiler warnings [-Wextra]

Смотрим:

![](https://ravesli.com/wp-content/uploads/2020/04/4-2.pngs)

Нажмите `"ОК"` и затем перейдите на вкладку `"Other compiler options"` и добавьте в область редактирования текст `-Wsign-conversion –Werror`:

![](https://ravesli.com/wp-content/uploads/2020/04/5-1.png)

И нажмите `"Ок"`.

> ***Примечание***: О параметре `-Werror` мы поговорим чуть позже.


## Пользователям GCC/G++
Добавьте следующие флаги в вашу командную строку:

`-Wall -Weffc++ -Wextra -Wsign-conversion`

## Обрабатывать предупреждения как ошибки
Вы также можете указать вашему компилятору обрабатывать все предупреждения так, как если бы они были ошибками (в таком случае, компилятор будет останавливать процесс компиляции, если обнаружит какие-либо предупреждения). Это хороший вариант заставить себя исправлять все предупреждения, особенно, если вам не хватает самодисциплины (как, впрочем, большинству из нас).

## Пользователям Visual Studio

Чтобы обрабатывать все предупреждения как ошибки, щелкните правой кнопкой мышки по названию вашего проекта в меню `"Обозреватель решений" > "Свойства"`:

![](https://ravesli.com/wp-content/uploads/2020/04/1.jpg)

В диалоговом окне вашего проекта убедитесь, что в поле `"Конфигурация"` установлено значение `"Все конфигурации"`. Затем перейдите на вкладку `"C/C++" > "Общие"` и в пункте `"Обрабатывать предупреждения как ошибки"` выберите значение `"Да(/WX)"`:

![](https://ravesli.com/wp-content/uploads/2020/04/7-1.png)

Затем нажмите `"Применить"` и `"ОК"`.

## Пользователям Code::Blocks
Перейдите в меню `"Settings"` > `"Compiler"`:

![](https://ravesli.com/wp-content/uploads/2020/04/3-1.png)

Затем `"Compiler settings"` > `"Other compiler options"` и добавьте `-Werror` в область редактирования:

![](https://ravesli.com/wp-content/uploads/2020/04/5-1.png)

Затем нажмите `"ОК"`.

## Пользователям GCC/G++
Добавьте следующий флаг в вашу командную строку:

`-Werror`

___
# Конфигурация компилятора: Выбор стандарта языка С++

Как с огромным количеством различных версий языка C++ (C++98, C++03, C++11, C++14, C++17, C++20) компилятор понимает, какую из них ему следует использовать? Как правило, компилятор выбирает стандарт языка по умолчанию (часто не самый последний языковой стандарт). Если вы хотите использовать другой стандарт, то вам придется внести изменения в настройки вашей IDE/компилятора. Эти настройки применяются только к текущему проекту. При создании нового проекта вам придется всё делать заново.

> Оглавление:
> * [Кодовые имена для версий языка С++]()
> * [Установка стандарта языка С++ в Visual Studio]()
> * [Установка стандарта языка C++ в Code::Blocks]()
> * [Установка стандарта языка С++ в GCC/G++]()
> * [Тестирование вашего компилятора]()

## Кодовые имена для версий языка С++
Обратите внимание на то, что каждый языковый стандарт имеет название, указывающее на год его принятия/утверждения (например, C++17 был принят/утвержден в 2017 году).

Однако, когда согласовывается новый языковой стандарт, неясно, в каком году удастся его принять, поэтому действующим языковым стандартам присваиваются кодовые имена, которые затем заменяются фактическими именами при доработке стандарта. Например, C++11 назывался c++1x, пока над ним вели работу. Вы можете по-прежнему видеть на просторах Интернета подобные кодовые имена (особенно, когда речь заходит о будущей версии языкового стандарта, у которого еще нет окончательного названия).

Вот сопоставление кодовых имен версий С++ с их окончательными названиями:

  * c++1x = C++11

  * c++1y = C++14

  * c++1z = C++17

  * c++2a = C++20

Например, если вы видите c++1z, то знайте, что речь идет о стандарте C++17.

## Установка стандарта языка С++ в Visual Studio

На момент написания данной статьи, Visual Studio 2019 по умолчанию использует возможности C++14, что не позволяет использовать более новые фичи, представленные в C++17 и в C++20.

Чтобы использовать новый функционал, вам необходимо подключить новый языковой стандарт. К сожалению, сейчас нет способа сделать это глобально — вы должны делать это к каждому проекту индивидуально.

Чтобы использовать новый языковый стандарт в Visual Studio, откройте ваш проект, затем щелкните правой кнопкой мышки по названию вашего проекта в меню "Обозреватель решений" > "Свойства":

![](https://ravesli.com/wp-content/uploads/2020/04/1.jpg)


В диалоговом окне вашего проекта убедитесь, что в пункте "Конфигурация" установлено значение "Все конфигурации". Затем перейдите на вкладку "C/C++" > "Язык" и в пункте "Стандарт языка С++" выберите ту версию языка С++, которую хотели бы использовать:

![](https://ravesli.com/wp-content/uploads/2020/04/1-3.png)

На момент написания данной статьи, я рекомендую выбрать "Стандарт ISO C++17 (/std:c++17)", который является последним стабильным стандартом.

Если вы хотите поэкспериментировать с возможностями грядущего стандарта языка C++ — C++20, то вы можете выбрать пункт "Предварительная версия ... (/std:c++latest)". Просто помните, что его поддержка может иметь баги.

## Установка стандарта языка C++ в Code::Blocks
Code::Blocks по умолчанию может использовать стандарт C++11. Хорошей новостью является то, что Code::Blocks позволяет устанавливать ваш стандарт языка С++ глобально, поэтому вы можете установить его один раз и сразу на все проекты (а не для каждого проекта в индивидуальном порядке). Для этого перейдите в меню `"Settings" > "Compiler"`:

![](https://ravesli.com/wp-content/uploads/2020/04/3-1.png)


Затем на вкладке "Compiler flags" найдите следующие пункты меню:

![](https://ravesli.com/wp-content/uploads/2016/07/screen1-1.png)

Отметьте тот пункт, у которого число обозначает ближайший (к текущему) год утверждения стабильной версии и нажмите "ОК" (на вышеприведенном скриншоте этим пунктом является "Have g++ follow the C++17 ISO C++ language standard [-std=c++17]").

> ***Примечание***: Если вы не нашли в ваших настройках опцию с C++17, то вам следует обновить вашу версию Code::Blocks.


## Установка стандарта языка С++ в GCC/G++

В GCC/G++ вы можете прописать соответствующие флаги `-std=c++11`, `-std=c++14`, `-std=c++17`или `-std=c++2a`, чтобы подключить функционал C++11/14/17/20, соответственно.

## Тестирование вашего компилятора
После подключения версии C++17 или выше, вы можете провести тест, который позволит понять, всё ли верно сделано и действительно ли подключена новая версия языка С++. Следующая программа в С++17 должна выполниться без каких-либо предупреждений или ошибок:

``` cpp
#include <array>
#include <iostream>
#include <string_view>
#include <tuple>
#include <type_traits>
 
namespace a::b::c
{
    inline constexpr std::string_view str{ "hello" };
}
 
template <class... T>
std::tuple<std::size_t, std::common_type_t<T...>> sum(T... args)
{
    return { sizeof...(T), (args + ...) };
}
 
int main()
{
    auto [iNumbers, iSum]{ sum(1, 2, 3) };
    std::cout << a::b::c::str << ' ' << iNumbers << ' ' << iSum << '\n';
 
    std::array arr{ 1, 2, 3 };
 
    std::cout << std::size(arr) << '\n';
 
    return 0;
}
```

Если вы не можете скомпилировать этот код, то либо вы не подключили C++17, либо ваш компилятор не полностью поддерживает C++17. В последнем случае обновите версию IDE или компилятора.

___

# Урок №7. Решения самых распространенных проблем

На этом уроке мы рассмотрим наиболее частые проблемы, с которыми сталкиваются новички при написании программ на языке C++.

> Оглавление:
> * [Проблема №1]()
> * [Проблема №2]()
> * [Проблема №3]()
> * [Проблема №4]()
> * [Проблема №5]()
> * [Проблема №6]()
> * [Проблема №7]()
> * [Проблема №8]()
> * [Проблема №9]()
> * [Проблема №10]()
> * [У меня есть другая проблема]()

## Проблема №1
> Как использовать кириллицу в программах C++?

**Ответ №1**

Чтобы выводить кириллицу в языке C++ нужно подключить заголовочный файл <Windows.h>:

`#include <Windows.h>`

И прописать следующие две строки в функции `main()`:

``` cpp
SetConsoleCP(1251);  
SetConsoleOutputCP(1251);
```

В качестве альтернативного варианта можно использовать следующую строку в функции `main()`:

`setlocale(LC_ALL, "Russian");`


## Проблема №2

> При выполнении программы появляется черное консольное окно, а затем сразу пропадает.

**Ответ №2**

Некоторые компиляторы (например, Bloodshed’s Dev C++) автоматически не задерживают консольное окно после того, как программа завершила свое выполнение. Если проблема в компиляторе, то следующие два шага решат эту проблему:

* Шаг №1: Добавьте следующую строку кода в верхнюю часть вашей программы:

`#include <iostream>`

* Шаг №2: Добавьте следующий код в конец функции main() (прямо перед оператором return):

``` cpp
std::cin.clear(); 
std::cin.ignore(32767, '\n');
std::cin.get();
```

Таким образом, программа будет ожидать нажатия клавиши, чтобы закрыть консольное окно. Вы получите дополнительное время, чтобы хорошенько всё рассмотреть/изучить. После нажатия любой клавиши, консольное окно закроется.

Другие решения, такие как system("pause");, могут работать только на определенных операционных системах, поэтому вариант, приведенный выше, предпочтительнее.

> ***Примечание***: Visual Studio не задерживает консольное окно, если выполнение запущено с отладкой (`"Отладка" > "Начать отладку"` или `F5`). Если вы хотите, чтобы была пауза — воспользуйтесь решением выше или запустите программу без отладки (`"Отладка" > "Запуск без отладки"` или `Ctrl+F5`).

### Проблема №3
> При использовании `cin`, `cout` или `endl` компилятор говорит, что `cin`, `cout` или `endl` являются `«undeclared identifier»` (необъявленными идентификаторами).

**Ответ №3**

Во-первых, убедитесь, что у вас присутствует следующая строка кода в верхней части вашей программы:

``` cpp
#include <iostream>
```

Во-вторых, убедитесь, что `cin`, `cout` или `endl` имеют префикс `std::`, например:

``` cpp
std::cout << "Hello world!" << std::endl;
```

## Проблема №4

> При использовании `endl` для перехода на новую строку, появляется ошибка, что `end1 является «undeclared identifier»`.

**Ответ №4**

Убедитесь, что вы не перепутали букву `l` (нижний регистр L) в `endl` с цифрой 1. В endl все символы являются буквами. Также легко можно перепутать заглавную букву `О` с цифрой `0` (ноль).

## Проблема №5
> Моя программа компилируется, но работает не так, как нужно. Что мне делать?

**Ответ №5**

Выполните отладку программы. Детально об этом читайте на уроке №26 и на уроке №27.

## Проблема №6

> Как включить нумерацию строк в Visual Studio?

**Ответ №6**

Перейдите в меню `"Средства" > "Параметры"`:


![](https://ravesli.com/wp-content/uploads/2016/07/screen1-1.jpg)

Затем откройте вкладку "Текстовый редактор" > "Все языки" > "Общие" и поставьте галочку возле "Номера строк", затем нажмите "ОК":

![](https://ravesli.com/wp-content/uploads/2016/07/screen2-1.jpg)


## Проблема №7
> При компиляции программы я получаю следующую ошибку: «unresolved external symbol _main or _WinMain@16».

**Ответ №7**

Это означает, что ваш компилятор не может найти главную функцию main(). Все программы должны содержать эту функцию.

Здесь есть несколько пунктов, которые нужно проверить:

  * Есть ли в вашей программе функция main()?

  * Слово main написано правильно?

  * Подключен ли файл, который содержит функцию main(), к вашему проекту? (если нет, то переместите функцию main() в файл, который является частью вашего проекта, либо добавьте этот файл в ваш проект)

  * Подключен ли файл, содержащий функцию main(), к компиляции?

## Проблема №8

> При компиляции программы я получаю следующее предупреждение: «Cannot find or open the PDB file».

**Ответ №8**

Это не ошибка, а предупреждение. На работоспособность вашей программы оно не повлияет. Тем не менее, в Visual Studio вы можете решить всё следующим образом: перейдите в меню `"Отладка" > "Параметры" > "Отладка" > "Символы"` и поставьте галочку возле `"Серверы символов (Майкрософт)"`, затем нажмите `"ОК"`.

## Проблема №9
> Я использую Code::Blocks или G++, но функционал C++11/C++14 не работает.

**Ответ №9**

В Code::Blocks перейдите в `"Project" > "Build options" > "Compiler settings" > "Compiler flags"` и поставьте галочку возле пункта `"Have g++ follow C++14 ISO C++ language standard"`. Смотрите урок №4 — там есть скриншоты, как это сделать.

При компиляции в g++, добавьте следующий код в командную строку:

`-std=c++14`

## Проблема №10
> Я запустил программу, появилось консольное окно, но ничего не выводится.

**Ответ №10**

Ваш антивирус может блокировать выполнение вашей программы. Попробуйте отключить его на время и запустите программу еще раз.


## У меня есть другая проблема, с которой я не могу разобраться. Как и где я могу получить ответ?
По мере прохождения данных уроков, у вас, несомненно, появятся вопросы или вы столкнетесь с проблемами. Что делать?

Во-первых, спросите у Google. Четко сформулируйте вашу проблему и просто «погуглите». Если у вас есть сообщение об ошибке — скопируйте его и вставьте в поиск Google, используя кавычки. Скорее всего, кто-то уже задавал такой же вопрос, как у вас, и получил на него ответ.

Если Google не помог, то спросите на специализированных сервисах вопросов/ответов, либо на форумах, посвященным тематике программирования/IT. Вот самые популярные из них:

   [Stack Overflow](http://stackoverflow.com)

   [CyberForum](http://cyberforum.ru)

   [Хабр Q&A (раньше Toster)](http://qna.habr.com)

Но будьте внимательны и старайтесь максимально конкретизировать свою проблему, укажите, какую операционную систему и IDE вы используете, а также то, что вы пробовали сделать самостоятельно для решения своей проблемы.

___
___

# Глава №1. Основы C++
___
# Урок №8. Структура программ

> Компьютерная программа — это последовательность инструкций, которые сообщают компьютеру, что ему нужно сделать.

> ## Оглавление:
> * [Стейтменты]()
> * [Выражения]()
> * [Функции]()
> * [Библиотеки]()
> * [Пример простой программы]()
> * [Синтаксис и синтаксические ошибки]()
> * [Тест]()
> * [Ответы]()

## Стейтменты

> Cтейтмент (англ. «statement») — это наиболее распространенный тип инструкций в программах. Это и есть та самая инструкция, наименьшая независимая единица в языке С++. Стейтмент в программировании — это то же самое, что и «предложение» в русском языке. Мы пишем предложения, чтобы выразить какую-то идею. В языке C++ мы пишем стейтменты, чтобы выполнить какое-то задание. Все стейтменты в языке C++ заканчиваются точкой с запятой.

Есть много разных видов стейтментов в языке C++. Рассмотрим самые распространенные из них:

```cpp
int x;
x = 5;
std::cout << x;
```
`int х` — это стейтмент объявления (англ. «statement declaration»). Он сообщает компилятору, что `х` является переменной. В программировании каждая переменная занимает определенное число адресуемых ячеек в памяти в зависимости от её типа. Минимальная адресуемая ячейка — байт. Переменная типа `int` может занимать до 4-х байт, т.е. до 4-х адресуемых ячеек памяти. Все переменные в программе должны быть объявлены, прежде чем использованы. Мы детально поговорим о переменных на следующих уроках.

`х = 5` — это стейтмент присваивания (англ. «assignment statement»). Здесь мы присваиваем значение `5` переменной `х`.

`std::cout << x;` — это стейтмент вывода (англ. «output statement»). Мы выводим значение переменной х на экран.

## Выражения

Компилятор также способен обрабатывать выражения. Выражение (англ. «expression») — это математический объект, который создается (составляется) для проведения вычислений и нахождения соответствующего результата. Например, в математике выражение `2 + 3` имеет значение `5`. Выражения в языке С++ могут содержать:

  * отдельные цифры и числа (например, `2`, `45`);

  * буквенные переменные (например, `х`, `у`);

  * операторы, в т.ч. математические (например, `+`, `-`);

  * функции.

Выражения могут состоять как из единичных символов — цифр или букв (например, `2` или `х`), так и из различных комбинаций этих символов с операторами (например, `2 + 3`, `2 + х`, `х + у` или `(2 + х) * (y - 3)`). Для наглядности разберем простой корректный стейтмент присваивания `х = 2 + 3;`. Здесь мы вычисляем результат сложения чисел `2 + 3`, который затем присваиваем переменной `х`.

## Функции

В языке C++ стейтменты объединяются в блоки — функции. Функция — это последовательность стейтментов. Каждая программа, написанная на языке C++, должна содержать главную функцию `main()`. Именно с первого стейтмента, находящегося в функции `main()`, и начинается выполнение всей программы. Функции, как правило, выполняют конкретное задание. Например, функция `max()` может содержать стейтменты, которые определяют большее из заданных чисел, а функция `calculateGrade()` может вычислять среднюю оценку студента по какой-либо дисциплине.

> ***Совет***: Всегда размещайте функцию `main()` в файле `.cpp` (`.cc`) с именем, совпадающим с именем проекта. Например, если вы пишете программу `Chess`, то поместите вашу функцию `main()` в файл `chess.cpp`.

## Библиотеки

> Библиотека — это набор скомпилированного кода (например, функций), который был «упакован» для повторного использования в других программах. С помощью библиотек можно расширить возможности программ. Например, если вы пишете игру, то вам придется подключать библиотеки звука или графики (если вы самостоятельно не хотите их создавать).

Язык C++ не такой уж и большой, как вы могли бы подумать. Тем не менее, он идет в комплекте со Стандартной библиотекой С++, которая предоставляет дополнительный функционал. Одной из наиболее часто используемых частей Стандартной библиотеки C++ является библиотека `iostream`, которая позволяет выводить данные на экран и обрабатывать пользовательский ввод.

## Пример простой программы

Теперь, когда у вас есть общее представление о том, что такое стейтменты, функции и библиотеки, давайте рассмотрим еще раз программу `«Hello, world!»`:

``` cpp
#include <iostream>
 
int main()
{
   std::cout << "Hello, world!";
   return 0;
}
```

***Строка №1***: Специальный тип инструкции, который называется директивой препроцессора. Директивы препроцессора сообщают компилятору, что ему нужно выполнить определенное задание. В этом случае мы говорим компилятору, что хотели бы подключить содержимое заголовочного файла `<iostream>` к нашей программе. Подключение заголовочного файла `<iostream>` дает нам возможность использовать функционал библиотеки `iostream`, что, в свою очередь, позволяет выводить нам данные на экран.

***Строка №2***: Пустое пространство, которое игнорируется компилятором.

***Строка №3***: Объявление главной функции `main()`.

***Строки №4 и №7***: Указываем компилятору область функции `main()`. Всё, что находится между открывающей фигурной скобкой в строке №4 и закрывающей фигурной скобкой в строке №7 — считается содержимым функции `main()`.

***Строка №5***: Наш первый стейтмент (заканчивается точкой с запятой) — стейтмент вывода. `std::cout` — это специальный объект, используя который мы можем выводить данные на экран. `<<` — это оператор вывода. Всё, что мы отправляем в `std::cout`, — выводится на экран. В этом случае, мы выводим текст `"Hello, world!"`.

***Строка №6***: Оператор возврата return. Когда программа завершает свое выполнение, функция main() передает обратно в операционную систему значение, которое указывает на результат выполнения программы: успешно ли прошло выполнение программы или нет.

Если оператор `return` возвращает число `0`, то это значит, что всё хорошо! Ненулевые возвращаемые значения указывают на то, что что-то пошло не так и выполнение программы было прервано. Об операторе `return` мы еще поговорим детально на соответствующем уроке.

## Синтаксис и синтаксические ошибки

Как вы, должно быть, знаете, в русском языке все предложения подчиняются правилам грамматики. Например, каждое предложение должно заканчиваться точкой. Правила, которые регулируют построение предложений, называются синтаксисом. Если вы не поставили точку и записали два предложения подряд, то это является нарушением синтаксиса русского языка.

Язык C++ также имеет свой синтаксис: правила написания кода/программ. При компиляции вашей программы, компилятор отвечает за то, чтобы ваша программа соответствовала правилам синтаксиса языка C++. Если вы нарушили правила, то компилятор будет ругаться и выдаст вам ошибку.

Например, давайте посмотрим, что произойдет, если мы не укажем в конце стейтмента точку с запятой:

``` cpp
#include <iostream>
 
int main()
{
   std::cout << "Hello world!"
   return 0;
}
```

## Результат:

`E0065: требуется точка с запятой ";"`

`C2143: синтаксическая ошибка: отсутствие ";" перед "}"`

Допущена синтаксическая ошибка в *строке №6*: мы забыли указать точку с запятой перед оператором `return`. В этом случае ошибка на самом деле в конце *строки №5*. В большинстве случаев компилятор правильно определяет строку с ошибкой, но есть ситуации, когда ошибка не заметна вплоть до начала следующей строки.

Синтаксические ошибки нередко совершаются при написании программ. К счастью, большинство из них можно легко найти и исправить. Но следует помнить, что программа может быть полностью скомпилирована и выполнена только при отсутствии ошибок.

## Тест
Теперь давайте проверим то, как вы усвоили материал текущего урока. Ответьте на следующие вопросы:

  * В чём разница между стейтментом и выражением?

  * В чём разница между функцией и библиотекой?

  * Чем заканчиваются стейтменты в языке С++?

  * Что такое синтаксическая ошибка?

Ответы:

**Ответ №1**

> Стейтмент — это «полное предложение», которое сообщает компилятору, что ему нужно выполнить определенное задание. Выражение всегда имеет результат (исключение — деление на ноль) и является частью стейтмента.

**Ответ №2**

> Функция — это последовательность стейтментов для выполнения определенного задания. Библиотека — это последовательность функций, которые могут повторно использоваться в других программах.

**Ответ №3**

> Стейтменты заканчиваються точкой с запятой (`;`).

**Ответ №4**

> Синтаксическая ошибка — это ошибка, указывающая на нарушение правил грамматики языка С++.

___
# Урок №9. Комментарии

> Комментарий — это строка (или несколько строк) текста, которая вставляется в исходный код для объяснения того, что делает код. В языке C++ есть 2 типа комментариев: однострочные и многострочные.

> ## Оглавление:
> * [Однострочные комментарии]()
> * [Многострочные комментарии]()
> * [Как правильно писать комментарии?]()
> * [Закомментировать код]()

## Однострочные комментарии

> Однострочные комментарии — это комментарии, которые пишутся после символов //. Они пишутся в отдельных строках и всё, что находится после этих символов комментирования, — игнорируется компилятором, например:

``` cpp
std::cout << «Hello, world!» << std::endl; // всё, что находится справа от двойного слеша, - игнорируется компилятором
```

Как правило, однострочные комментарии используются для объяснения одной строчки кода:

``` cpp
std::cout << «Hello, world!» << std::endl; // cout и endl находятся в библиотеке iostream
std::cout << «It is so exciting!» << std::endl; // эти комментарии усложняют чтение кода
std::cout << «Yeah!» << std::endl; // особенно, когда строки разной длины
```

Размещая комментарии справа от кода, мы затрудняем себе как чтение кода, так и чтение комментариев. Следовательно, однострочные комментарии лучше размещать над строками кода:


``` cpp
// cout и endl находятся в библиотеке iostream
std::cout << «Hello, world!» << std::endl;
 
// теперь уже легче читать
std::cout << «It is so exciting!» << std::endl;
 
// не так ли?
std::cout << «Yeah!» << std::endl;
```

## Многострочные комментарии

> Многострочные комментарии — это комментарии, которые пишутся между символами /* */. Всё, что находится между звёздочками, — игнорируется компилятором:

``` cpp
/* Это многострочный комментарий.
Эта строка игнорируется
и эта тоже. */
```

Так как всё, что находится между звёздочками, — игнорируется, то иногда вы можете наблюдать следующее:

``` cpp
/* Это многострочный комментарий.
* Звёздочки слева
* упрощают чтение текста
*/
```
Многострочные комментарии не могут быть вложенными (т.е. одни комментарии внутри других):
``` cpp
/* Это многострочный /* комментарий */ а это уже не комментарий */
// Верхний комментарий заканчивается перед первым */, а не перед вторым */
```
***Правило: Никогда не используйте вложенные комментарии.***

## Как правильно писать комментарии?
Во-первых, на уровне библиотек/программ/функций комментарии отвечают на вопрос «ЧТО?»: «Что делают эти библиотеки/программы/функции?». Например:

``` cpp
// Эта программа вычисляет оценку студента за семестр на основе его оценок за модули
 
// Эта функция использует метод Ньютона для вычисления корня функции
 
// Следующий код генерирует случайное число
```

Все эти комментарии позволяют понять, что делает программа, без необходимости смотреть на исходный код. Это особенно важно специалистам, работающим в команде, где не каждый специалист будет знаком со всем имеющимся кодом.

Во-вторых, внутри библиотек/программ/функций комментарии отвечают на вопрос «КАК?»: «Как код выполняет задание?». Например:

``` cpp
/* Для расчета итоговой оценки ученика, мы складываем все его оценки за уроки и домашние задания,
   а затем делим получившееся число на общее количество оценок. 
   Таким образом, мы получаем средний балл ученика. */
```

Или:

``` cpp
// Чтобы получить рандомный (случайный) элемент, мы выполняем следующее:
 
// 1) Составляем список всех элементов.
// 2) Вычисляем среднее значение для каждого элемента, исходя из его веса, цвета и цены.
// 3) Выбираем любое число.
// 4) Определяем соответствие элемента случайно выбранному числу.
// 5) Возвращаем случайный элемент.
```

Эти комментарии позволяют читателю понять, каким образом код выполняет поставленное ему задание.


В-третьих, на уровне стейтментов (однострочного кода) комментарии отвечают на вопрос «ПОЧЕМУ?»: «Почему код выполняет задание именно так, а не иначе?». Плохой комментарий на уровне стейтментов объясняет, что делает код. Если вы когда-нибудь писали код, который был настолько сложным, что нужен был комментарий, который бы объяснял, что он делает, то вам нужно было бы не писать комментарий, а переписывать этот код.

Примеры плохих и хороших однострочных комментариев:

**Плохой комментарий:**
``` cpp
// Присваиваем переменной sight значение 0
sight = 0;
```


(По коду это и так понятно)

**Хороший комментарий:**

``` cpp
// Игрок выпил зелье слепоты и ничего не видит
sight = 0;
```

(Теперь мы знаем, ПОЧЕМУ зрение у игрока равно нулю)

**Плохой комментарий:**

``` cpp
// Рассчитываем стоимость элементов
cost = items / 2 * storePrice;
```

(Да, мы видим, что здесь подсчет стоимости, но почему элементы делятся на 2?)

**Хороший комментарий:**


``` cpp
// Нам нужно разделить все элементы на 2, потому что они куплены по парам
cost = items / 2 * storePrice;
```

(Теперь понятно!)

Программистам часто приходится принимать трудные решения по поводу того, каким способом решить проблему. А комментарии и существуют для того, чтобы напомнить себе (или объяснить другим) причину, почему вы написали код именно так, а не иначе.

**Хорошие комментарии:**

``` cpp

2
// Мы решили использовать список вместо массива,
// потому что массивы осуществляют медленную вставку.
```

Или:

``` cpp
// Мы используем метод Ньютона для вычисления корня функции, 
// так как другого детерминистического способа решения этой задачи - нет.
```

И, наконец, комментарии нужно писать так, чтобы человек, который не имеет ни малейшего представления о том, что делает ваш код — смог в нем разобраться. Очень часто случаются ситуации, когда программист говорит: «Это же совершенно очевидно, что делает код! Я это точно не забуду!». Угадайте, что случится через несколько недель или даже дней? Это не совершенно очевидно, и вы удивитесь, как скоро вы забудете то, что делает ваш код. Вы (или кто-то другой) будете очень благодарны себе за то, что оставите комментарии, объясняя на человеческом языке что, как и почему делает ваш код. Читать отдельные строки кода — легко, понимать их логику и смысл — сложно.

Подытожим:

  * На уровне библиотек/программ/функций оставляйте комментарии, отвечая на вопрос «ЧТО?».

  * Внутри библиотек/программ/функций оставляйте комментарии, отвечая на вопрос «КАК?».

  * На уровне стейтментов оставляйте комментарии, отвечая на вопрос «ПОЧЕМУ?».


## Закомментировать код

> Закомментировать код — это конвертировать одну или несколько строк кода в комментарии. Таким образом, вы можете (временно) исключить часть кода из компиляции.

Чтобы закомментировать **одну строку кода**, используйте однострочные символы комментирования `//`.

Не закомментировано:

`std::cout << 1;`

Закомментировано:

`//    std::cout << 1;`

Чтобы закомментировать **блок кода**, используйте однострочные символы комментирования `//` на каждой строке или символы многострочного комментария `/*`{блок кода}`*/`.


Не закомментировано:
``` cpp
std::cout << 1;
std::cout << 2;
std::cout << 3;
```

Закомментировано символами однострочного комментария:
``` cpp
//    std::cout << 1;
//    std::cout << 2;
//    std::cout << 3;
```

Закомментировано символами многострочного комментария:

``` cpp
/*
     std::cout << 1;
     std::cout << 2;
     std::cout << 3;
*/
```

Есть несколько причин, почему следует использовать «закомментирование»:

  * Причина №1: Вы работаете над новой частью кода, которая пока что не рабочая, но вам нужно запустить программу. Компилятор не позволит выполнить программу, если в ней будут ошибки. Временное отделение нерабочего кода от рабочего комментированием позволит вам запустить программу. Когда код будет рабочий, то вы сможете его легко раскомментировать и продолжить работу.

  * Причина №2: Вы написали код, который компилируется, но работает не так, как нужно и сейчас у вас нет времени с этим возиться. Закомментируйте код, а затем, когда будет время, исправьте ошибки.

  * Причина №3: Поиск корня ошибки. Если вас не устраивают результаты работы программы (или вообще происходит сбой), полезно будет поочерёдно «отключать» части вашего кода, чтобы понять какие из них рабочие, а какие — создают проблемы. Если вы закомментируете одну или несколько строчек кода и программа начнет корректно работать (или пропадут сбои), шансы того, что последнее, что вы закомментировали, является ошибкой — очень велики. После этого вы сможете разобраться с тем, почему же этот код не работает так, как нужно.

  * Причина №4: Тестирование нового кода. Вместо удаления старого кода, вы можете его закомментировать и оставить для справки, пока не будете уверены в том, что ваш новый код работает так, как нужно. Как только вы будете уверены в новом коде, то сможете без проблем удалить старые фрагменты кода. Если же новый код у вас будет работать не так, как нужно, то вы сможете его удалить и откатиться к старому коду.

> ***Примечание***: Во всех следующих уроках я буду использовать комментарии в иллюстративных целях. Внимательные читатели смогут заметить, что по вышеуказанным стандартам большинство из этих комментариев будут плохими. Но помните, что использовать я их буду в образовательных целях, а не для демонстрации хороших примеров.

___
# Урок №10. Переменные, Инициализация и Присваивание

Программируя на языке C++, мы создаем, обрабатываем и уничтожаем объекты. Объект — это часть памяти, которая может хранить значение. В качестве аналогии мы можем использовать почтовый ящик, куда мы помещаем информацию и откуда её извлекаем. Все компьютеры имеют оперативную память, которую используют программы. При создании объекта, часть оперативной памяти выделяется для этого объекта. Большинство объектов, с которыми мы будем работать в языке C++, являются переменными.

> ## Оглавление:
> * [Переменные]()
> * [l-values и r-values]()
> * [Инициализация vs. Присваивание]()
> * [Неинициализированные переменные]()
> * [Тест]()
> * [Ответы]()

## Переменные
Cтейтмент `a = 8;` выглядит довольно простым: мы присваиваем значение `8` переменной `a`. Но что такое `a`? `a` — *это переменная*, ***объект с именем***.

На этом уроке мы рассмотрим только целочисленные переменные. **Целое число** — это число, которое можно записать без дроби, например: `-11`, `-2`, `0`, `5` или `34`.

Для создания переменной используется стейтмент объявления (разницу между объявлением и определением переменной мы рассмотрим несколько позже). Вот пример объявления целочисленной переменной `a` (которая может содержать только целые числа):

``` cpp
int a;
```

При выполнении этой инструкции центральным процессором часть оперативной памяти выделяется под этот объект. Например, предположим, что переменной a присваивается ячейка памяти под номером 150. Когда программа видит переменную a в выражении или в стейтменте, то она понимает, что для того, чтобы получить значение этой переменной, нужно заглянуть в ячейку памяти под номером 150.

Одной из наиболее распространенных операций с переменными является операция присваивания, например:

``` cpp
a = 8;
```

Когда процессор выполняет эту инструкцию, он понимает её как «поместить значение `8` в ячейку памяти под номером `150`».

Затем мы сможем вывести это значение на экран с помощью `std::cout`:

``` cpp
std::cout << a; // выводим значение переменной a (ячейка памяти под номером 150) на экран
```

## l-values и r-values

В языке C++ все переменные являются `l-values`. `l-value` (в переводе «л-значение», произносится как «ел-валью») — это значение, которое имеет свой собственный адрес в памяти. Поскольку все переменные имеют адреса, то они все являются `l-values` (например, переменные `a`, `b`, `c` — все они являются `l-values`). `l` от слова «left», так как только значения `l-values` могут находиться в левой стороне в операциях присваивания (в противном случае, мы получим ошибку). Например, стейтмент `9 = 10;` вызовет ошибку компилятора, так как 9 не является `l-value`. Число `9` не имеет своего адреса в памяти и, таким образом, мы ничего не можем ему присвоить (`9 = 9` и ничего здесь не изменить).

Противоположностью `l-value` является `r-value` (в переводе «р-значение», произносится как «ер-валью»). `r-value` — это значение, которое не имеет постоянного адреса в памяти. Примерами могут быть единичные числа (например, `7`, которое имеет значение `7`) или выражения (например, `3 + х`, которое имеет значение `х` плюс `3`).
``` cpp
Вот несколько примеров операций присваивания с использованием `r-values`:

int a;      // объявляем целочисленную переменную a
a = 5;      // 5 имеет значение 5, которое затем присваивается переменной а
a = 4 + 6;  // 4 + 6 имеет значение 10, которое затем присваивается переменной а
 
int b;      // объявляем целочисленную переменную b
b = a;      // a имеет значение 10 (исходя из предыдущих операций), которое затем присваивается переменной b
b = b;      // b имеет значение 10, которое затем присваивается переменной b (ничего не происходит)
b = b + 2;  // b + 2 имеет значение 12, которое затем присваивается переменной b
```

Давайте детально рассмотрим последнюю операцию присваивания:

``` cpp
b = b + 2;
```

Здесь переменная `b` используется в двух различных контекстах. Слева `b` используется как `l-value` (переменная с адресом в памяти), а справа `b` используется как `r-value` и имеет отдельное значение (в данном случае, `12`). При выполнении этого стейтмента, компилятор видит следующее:
``` cpp
b = 10 + 2;
```

И здесь уже понятно, какое значение присваивается переменной b.

Сильно беспокоиться о l-values или r-values сейчас не нужно, так как мы еще вернемся к этой теме на следующих уроках. Всё, что вам нужно сейчас запомнить — это то, что в левой стороне операции присваивания всегда должно находиться l-value (которое имеет свой собственный адрес в памяти), а в правой стороне операции присваивания — r-value (которое имеет какое-то значение).

## Инициализация vs. Присваивание

В языке C++ есть две похожие концепции, которые новички часто путают: присваивание и инициализация.

После объявления переменной, ей можно **присвоить** значение с помощью оператора присваивания (знак равенства `=`):

```
int a; // это объявление переменной
a = 8; // а это присваивание переменной a значения 8
```

В языке C++ вы можете **объявить переменную** и **присвоить** ей значение одновременно. Это называется **инициализацией** (или «определением»).

``` cpp
int a = 8; // инициализируем переменную a значением 8
```

Переменная может быть инициализирована только после операции объявления.

Хотя эти два понятия близки по своей сути и часто могут использоваться для достижения одних и тех же целей, все же в некоторых случаях следует использовать инициализацию, вместо присваивания, а в некоторых — присваивание вместо инициализации.

***Правило: Если у вас изначально имеется значение для переменной, то используйте инициализацию, вместо присваивания.***

## Неинициализированные переменные

В отличие от других языков программирования, языки Cи и C++ не инициализируют переменные определенными значениями (например, нулем) по умолчанию. Поэтому, при создании переменной, ей присваивается ячейка в памяти, в которой уже может находиться какой-нибудь мусор! Переменная без значения (со стороны программиста или пользователя) называется неинициализированной переменной.

Использование неинициализированных переменных может привести к ошибкам, например:

``` cpp
#include <iostream>
 
int main()
{
    // Объявляем целочисленную переменную a
    int a;
 
    // Выводим значение переменной a на экран (a - это неинициализированная переменная)
    std::cout << a;
 
    return 0;
}
```

В этом случае компилятор присваивает переменной `a` ячейку в памяти, которая в данный момент свободна (не используется). Затем значение переменной `a` отправляется на вывод. Но что мы увидим на экране? Ничего, так как компилятор это не пропустит — выведется ошибка, что переменная a является неинициализированной. В более старых версиях Visual Studio компилятор вообще мог бы вывести какое-то некорректное значение (например, `7177728`, *т.е. мусор*), которое было бы содержимым той ячейки памяти, которую он присвоил нашей переменной.

Использование неинициализированных переменных является одной из самых распространенных ошибок начинающих программистов, но, к счастью, большинство современных компиляторов выдадут ошибку во время компиляции, если обнаружат неинициализированную переменную.

Хорошей практикой считается всегда инициализировать свои переменные. Это будет гарантией того, что ваша переменная всегда имеет определенное значение и вы не получите ошибку от компилятора.

***Правило: Убедитесь, что все ваши переменные в программе имеют значения (либо через инициализацию, либо через операцию присваивания).***

## Тест

Какой результат выполнения следующих стейтментов?

``` cpp
int a = 6;
a = a - 3;
std::cout << a << std::endl; // №1
 
int b = a;
std::cout << b << std::endl; // №2
 
// В этом случае a + b является r-value 
std::cout << a + b << std::endl; // №3
 
std::cout << a << std::endl; // №4
 
int c;
std::cout << c << std::endl; // №5
```

## Ответы

**Ответ №1**

Программа выведет `3`: `a – 3 = 3`, что и присваивается переменной `a`.

**Ответ №2**

Программа выведет `3`: переменной `b` присваивается значение переменной `a` (`3`).

**Ответ №3**

Программа выведет `6`: `a + b = 6`. Здесь не используется операция присваивания.

**Ответ №4**

Программа выведет `3`: значением переменной `a` до сих пор является `3`.

**Ответ №5**

Результатом будет ошибка, так как `c` — это неинициализированная переменная.


___
# Урок №11. cout, cin и endl

На этом уроке мы рассмотрим такие объекты, как cout, endl и cin, существующие в языке C++.

> ## Оглавление:
> * [Объект std::cout]()
> * [Объект std::endl]()
> * [Объект std::cin]()
> * [std::cin, std::cout, << и >>]()

## Объект std::cout

Как мы уже говорили на предыдущих уроках, объект `std::cout` (который находится в библиотеке `iostream`) используется для вывода данных на экран (в консольное окно). В качестве напоминания, вот наша программа `«Hello, world!»`:

``` cpp
#include <iostream>
 
int main()
{
    std::cout << "Hello, world!";
    return 0;
}
```

Для вывода нескольких предложений на одной строке оператор вывода `<<` нужно использовать несколько раз, например:

``` cpp
#include <iostream>
 
int main()
{
   int a = 7;
   std::cout << "a is " << a;
   return 0;
}
```
Программа выведет:

`a is 7`

А какой результат выполнения следующей программы?

``` cpp
#include <iostream>
 
int main()
{
   std::cout << "Hi!";
   std::cout << "My name is Anton.";
   return 0;
}
```

Возможно, вы удивитесь, но:

`Hi!My name is Anton.`

## Объект std::endl

Если текст нужно вывести раздельно (на нескольких строках) — используйте `std::endl`. При использовании с `std::cout`, `std::endl` вставляет символ новой строки. Таким образом, мы перемещаемся к началу следующей строки, например:

``` cpp
#include <iostream>
 
int main()
{
   std::cout << "Hi!" << std::endl;
   std::cout << "My name is Anton." << std::endl;
   return 0;
}
```

Результат:

```
Hi!
My name is Anton.
```

## Объект std::cin
`std::cin` является противоположностью `std::cout`. В то время как `std::cout` выводит данные в консоль с помощью оператора вывода `<<`, `std::cin` получает данные от пользователя с помощью оператора ввода `>>`. Используя `std::cin` мы можем получать и обрабатывать пользовательский ввод:

``` cpp
#include <iostream>
 
int main()
{
   std::cout << "Enter a number: "; // просим пользователя ввести любое число
   int a = 0;
   std::cin >> a; // получаем пользовательское число и сохраняем его в переменную a
   std::cout << "You entered " << a << std::endl;
   return 0;
}
```

Попробуйте скомпилировать и запустить эту программу. При запуске вы увидите `Enter a number:`, а затем программа будет ждать, пока вы укажите число. Как только вы это сделаете и нажмете Enter, программа выведет `You entered, а` затем ваше число.

Например (я ввел `7`):

```
Enter a number: 7
You entered 7
```

Это самый простой способ получения данных от пользователя. Мы будем его использовать в дальнейших примерах.

Если ваше окно закрывается сразу после ввода числа — смотрите [Урок №7]() (там есть решение данной проблемы).

Если же ввести действительно большое число, то вы получите переполнение, так как переменная а может содержать числа только определенного размера/диапазона. Если число больше/меньше допустимых максимумов/минимумов, то происходит переполнение. Об этом мы детально поговорим на следующих уроках.

## `std::cin`, `std::cout`, `<<` и `>>`

Новички часто путают `std::cin` с `std::cout` и `<<` с `>>`. Вот простые способы запомнить их различия:

  * `std::cin` и `std::cout` всегда находятся в левой стороне стейтмента;

  * `std::cout` используется для вывода значения (`cOUT` = вывод);

  * `std::cin` используется для получения значения (`cIN` = ввод);

  *  оператор вывода `<<` используется с `std::cout` и показывает направление, в котором данные движутся от `r-value` в консоль. `std::cou` << 7;` (значение `7` перемещается в консоль);

  * оператор ввода `>>` используется с `std::cin` и показывает направление, в котором данные движутся из консоли в переменную. `std::cin >> a;` (значение из консоли перемещается в переменную `a`).

___
# Урок №12. Функции и оператор возврата return

Вы уже знаете, что каждая программа должна содержать функцию main() (с которой она и начинает свое выполнение). Тем не менее, большинство программ используют и много других функций.

> ## Оглавление:
> * [Функции]()
> * [Возвращаемые значения]()
> * [Тип возврата void]()
> * [Возврат значений обратно в функцию main()]()
> * [Еще о возвращаемых значениях]()
> * [Повторное использование функций]()
> * [Вложенные функции]()
> * [Тест]()
> * [Ответы]()

## Функции
> Функция — это последовательность стейтментов для выполнения определенного задания. Часто ваши программы будут прерывать выполнение одних функций ради выполнения других. Вы делаете аналогичные вещи в реальной жизни постоянно. Например, вы читаете книгу и вспомнили, что должны были сделать телефонный звонок. Вы оставляете закладку в своей книге, берете телефон и набираете номер. После того, как вы уже поговорили, вы возвращаетесь к чтению: к той странице, на которой остановились.

Программы на языке C++ работают похожим образом. Иногда, когда программа выполняет код, она может столкнуться с вызовом функции. Вызов функции — это выражение, которое указывает процессору прервать выполнение текущей функции и приступить к выполнению другой функции. Процессор «оставляет закладку» в текущей точке выполнения, а затем выполняет вызываемую функцию. Когда выполнение вызываемой функции завершено, процессор возвращается к закладке и возобновляет выполнение прерванной функции.

Функция, в которой находится вызов, называется `caller`, а функция, которую вызывают — вызываемая функция, например:

``` cpp
#include <iostream> // для std::cout и std::endl
 
// Объявление функции doPrint(), которую мы будем вызывать
void doPrint() {
   std::cout << "In doPrint()" << std::endl;
}
 
// Объявление функции main()
int main()
{
   std::cout << "Starting main()" << std::endl;
   doPrint(); // прерываем выполнение функции main() вызовом функции doPrint(). Функция main() в данном случае является caller-ом
   std::cout << "Ending main()" << std::endl;
   return 0;
}
```

Результат выполнения программы:

```
Starting main()
In doPrint()
Ending main()
```

Эта программа начинает выполнение с первой строки функции `main()`, где выводится на экран следующая строка: `Starting main()`. Вторая строка функции `main()` вызывает функцию `doPrint()`. На этом этапе выполнение стейтментов в функции `main()` приостанавливается и процессор переходит к выполнению стейтментов внутри функции `doPrint()`. Первая (и единственная) строка в `doPrint()` выводит текст `In doPrint()`. Когда процессор завершает выполнение `doPrint()`, он возвращается обратно в `main()` к той точке, на которой остановился. Следовательно, следующим стейтментом является вывод строки `Ending main()`.

Обратите внимание, для вызова функции нужно указать её имя и список параметров в круглых скобках `()`. В примере, приведенном выше, параметры не используются, поэтому круглые скобки пусты. Мы детально поговорим о параметрах функций на следующем уроке.

Правило: Не забывайте указывать круглые скобки `()` при вызове функций.

## Возвращаемые значения

Когда функция `main()` завершает свое выполнение, она возвращает целочисленное значение обратно в операционную систему, используя оператор `return`.

Функции, которые мы пишем, также могут возвращать значения. Для этого нужно указать тип возвращаемого значения (или «тип возврата»). Он указывается при объявлении функции, перед её именем. Обратите внимание, тип возврата не указывает, какое именно значение будет возвращаться. Он указывает только тип этого значения.

Затем, внутри вызываемой функции, мы используем оператор `return`, чтобы указать возвращаемое значение — какое именно значение будет возвращаться обратно в `caller`.

Рассмотрим простую функцию, которая возвращает целочисленное значение:

``` cpp
#include <iostream>
 
// int означает, что функция возвращает целочисленное значение обратно в caller
int return7()
{
    // Эта функция возвращает целочисленное значение, поэтому мы должны использовать оператор return
    return 7; // возвращаем число 7 обратно в caller
}
 
int main()
{
    std::cout << return7() << std::endl; // выведется 7
    std::cout << return7() + 3 << std::endl; // выведется 10
 
    return7(); // возвращаемое значение 7 игнорируется, так как функция main() ничего с ним не делает
 
    return 0;
}
```
Результат выполнения программы:
```
7
10
```
Разберемся детально:

  * Первый вызов функции `return7()` возвращает `7` обратно в `caller`, которое затем передается в `std::cout` для вывода.

  * Второй вызов функции `return7()` опять возвращает `7` обратно в `caller`. Выражение `7 + 3` имеет результат `10`, который затем выводится на экран.

  * Третий вызов функции `return7()` опять возвращает `7` обратно в `caller`. Однако функция `main()` ничего с ним не делает, поэтому ничего и не происходит (возвращаемое значение игнорируется).

***Примечание: Возвращаемые значения не выводятся на экран, если их не передать объекту `std::cout`. В последнем вызове функции `return7()` значение не отправляется в `std::cout`, поэтому ничего и не происходит.***

## Тип возврата void

> Функции могут и не возвращать значения. Чтобы сообщить компилятору, что функция не возвращает значение, нужно использовать тип возврата `void`. 

Взглянем еще раз на функцию `doPrint()` из вышеприведенного примера:

``` cpp
void doPrint() // void - это тип возврата
{
    std::cout << "In doPrint()" << std::endl;
    // Эта функция не возвращает никакого значения, поэтому оператор return здесь не нужен
}
```

Эта функция имеет тип возврата `void`, который означает, что функция не возвращает значения. Поскольку значение не возвращается, то и оператор `return` не требуется.

Вот еще один пример использования функции типа `void`:

``` cpp
#include <iostream>
 
// void означает, что функция не возвращает значения
void returnNothing()
{
    std::cout << "Hi!" << std::endl;
    // Эта функция не возвращает никакого значения, поэтому оператор return здесь не нужен
}
 
int main()
{
    returnNothing(); // функция returnNothing() вызывается, но обратно в main() ничего не возвращает
 
    std::cout << returnNothing(); // ошибка, эта строчка не скомпилируется. Вам нужно будет её закомментировать
    return 0;
}
```
В первом вызове функции `returnNothing()` выводится `Hi!`, но ничего не возвращается обратно в `caller`. Точка выполнения возвращается обратно в функцию `main()`, где программа продолжает свое выполнение.

Второй вызов функции `returnNothing()` даже не скомпилируется. Функция `returnNothing()` имеет тип возврата `void`, который означает, что эта функция не возвращает значения. Однако функция `main()` пытается отправить это значение (которое не возвращается) в `std::cout` для вывода. `std::cout` не может обработать этот случай, так как значения на вывод не предоставлено. Следовательно, компилятор выдаст ошибку. Вам нужно будет закомментировать эту строку, чтобы компиляция прошла успешно.

## Возврат значений обратно в функцию main()

Теперь у вас есть понимание того, как работает функция `main()`. Когда программа выполняется, операционная система делает вызов функции `main()` и начинается её выполнение. Стейтменты в `main()` выполняются последовательно. В конце функция `main()` возвращает целочисленное значение (обычно `0`) обратно в операционную систему. Поэтому `main()` объявляется как `int main()`.

Почему нужно возвращать значения обратно в операционную систему? Дело в том, что возвращаемое значение функции `main()` является кодом состояния, который сообщает операционной системе об успешном или неудачном выполнении программы. Обычно, возвращаемое значение `0` (ноль) означает что всё прошло успешно, тогда как любое другое значение означает неудачу/ошибку.

Обратите внимание, по стандартам языка C++ функция `main()` должна возвращать целочисленное значение. Однако, если вы не укажете `return` в конце функции `main()`, компилятор возвратит `0` автоматически, если никаких ошибок не будет. Но рекомендуется указывать `return` в конце функции `main()` и использовать тип возврата `int` для функции `main()`.

## Еще о возвращаемых значениях
Во-первых, если тип возврата функции не `void`, то она должна возвращать значение указанного типа (использовать оператор `return`). Единственно исключение — функция `main()`, которая возвращает `0`, если не предоставлено другое значение.

Во-вторых, когда процессор встречает в функции оператор `return`, он немедленно выполняет возврат значения обратно в `caller` и точка выполнения также переходит в `caller`. Любой код, который находится за `return`-ом в функции — игнорируется.

Функция может возвращать только одно значение через `return` обратно в `caller`. Это может быть либо число (например, `7`), либо значение переменной, либо выражение (у которого есть результат), либо определенное значение из набора возможных значений.

Но есть способы обойти правило возврата одного значения, возвращая сразу несколько значений, но об этом детально мы поговорим на соответствующем уроке.

Наконец, автор функции решает, что означает её возвращаемое значение. Некоторые функции используют возвращаемые значения в качестве кодов состояния для указания результата выполнения функции (успешно ли выполнение или нет). Другие функции возвращают определенное значение из набора возможных значений. Кроме того, существуют функции, которые вообще ничего не возвращают.

## Повторное использование функций

Одну и ту же функцию можно вызывать несколько раз, даже в разных программах, что очень полезно:
``` cpp
#include <iostream>
 
// Функция getValueFromUser() получает значение от пользователя, а затем возвращает его обратно в caller
int getValueFromUser()
{
   std::cout << "Enter an integer: ";
   int x;
   std::cin >> x;
   return x;
}
 
int main()
{
   int a = getValueFromUser(); // первый вызов функции getValueFromUser()
   int b = getValueFromUser(); // второй вызов функции getValueFromUser()
 
   std::cout << a << " + " << b << " = " << a + b << std::endl;
 
   return 0;
}
```

Результат выполнения программы:
```
Enter an integer: 4
Enter an integer: 9
4 + 9 = 13
```
Здесь `main()` прерывается `2` раза. Обратите внимание, в обоих случаях, полученное пользовательское значение сохраняется в переменной `x`, а затем передается обратно в `main()` с помощью `return`, где присваивается переменной `a` или `b`!

Также `main()` не является единственной функцией, которая может вызывать другие функции. Любая функция может вызывать любую другую функцию!

``` cpp
#include <iostream>
 
void printO()
{
   std::cout << "O" << std::endl;
}
 
void printK()
{
   std::cout << "K" << std::endl;
}
 
// Функция printOK() вызывает как printO(), так и printK()
void printOK()
{
   printO();
   printK();
}
 
// Объявление main()
int main()
{
   std::cout << "Starting main()" << std::endl;
   printOK();
   std::cout << "Ending main()" << std::endl;
   return 0;
}
```

Результат выполнения программы:
```
Starting main()
O
K
Ending main()
```
## Вложенные функции
В языке С++ одни функции не могут быть объявлены внутри других функций (т.е. быть вложенными). Следующий код вызовет ошибку компиляции:

``` cpp
#include <iostream>
 
int main()
{
   int boo() // эта функция находится внутри функции main(), что запрещено
   {
      std::cout << "boo!";
      return 0;
   }
 
   boo();
   return 0;
}
```
Правильно вот так:
``` cpp
#include <iostream>
 
int boo() // теперь уже не в main()
{
   std::cout << "boo!";
   return 0;
}
 
int main()
{
   boo();
   return 0;
}
```

## Тест

Какие из следующих программ не скомпилируются (и почему), а какие скомпилируются (и какой у них результат)?

*Программа №1:*
``` cpp
#include <iostream>
 
int return5()
{
    return 5;
}
 
int return8()
{
    return 8;
}
 
int main()
{
    std::cout << return5() + return8() << std::endl;
 
    return 0;
}
```

*Программа №2:*

``` cpp
#include <iostream>

int return5()
{
    return 5;
 
    int return8()
    {
        return 8;
    }
}
 
int main()
{
    std::cout << return5() + return8() << std::endl;
 
    return 0;
}
```
*Программа №3:*

``` cpp
#include <iostream>

int return5()
{
    return 5;
}
 
int return8()
{
    return 8;
}
 
int main()
{
    return5();
    return8();
 
    return 0;
}
```
Программа №4:

``` cpp
#include <iostream>
 
void printO()
{
    std::cout << "O" << std::endl;
}
 
int main()
{
    std::cout << printO() << std::endl;
 
    return 0;
}
```
*Программа №5:*
``` cpp
#include <iostream>

int getNumbers()
{
    return 6;
    return 8;
}
 
int main()
{
    std::cout << getNumbers() << std::endl;
    std::cout << getNumbers() << std::endl;
 
    return 0;
}
```

*Программа №6:*
``` cpp
#include <iostream>

int return 6()
{
    return 6;
}
 
int main()
{
    std::cout << return 6() << std::endl;
 
    return 0;
}
```

*Программа №7:*
``` cpp
#include <iostream>

int return6()
{
    return 6;
}
 
int main()
{
    std::cout << return6 << std::endl;
 
    return 0;
}
```

## Ответы

**Ответ №1**

Скомпилируется, результатом выполнения программы будет значение 13.

**Ответ №2**

Эта программа не скомпилируется. Вложенные функции запрещены.

**Ответ №3**

Эта программа скомпилируется, но не будет никакого вывода. Возвращаемые значения из функций не используются в main() и, таким образом, игнорируются.

**Ответ №4**

Эта программа не скомпилируется, так как тип возврата функции printO() — void, а мы отправляем несуществующее возвращаемое значение на вывод. Результат — ошибка компиляции.

**Ответ №5**

Результатом выполнения этой программы будет:

6
6

Оба раза, когда вызывается функция getNumbers(), возвращается значение 6. Компилятор, встречая первый return, сразу же выполняет возврат этого значения, и всё, что находится за первым return-ом, — игнорируется. Строка return 8; никогда не выполнится.

**Ответ №6**

Эта программа не скомпилируется из-за недопустимого имени функции.

**Ответ №7**

Эта программа скомпилируется, но функция не будет вызвана, так как в её вызове отсутствуют круглые скобки. Результат вывода зависит от компилятора.

___
# Урок №13. Параметры и аргументы функций

На предыдущем уроке мы говорили о том, что функция может возвращать значение обратно в caller, используя оператор return. На этом уроке мы узнаем, что такое аргументы в функции и что такое параметры в функции.

> ## Оглавление:
> * [Параметры и аргументы функций]()
> * [Как работают параметры и аргументы функций?]()
> * [Как работают параметры и возвращаемые значения]()
> * [функций?]()
> * [Еще примеры]()
> * [Тест]()
> * [Ответы]()

## Параметры и аргументы функций
Во многих случаях нам нужно будет передавать данные в вызываемую функцию, чтобы она могла с ними как-то взаимодействовать. Например, если мы хотим написать функцию умножения двух чисел, то нам нужно каким-то образом сообщить функции, какие это будут числа. В противном случае, как она узнает, что на что перемножать? Здесь нам на помощь приходят параметры и аргументы.

> **Параметр функции** — это переменная, которая используется в функции, и значение которой предоставляет `caller` (вызывающий объект). Параметры указываются при объявлении функции в круглых скобках. Если их много, то они перечисляются через запятую, например:

``` cpp 
// Эта функция не имеет параметров
void doPrint()
{
   std::cout << "In doPrint()" << std::endl;
}
 
// Эта функция имеет один параметр типа int: a
void printValue(int a)
{
   std::cout << a << std::endl;
}
 
// Эта функция имеет два параметра типа int: a и b
int add(int a, int b)
{
   return a + b;
}
```

Параметры каждой функции действительны только внутри этой функции. Поэтому, если `printValue()` и `add()` имеют параметр с именем `a`, то это не означает, что произойдет конфликт имен. Эти параметры считаются независимыми и никак не взаимодействуют друг с другом.

> **Аргумент функции** — это значение, которое передается из `caller`-а в функцию и которое указывается в скобках при вызове функции в `caller`-е:

``` cpp
printValue(7); // 7 – это аргумент функции printValue()
add(4, 5); // 4 и 5 – это аргументы функции add()
```

Обратите внимание, аргументы тоже перечисляются через запятую. Количество аргументов должно совпадать с количеством параметров, иначе компилятор выдаст сообщение об ошибке.

## Как работают параметры и аргументы функций?

При вызове функции, все её параметры создаются как локальные переменные, а значение каждого из аргументов копируется в соответствующий параметр (локальную переменную). Этот процесс называется передачей по значению. Например:

``` cpp
#include <iostream>
 
// Эта функция имеет два параметра типа int: a и b
// Значения переменных a и b определяет caller
void printValues(int a, int b)
{
   std::cout << a << std::endl;
   std::cout << b << std::endl;
}
 
int main()
{
   printValues(8, 9); // здесь два аргумента: 8 и 9
 
   return 0;
}
```

При вызове функции `printValues()` аргументы `8` и `9` копируются в параметры `a` и `b`. Параметру `a` присваивается значение `8`, а параметру `b` — значение `9`.

Результат:
```
8
9
```
Как работают параметры и возвращаемые значения функций?
Используя параметры и возвращаемые значения, мы можем создавать функции, которые будут принимать и обрабатывать данные, а затем возвращать результат обратно в `caller`.

Например, простая функция, которая принимает два целых числа и возвращает их сумму:

``` cpp
#include <iostream>
 
// Функция add() принимает два целых числа в качестве параметров и возвращает их сумму
// Значения a и b определяет caller
int add(int a, int b)
{
   return a + b;
}
 
// Функция main() не имеет параметров
int main()
{
   std::cout << add(7, 8) << std::endl; // аргументы 7 и 8 передаются в функцию add()
   return 0;
}
```

При вызове функции `add()`, параметру a присваивается значение `7`, а параметру `b` — значение `8`. Затем функция `add()` вычисляет их сумму и возвращает результат обратно в `main()`. И тогда уже результат выводится на экран.

Результат выполнения программы:

`15`

## Еще примеры

Рассмотрим еще несколько вызовов функций:

``` cpp
#include <iostream>
 
int add(int a, int b)
{
   return a + b;
}
 
int multiply(int c, int d)
{
   return c * d;
}
 
int main()
{
   std::cout << add(7, 8) << std::endl; // внутри функции add(): a = 7, b = 8, значит a + b = 15
   std::cout << multiply(4, 5) << std::endl; // внутри функции multiply(): c = 4, d = 5, значит c * d = 20
 
   // Мы можем передавать целые выражения в качестве аргументов
   std::cout << add(2 + 3, 4 * 5) << std::endl; // внутри функции add(): a = 5, b = 20, значит a + b = 25
 
   // Мы можем передавать переменные в качестве аргументов
   int x = 4;
   std::cout << add(x, x) << std::endl; // будет 4 + 4
 
   std::cout << add(1, multiply(2, 3)) << std::endl; // будет 1 + (2 * 3)
   std::cout << add(1, add(2, 3)) << std::endl; // будет 1 + (2 + 3)
 
   return 0;
}
```

Результат выполнения программы:
```
15
20
25
8
7
6
```
С первыми двумя вызовами всё понятно.

В третьем вызове параметрами являются выражения, которые сначала нужно обработать. `2 + 3 = 5` и результат `5` присваивается переменной `a`. `4 * 5 = 20` и результат `20` присваивается переменной `b`. Результатом выполнения функции `add(5, 20)` является значение `25`.

Следующая пара относительно лёгкая для понимания:

``` cpp
int x = 4;
std::cout << add(x, x) << std::endl; // будет 4 + 4
```

Здесь уже `a = x` и `b = x`. Поскольку `x = 4`, то `add(x, x)` = `add(4, 4)`. Результат — `8`.

Теперь рассмотрим вызов посложнее:

``` cpp
std::cout << add(1, multiply(2, 3)) << std::endl; // будет 1 + (2 * 3)
```

При выполнении этого стейтмента процессор должен определить значения параметров `a` и `b` функции `add()`. С параметром a всё понятно — мы передаем значение `1` (`a = 1`). А вот чтобы определить значение параметра `b`, нам необходимо выполнить операцию умножения: `multiply(2, 3)`, результат — `6`. Затем `add(1, 6)` возвращает число `7`, которое и выводится на экран.

Короче говоря:

```
add(1, multiply(2, 3)) => add(1, 6) => 7
```

Последний вызов может показаться немного сложным из-за того, что параметром функции `add()` является другой вызов `add()`:

``` cpp
std::cout << add(1, add(2, 3)) << std::endl; // будет 1 + (2 + 3)
```

Но здесь всё аналогично вышеприведенному примеру. Перед тем, как процессор вычислит внешний вызов функции `add()`, он должен обработать внутренний вызов функции `add(2, 3)`. `add(2, 3) = 5`. Затем процессор обрабатывает функцию `add(1, 5)`, результатом которой является значение `6`. Затем `6` передается в `std::cout`.

Короче говоря:
```
add(1, add(2, 3)) => add(1, 5) => 6
```
## Тест

*Задание №1*: Что не так со следующим фрагментом кода?
``` cpp
#include <iostream>
 
void multiply(int a, int b)
{
   return a * b;
}
 
int main()
{
   std::cout << multiply(7, 8) << std::endl;
   return 0;
}
```

*Задание №2*: Какие здесь есть две проблемы?
``` cpp
#include <iostream>

int multiply(int a, int b)
{
   int product = a * b;
}

int main()
{
   std::cout << multiply(5) << std::endl;
   return 0;
}
```

*Задание №3*: Какой результат выполнения следующей программы?

``` cpp
#include <iostream>
 
int add(int a, int b, int c)
{
   return a + b + c;
}
 
int multiply(int a, int b)
{
   return a * b;
}
 
int main()
{
   std::cout << multiply(add(3, 4, 5), 5) << std::endl;
   return 0;
}
```

*Задание №4*: Напишите функцию `doubleNumber()`, которая принимает целое число в качестве параметра, удваивает его, а затем возвращает результат обратно в `caller`.

*Задание №5*: Напишите полноценную программу, которая принимает целое число от пользователя (используйте `std::cin`), удваивает его с помощью функции `doubleNumber()` из предыдущего задания, а затем выводит результат на экран.

## Ответы


**Ответ №1**

Функция `multiply()` имеет тип возврата `void`, что означает, что эта функция не возвращает значения. Но, так как она все равно пытается возвратить значение с помощью оператора `return`, мы получим ошибку от компилятора. Функция должна иметь тип возврата `int`.

**Ответ №2**

*Проблема №1*: `main()` передает один аргумент в `multiply()`, но `multiply()` имеет два параметра.

*Проблема №2*: `multiply()` вычисляет результат и присваивает его локальной переменной, которую не возвращает обратно в `main()`. А поскольку тип возврата функции `multiply()` — `int`, то мы получим ошибку (в некоторых компиляторах) или неожиданные результаты (в остальных компиляторах).

**Ответ №3**

Функция `multiply()` принимает следующие параметры: `a = add(3, 4, 5)` и `b = 5`. Сначала процессор обрабатывает `a = add(3, 4, 5)`, т.е. `3 + 4 + 5 = 12`. Затем уже выполняет операцию умножения, результатом которой является `60`. ***Ответ***: `60`.

**Ответ №4**

``` cpp
int doubleNumber(int a)
{
   return 2 * a;
}
```

**Ответ №5**
``` cpp
#include <iostream>

int doubleNumber(int a)
{
   return 2 * a;
}

int main()
{
   int a;
   std::cout<<"Enter a number: ";
   std::cin >> a;
   std::cout << doubleNumber(a) << std::endl;
   return 0;
}

/*
// Следующее решение является альтернативным:
int main()
{
   int a;
   std::cout<<"Enter a number: ";
   std::cin >> a;
   a = doubleNumber(a);
   std::cout << a << std::endl;
   return 0;
}
*/
```

> ***Примечание***: У вас могут быть и другие решения заданий *№4* и *№5* — это ок. В программировании есть много случаев, когда одну задачу можно решить несколькими способами.

___
# Урок №14. Почему функции — полезны, и как их эффективно использовать?

Теперь, когда мы уже знаем, что такое функции и зачем они нужны, давайте более подробно рассмотрим, почему они так полезны.

## Зачем использовать функции?
Начинающие программисты часто спрашивают: «А можно ли обходиться без функций и весь код помещать непосредственно в функцию `main()`?». Если вашего кода всего 10-20 строк, то можно. Если же серьезно, то функции предназначены для упрощения кода, а не для его усложнения. Они имеют ряд преимуществ, которые делают их чрезвычайно полезными в нетривиальных программах.

  * Структура. Как только программы увеличиваются в размере/сложности, сохранять весь код внутри main() становится трудно. Функция — это как мини-программа, которую мы можем записать отдельно от головной программы, не заморачиваясь при этом об остальных частях кода. Это позволяет разбивать сложные задачи на более мелкие и простые, что кардинально снижает общую сложность программы.

  * Повторное использование. После объявления функции, её можно вызывать много раз. Это позволяет избежать дублирования кода и сводит к минимуму вероятность возникновения ошибок при копировании/вставке кода. Функции также могут использоваться и в других программах, уменьшая объем кода, который нужно писать с нуля каждый раз.

  * Тестирование. Поскольку функции убирают лишний код, то и тестировать его становится проще. А так как функция — это самостоятельная единица, то нам достаточно протестировать её один раз, чтобы убедиться в её работоспособности, а затем мы можем её повторно использовать много раз без необходимости проводить тестирование (до тех пор, пока не внесем изменения в эту функцию).

  * Модернизация. Когда нужно внести изменения в программу или расширить её функционал, то функции являются отличным вариантом. С их помощью можно внести изменения в одном месте, чтобы они работали везде.

  * Абстракция. Для того, чтобы использовать функцию, нам нужно знать её имя, данные ввода, данные вывода и где эта функция находится. Нам не нужно знать, как она работает. Это очень полезно для написания кода, понятного другим (например, Стандартная библиотека С++ и всё, что в ней находится, созданы по этому принципу).

Каждый раз, при вызове `std::cin` или `std::cout` для ввода или вывода данных, мы используем функцию из Стандартной библиотеки C++, которая соответствует всем вышеперечисленным концепциям.

## Эффективное использование функций

Одной из наиболее распространенных проблем, с которой сталкиваются новички, является понимание того, где, когда и как эффективно использовать функции. Вот несколько основных рекомендаций при написании функций:

  * ***Рекомендация №1***: Код, который появляется более одного раза в программе, лучше переписать в виде функции. Например, если мы получаем данные от пользователя несколько раз одним и тем же способом, то это отличный вариант для написания отдельной функции.

  * ***Рекомендация №2***: Код, который используется для сортировки чего-либо, лучше записать в виде отдельной функции. Например, если у нас есть список вещей, которые нужно отсортировать — пишем функцию сортировки, куда передаем несортированный список и откуда получаем отсортированный.

  * ***Рекомендация №3***: Функция должна выполнять одно (и только одно) задание.

  * ***Рекомендация №4***: Когда функция становится слишком большой, сложной или непонятной — её следует разбить на несколько подфункций. Это называется **рефакторингом кода**.

При изучении языка C++ вам предстоит написать много программ, которые будут включать следующие три подзадания:

  * Получение данных от пользователя.

  * Обработка данных.

  * Вывод результата.

Для простых программ (менее, чем 30 строк кода) частично или все эти три подзадания можно записать в функции `main()`. Для более сложных программ (или просто для практики) каждое из этих трех подзаданий является хорошим вариантом, чтобы написать отдельные функции.

Новички часто комбинируют обработку ввода и вывод результата в одной функции. Тем не менее, это нарушает правило «одного задания». Функция, которая обрабатывает значение, должна возвращать его в `caller`, а дальше уже пускай `caller` сам решает, что ему с ним делать.

___
# Урок №15. Локальная область видимости

Как мы уже знаем из предыдущих уроков, при выполнении процессором стейтмента `int х;` создается переменная. Возникает вопрос: «Когда эта переменная уничтожается?».

> Область видимости переменной определяет, кто может видеть и использовать переменную во время её существования. И параметры функции, и переменные, которые объявлены внутри функции, имеют локальную область видимости. Другими словами, эти параметры и переменные используются только внутри функции, в которой они объявлены. Локальные переменные создаются в точке объявления и уничтожаются, когда выходят из области видимости.

Рассмотрим следующую программу:

``` cpp
#include <iostream>
 
int add(int a, int b) // здесь создаются переменные a и b
{
   // a и b можно видеть/использовать только внутри этой функции
   return a + b;
} // здесь a и b выходят из области видимости и уничтожаются
 
int main()
{
   int x = 7; // здесь создается и инициализируется переменная x
   int y = 8; // здесь создается и инициализируется переменная y
   // x и y можно использовать только внутри функции main()
   std::cout << add(x, y) << std::endl; // вызов функции add() с a = x и b = y
   return 0;
} // здесь x и y выходят из области видимости и уничтожаются
```
Параметры `a` и `b` функции `add()` создаются при вызове этой функции, используются только внутри нее и уничтожаются по завершении выполнения этой функции.

Переменные `x` и `y` функции `main()` можно использовать только внутри `main()` и они также уничтожаются по завершении выполнения функции `main()`.

Для лучшего понимания давайте детально разберем ход выполнения этой программы:

  * выполнение начинается с функции `main()`;

  * создается переменная `x` в функции `main()` и ей присваивается значение `7`;

  * создается переменная `y` в функции `main()` и ей присваивается значение `8`;

  * вызывается функция `аdd()` с параметрами `7` и `8`;

  * создается переменная `a` в функции `add()` и ей присваивается значение `7`;

  * создается переменная `b` в функции `add()` и ей присваивается значение `8`;

  * выполняется операция сложения чисел `7` и `8`, результатом является значение `15`;

  * функция `add()` возвращает значение `15` обратно в `caller` (в функцию `main()`);

  * переменные `a` и `b` функции `add()` уничтожаются;

  * функция `main()` выводит значение `15` на экран;

  * функция `main()` возвращает `0` в операционную систему;

  * переменные `x` и `y` функции `main()` уничтожаются.

Всё!

Обратите внимание, если бы функция `add()` вызывалась дважды, параметры `a` и `b` создавались и уничтожались бы также дважды. В программе с большим количеством функций, переменные создаются и уничтожаются часто.

Локальная область видимости предотвращает возникновение конфликтов имен
Из примера, приведенного выше, понятно, что переменные `x` и `y` отличаются от переменных `a` и `b`.

Теперь давайте рассмотрим следующую программу:

``` cpp
#include <iostream>
 
int add(int a, int b) // здесь создаются переменные a и b функции add()
{
   return a + b;
} // здесь a и b функции add() выходят из области видимости и уничтожаются
 
int main()
{
   int a = 7; // здесь создается переменная a функции main()
   int b = 8; // здесь создается переменная b функции main()
   std::cout << add(a, b) << std::endl; // значения переменных a и b функции main() копируются в переменные a и b функции add()
   return 0;
} // здесь a и b функции main() выходят из области видимости и уничтожаются
```

Здесь мы изменили имена переменных `x` и `y` функции `main()` на a и `b`. Программа по-прежнему работает корректно, несмотря на то, что функция `add()` также имеет переменные `a` и `b`. Почему это не вызывает конфликта имен? Дело в том, что `a` и `b`, принадлежащие функции `main()`, являются локальными переменными, функция `add()` не может их видеть, точно так же, как функция `main()` не может видеть переменные `a` и `b`, принадлежащие функции `add()`. Ни `add()`, ни `main()` не знают, что они имеют переменные с одинаковыми именами!

Это значительно снижает возможность возникновения конфликта имен. Любая функция не должна знать или заботиться о том, какие переменные находятся в другой функции. Это также предотвращает возникновение ситуаций, когда одни функции могут непреднамеренно (или намеренно) изменять значения переменных других функций.

***Правило: Имена, которые используются внутри функции (включая параметры), доступны/видны только внутри этой же функции.***

## Тест

Каким будет результат выполнения следующей программы?

``` cpp
#include <iostream>
 
void doMath(int a)
{
    int b = 5;
    std::cout << "doMath: a = " << a << " and b = " << b << std::endl;
    a = 4;
    std::cout << "doMath: a = " << a << " and b = " << b << std::endl;
}
 
int main()
{
    int a = 6;
    int b = 7;
    std::cout << "main: a = " << a << " and b = " << b << std::endl;
    doMath(a);
    std::cout << "main: a = " << a << " and b = " << b << std::endl;
    return 0;
}
```

## Ответ

Результат выполнения программы:
```
main: a = 6 and b = 7
doMath: a = 6 and b = 5
doMath: a = 4 and b = 5
main: a = 6 and b = 7
```
Вот ход выполнения этой программы:

  * выполнение начинается с функции `main()`;

  * создается переменная `a` в функции `main()`, ей присваивается значение `6`;

  * создается переменная `b` в функции `main()`, ей присваивается значение `7`;

  * `cout` выводит `main: a = 6 and b = 7`;

  * вызывается `doMath()` с аргументом `6`;

  * создается переменная `a` в функции `doMath()`, ей присваивается значение `6`;

  * выполняется инициализация переменной `b` функции `doMath()` значением `5`;

  * `cout` выводит `doMath: a = 6 and b = 5`;

  * переменной `a` функции `doMath()` присваивается значение `4`;

  * `cout` выводит `doMath: a = 4 and b = 5`;

  * переменные `a` и `b` функции `doMath()` уничтожаются;

  * `cout` выводит `main: a = 6 and b = 7`;

  * функция `main()` возвращает `0` в операционную систему;

  * переменные `a` и `b` функции main() уничтожаются.

Обратите внимание, даже когда мы присвоили значения переменным `a` и `b` внутри функции `doMath()`, на переменные внутри функции `main()` это никак не повлияло.

___
# Урок №16. Ключевые слова и идентификаторы

Язык C++ имеет зарезервированный набор из 84 слов (включая версию С++17) для собственного использования. Эти слова называются ключевыми словами, каждое из которых имеет свое особое значение.

Вот список всех ключевых слов в языке C++ (включая C++17):

<table class="tabluc" style="font-size: 0.9em; margin-bottom: 15px;" width="100%"><tbody><tr valign="top"><td style="text-align: left; padding-left: 25px;">alignas (C++11)<br>alignof (C++11)<br>and<br>and_eq<br>asm<br>auto<br>bitand<br>bitor<br>bool<br>break<br>case<br>catch<br>char<br>char16_t (C++11)<br>char32_t (C++11)<br>class<br>compl<br>const<br>constexpr (C++11)<br>const_cast<br>continue</td><td style="text-align: left; padding-left: 25px;">decltype (C++11)<br>default<br>delete<br>do<br>double<br>dynamic_cast<br>else<br>enum<br>explicit<br>export<br>extern<br>false<br>float<br>for<br>friend<br>goto<br>if<br>inline<br>int<br>long<br>mutable</td><td style="text-align: left; padding-left: 25px;">namespace<br>new<br>noexcept (C++11)<br>not<br>not_eq<br>nullptr (C++11)<br>operator<br>or<br>or_eq<br>private<br>protected<br>public<br>register<br>reinterpret_cast<br>return<br>short<br>signed<br>sizeof<br>static<br>static_assert (C++11)<br>static_cast</td><td style="text-align: left; padding-left: 25px;">struct<br>switch<br>template<br>this<br>thread_local (C++11)<br>throw<br>true<br>try<br>typedef<br>typeid<br>typename<br>union<br>unsigned<br>using<br>virtual<br>void<br>volatile<br>wchar_t<br>while<br>xor<br>xor_eq</td></tr></tbody></table>

C++11 также добавил два специальных идентификатора: `override` и `final`. Они имеют особое значение при использовании в определенных контекстах, но не являются зарезервированными ключевыми словами.

Мы уже сталкивались с некоторыми ключевыми словами, такими как `int`, `void` и `return`. Вместе с набором операторов, ключевые слова определяют весь язык C++ (не включая команд препроцессора). Поскольку они имеют особые значения, то IDE всегда выделяют/подсвечивают их другим цветом.

После изучения материалов всех уроков по С++ на Ravesli, вы узнаете суть большинства ключевых слов языка С++, приведенных выше.

## Идентификаторы
> Идентификатор — это имя переменной, функции, класса или другого объекта в языке C++. Мы можем определять идентификаторы любыми словами/именами. Тем не менее, есть несколько общих правил, которые необходимо соблюдать:

  * Идентификатор не может быть ключевым словом. Ключевые слова зарезервированы.

  * Идентификатор может состоять только из букв (нижнего и верхнего регистра) латинского алфавита, цифр и символов подчёркивания. Это означает, что все другие символы и пробелы — запрещены.

  * Идентификатор должен начинаться с буквы (нижнего или верхнего регистра). Он не может начинаться с цифры.

  * Язык C++ различает нижний регистр от верхнего. `nvalue` отличается от `nValue` и отличается от `NVALUE`.

Теперь, когда вы знаете, как можно называть объекты, давайте поговорим о том, как их нужно называть.

Во-первых, в языке C++ имена переменных начинаются с буквы в нижнем регистре. Если имя переменной состоит из одного слова, то это слово должно быть записано в нижнем регистре:

``` cpp
int value; // корректно
 
int Value; // некорректно (должно начинаться с буквы в нижнем регистре)
int VALUE; // некорректно (должно начинаться с буквы в нижнем регистре)
int VaLuE; // некорректно (должно начинаться с буквы в нижнем регистре)
```

Как правило, имена функций также начинаются с буквы в нижнем регистре (хотя есть некоторые разногласия по этому вопросу). Мы будем придерживаться этого стиля, поскольку даже функция `main()` (главная функция всех программ) начинается с буквы в нижнем регистре, как и все функции из Стандартной библиотеки C++.

Имена идентификаторов, которые начинаются с заглавной буквы, используются для структур, классов или перечислений (об этом позже).

Если имя переменной или функции состоит из нескольких слов, то здесь есть два варианта: разделить подчёркиванием или использовать **CamelCase** — принцип, когда несколько слов пишутся слитно, без пробелов, и каждое новое слово пишется с заглавной буквы. CamelCase (в переводе как «ВерблюжийСтиль») получил свое название из-за заглавных букв, которые напоминают верблюжьи горбы.

``` cpp
int my_variable_name; // корректно (разделяется символом подчёркивания)
void my_function_name(); // корректно (разделяется символом подчёркивания)
 
int myVariableName; // корректно (используется CamelCase)
void myFunctionName(); // корректно (используется CamelCase)
 
int my variable name; // некорректно (пробелы запрещены)
void my function name(); // некорректно (пробелы запрещены) 
 
int MyVariableName; // работает, но не рекомендуется (следует начинать с буквы в нижнем регистре)
void MyFunctionName(); // работает, но не рекомендуется
```

Хотя даже Стандартная библиотека C++ использует символ подчёркивания для переменных и функций, мы же будем использовать CamelCase — для лучшей читабельности кода. Иногда вы будете видеть сочетание двух способов: подчёркивание для переменных и CamelCase для функций.

Стоит отметить, что, если вы работаете с чужим кодом, хорошей практикой будет придерживаться стиля, в котором написан этот код, даже если он не соответствует рекомендациям, приведенным выше.

Во-вторых, не начинайте ваши имена с символа подчёркивания, так как такие имена уже зарезервированы для ОС, библиотеки и/или используются компилятором.

В-третьих, (это, пожалуй, самое важное правило из всех) используйте в качестве идентификаторов только те имена, которые реально описывают то, чем является объект. Очень характерно для неопытных программистов сокращать имена переменных, чтобы сэкономить время при наборе кода или потому, что они думают, что всё и так понятно. В большинстве случаев не всё всегда является понятным и очевидным. В идеале переменные нужно называть так, чтобы человек, который первый раз увидел ваш код, понял как можно скорее, что этот код делает. Через 3 месяца, когда вы будете пересматривать свои программы, вы забудете, как они работают, и будете благодарны самому себе за то, что называли переменные по сути, а не как попало. Чем сложнее код, тем проще и понятнее должны быть идентификаторы.

<table class="tabluc" style="font-size: 0.9em; margin-bottom: 15px;" width="100%"><tbody><tr><td><strong><span class="raznui_kolir_td">int ccount</span></strong></td><td>Плохо</td><td style="text-align: left;">Никто не знает, что такое ccount</td></tr><tr><td><strong><span class="raznui_kolir_td">int customerCount</span></strong></td><td>Хорошо</td><td style="text-align: left;">Теперь понятно, что мы считаем</td></tr><tr><td><strong><span class="raznui_kolir_td">int i</span></strong></td><td>Плохо*</td><td style="text-align: left;">В большинстве нетривиальных случаев — плохо, в простых примерах — может быть (например, в циклах)</td></tr><tr><td><strong><span class="raznui_kolir_td">int index</span></strong></td><td>50/50</td><td style="text-align: left;">Хорошо, если очевидно, индексом чего является переменная</td></tr><tr><td><strong><span class="raznui_kolir_td">int totalScore</span></strong></td><td>Хорошо</td><td style="text-align: left;">Всё понятно</td></tr><tr><td><strong><span class="raznui_kolir_td">int _count</span></strong></td><td>Плохо</td><td style="text-align: left;">Не начинайте имена переменных с символов подчёркивания</td></tr><tr><td><strong><span class="raznui_kolir_td">int count</span></strong></td><td>50/50</td><td style="text-align: left;">Хорошо, если очевидно, что мы считаем</td></tr><tr><td><strong><span class="raznui_kolir_td">int data</span></strong></td><td>Плохо</td><td style="text-align: left;">Какой тип данных?</td></tr><tr><td><strong><span class="raznui_kolir_td">int value1, value2</span></strong></td><td>50/50</td><td style="text-align: left;">Может быть трудно понять разницу между переменными</td></tr><tr><td><strong><span class="raznui_kolir_td">int numberOfApples</span></strong></td><td>Хорошо</td><td style="text-align: left;">Всё понятно</td></tr><tr><td><strong><span class="raznui_kolir_td">int monstersKilled</span></strong></td><td>Хорошо</td><td style="text-align: left;">Всё понятно</td></tr><tr><td><strong><span class="raznui_kolir_td">int x, y</span></strong></td><td>Плохо*</td><td style="text-align: left;">В большинстве нетривиальных случаев — плохо, в простых примерах — может быть (например, в математических функциях)</td></tr></tbody></table>

> **Примечание**: Можно использовать тривиальные имена для переменных, которые имеют тривиальное использование (например, для переменных в цикле, в простых математических функциях и т.д.).

В-четвертых, уточняющий комментарий всегда будет только плюсом. Например, мы объявили переменную с именем `numberOfChars`, которая должна хранить количество символов определенной части строки. Сколько символов в строке `Hello, world!`: `10`, `11`, `12` или `13`? Это зависит от того, учитываем ли мы пробелы и знаки препинания или нет. Вместо названия переменной `numberOfCharsIncludingWhitespaceAndPunctuation` лучше оставить хороший комментарий, который прояснит ситуацию:

``` cpp
// Эта переменная подсчитывает количество символов части строки, включая пробелы и знаки препинания
int numberOfChars;
```
## Тест

Какие из переменных неправильно названы и почему?

  * `int result;`

  * `int _oranges;`

  * `int NUMBER;`

  * `int the name of a variable;`

  * `int TotalCustomers;`

  * `int void;`

  * `int countFruit;`

  * `int 4orYou;`

  * `int kilograms_of_pipe;`


## Ответ

   * int result`. Всё ок.

   * `int _oranges`. Имена переменных не должны начинаться с символов подчёркивания.

   * `int NUMBER`. Имена переменных должны начинаться с буквы в нижнем регистре.

   * `int the name of a variable`. Имена переменных не могут содержать пробелы.

   * `int TotalCustomers`. Имена переменных должны начинаться с буквы в нижнем регистре.

   * `int void`. `void` — это ключевое слово и его нельзя использовать в качестве идентификатора для своих переменных или функций.

   *  int countFruit`. Всё ок.

   * `int 4orYou`. Имена переменных не могут начинаться с цифр.

   * `int kilograms_of_pipe`. Всё ок.


___
# Урок №17. Операторы

Как мы уже знаем из предыдущих уроков, выражение — это математический объект, который имеет определенное значение. Однако, термин «математический объект» несколько расплывчатый. Точнее будет так: **выражение** — это комбинация литералов, переменных, функций и операторов, которая генерирует (создает) определенное значение.

> ### Оглавление:
> * [Литералы]()
> * [Операторы]()
> * [Заключение]()

## Литералы
Литерал — это фиксированное значение, которое записывается непосредственно в исходном коде (например, `7` или `3.14159`). Вот пример программы, которая использует литералы:

``` cpp
#include <iostream>
 
int main()
{
   int a = 3; // a – это переменная, 3 – это литерал
   std::cout << 5 + 2; // 5 + 2 – это выражение, 5 и 2 – это литералы
   std::cout << "Hello, world!"; // "Hello, world" – это тоже литерал
}
```

Литералы, переменные и функции еще известны как операнды. Операнды — это данные, с которыми работает выражение. Литералы имеют фиксированные значения, переменным можно присваивать значения, функции же генерируют определенные значения (в зависимости от типа возврата, исключением являются функции типа `void`).

## Операторы

Последним пазлом в выражениях являются операторы. С их помощью мы можем объединить операнды для получения нового значения. Например, в выражении `5 + 2`, `+` является оператором. С помощью `+` мы объединили операнды `5` и `2` для получения нового значения (`7`).

Вы, вероятно, уже хорошо знакомы со стандартными арифметическими операторами из школьной математики: сложение (`+`), вычитание (`-`), умножение (`*`) и деление (`/`). Знак равенства `=` является оператором присваивания. Некоторые операторы состоят более чем из одного символа, например, оператор равенства `==`, который позволяет сравнивать между собой два определенных значения.

> ***Примечание***: Очень часто новички путают оператор присваивания (`=`) с оператором равенства (`==`). С помощью оператора присваивания (`=`) мы присваиваем переменной определенное значение. С помощью оператора равенства (`==`) мы проверяем, равны ли между собой два определенных операнда.

Операторы бывают трёх типов:

  * **Унарные**. Работают с одним операндом. Например, оператор − (минус). В выражении `−7`, оператор − применяется только к одному операнду (`7`), чтобы создать новое значение (`−7`).

  * **Бинарные**. Работают с двумя операндами (левым и правым). Например, оператор `+`. В выражении `5 + 2`, оператор `+` работает с левым операндом (`5`) и правым (`2`), чтобы создать новое значение (`7`).

  * **Тернарные**. Работают с тремя операндами (в языке C++ есть только один тернарный оператор).

Обратите внимание, некоторые операторы могут иметь несколько значений. Например, оператор `−` (минус) может использоваться в двух контекстах: как унарный для изменения знака числа (например, конвертировать `7` в `−7` и наоборот), и как бинарный для выполнения арифметической операции вычитания (например, `4 - 3`).

## Заключение
Это только верхушка айсберга. Более детально об операторах мы обязательно поговорим на следующих уроках.

__
# Урок №18. Базовое форматирование кода

**Пробелы** относятся к символам, которые используются в форматировании кода, вместе с символами табуляции и, иногда, разрывом строки. Компилятор, как правило, игнорирует пробелы, но все же есть небольшие исключения.

В следующем примере все строки кода выполняют одно и то же:
``` cpp
std::cout << "Hello, world!";
 
std::cout               <<            "Hello, world!";
 
std::cout << "Hello, world!";
 
std::cout
    << "Hello, world!";
```

Даже последний стейтмент с разрывом строки успешно скомпилируется.

Аналогично:

``` cpp
int add(int x, int y) { return x + y; }
 
int add(int x, int y) {
    return x + y; }
 
int add(int x, int y)
{    return x + y; }
 
int add(int x, int y)
{
    return x + y;
}
```
Исключением, где компилятор учитывает пробелы, является цитируемый текст, например: `"Hello, world!"`.

`"Hello, world!"`

отличается от

`"Hello,     world!"`

Разрыв/перевод строки не допускается в цитируемом тексте:

``` cpp
std::cout << "Hello,
     world!" << std::endl; // Не допускается!
```

Еще одним исключением, где компилятор обращает внимание на пробелы, являются однострочные комментарии: они занимают только одну строку. Перенос однострочного комментария на вторую строку вызовет ошибку компиляции, например:

``` cpp
std::cout << "Hello, world!" << std::endl; // это однострочный комментарий
А это уже не комментарий
```

## Основные рекомендации
В отличие от других языков программирования, C++ не имеет каких-либо ограничений в форматировании кода со стороны программистов. Основное правило заключается в том, чтобы использовать только те способы, которые максимально улучшают читабельность и логичность кода.

Вот 6 основных рекомендаций:

* **Рекомендация №1**: Вместо символа табуляции (клавиша «Tab») используйте 4 пробела. В некоторых IDE по умолчанию используются три пробела в качестве одного символа табуляции — это тоже нормально (количество пробелов можно легко настроить в соответствующих пунктах меню вашей IDE).

Причиной использования пробелов вместо символов табуляции является то, что если вы откроете свой код в другом редакторе, то он сохранит правильные отступы, в отличие от использования символов табуляции.

* **Рекомендация №2**: Открытие и закрытие фигурных скобок функции должно находиться на одном уровне на отдельных строках:

``` cpp
int main()
{
   // ...
}
```
Хотя есть еще и следующий вариант (вы также можете его использовать):
``` cpp
int main() {
   // ...
}
```
Первый вариант хорош тем, что в случае возникновения ошибки несоответствия скобок, найти те самые проблемные скобки визуально будет проще.

**Рекомендация №3**: Каждый стейтмент функции должен быть с соответствующим отступом (клавиша `Tab` или 4 пробела):

``` cpp
int main()
{
    std::cout << "Hello world!" << std::endl; // один Tab (4 пробела)
    std::cout << "Nice to meet you." << std::endl; // один Tab(4 пробела)
}
```
**Рекомендация №4**: Строки не должны быть слишком длинными. 72, 78 или 80 символов — это оптимальный максимум строки. Если она будет длиннее, то её следует разбить на несколько отдельных строк:
``` cpp
int main()
{
    std::cout << "This is a really, really, really, really, really, really, really, " <<
        "really long line" << std::endl; // один дополнительный отступ для строки-продолжения
 
    std::cout << "This is another really, really, really, really, really, really, really, " <<
            "really long line" << std::endl; // отступ + выравнивание с учетом главной строки
 
    std::cout << "This one is short" << std::endl;
}
```
**Рекомендация №5**: Если длинная строка разбита на части с помощью определенного оператора (например, `<<` или `+`), то этот оператор должен находиться в конце этой же строки, а не в начале следующей (так читабельнее).

Правильно:

``` cpp
std::cout << "This is a really, really, really, really, really, really, really, " <<
        "really long line" << std::endl;
```

Неправильно:

``` cpp
std::cout << "This is a really, really, really, really, really, really, really, "
        << "really long line" << std::endl;
```

**Рекомендация №6**: Используйте пробелы и пропуски строк между стейтментами для улучшения читабельности вашего кода.

Менее читабельно:

``` cpp
nCost = 57;
nPricePerItem = 24;
nValue = 5;
nNumberOfItems = 17;
```

Более читабельно:

``` cpp
nCost          = 57;
nPricePerItem  = 24;
nValue         = 5;
nNumberOfItems = 17;
```
Менее читабельно:

``` cpp
std::cout << "Hello world!" << std::endl; // cout и endl находятся в библиотеке iostream
std::cout << "It is very nice to meet you!" << std::endl; // эти комментарии ухудшают читабельность кода
std::cout << "Yeah!" << std::endl; // особенно, когда строки разной длины
```

Более читабельно:

``` cpp
std::cout << "Hello world!" << std::endl;                  // cout и endl находятся в библиотеке iostream
std::cout << "It is very nice to meet you!" << std::endl;  // эти комментарии более читабельны
std::cout << "Yeah!" << std::endl;                         // не так ли?
```
Менее читабельно:

``` cpp
// cout и endl находятся в библиотеке iostream
std::cout << "Hello world!" << std::endl;
// эти комментарии ухудшают читабельность кода
std::cout << "It is very nice to meet you!" << std::endl;
// особенно, когда они в одной куче
std::cout << "Yeah!" << std::endl;
```

Более читабельно:

``` cpp
// cout и endl находятся в библиотеке iostream
std::cout << "Hello world!" << std::endl;
 
// эти комментарии читать легче
std::cout << "It is very nice to meet you!" << std::endl;
 
// ведь они разделены дополнительными строками
std::cout << "Yeah!" << std::endl;
```

Язык C++ позволяет выбрать вам тот стиль форматирования вашего кода, в котором вам будет наиболее комфортно работать.

___
# Урок №19. Прототип функции и Предварительное объявление

На этом уроке мы рассмотрим прототип функции и предварительное объявление в языке С++.

> ## Оглавление:
> * [Наличие проблемы]()
> * [Прототипы функций и Предварительное объявление]()
> * [Предварительно объявили, но не определили]()
> * [Объявление vs. Определение]()
> * [Тест]()
> * [Ответы]()

## Наличие проблемы
Посмотрите на этот, казалось бы, невинный кусочек кода под названием add.cpp:


``` cpp
#include <iostream>
 
int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
    return 0;
}
 
int add(int x, int y)
{
    return x + y;
}
```

Вы, наверное, ожидаете увидеть примерно следующий результат:

`The sum of 3 and 4 is: 7`

Но в действительности эта программа даже не скомпилируется. Причиной этому является то, что компилятор читает код последовательно. Когда он встречает вызов функции `add()` в строке №5 функции `main()`, он даже не знает, что такое `add()`, так как это еще не определили! В результате чего мы получим следующую ошибку:

`add: идентификатор не найден`

Чтобы устранить эту проблему, мы должны учитывать тот факт, что компилятор не знает, что такое `add()`. Есть 2 решения.

***Решение №1***: Поместить определение функции `add()` выше её вызова (т.е. перед функцией `main()`):

``` cpp
#include <iostream>
 
int add(int x, int y)
{
    return x + y;
}
 
int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
    return 0;
}
```

Таким образом, при вызове функции `add()` в функции `main()`, компилятор будет знать, что это такое. Так как это простая программа, то внести подобные изменения несложно. Однако в программах, содержащих большое количество строк кода, это может быть утомительно — узнавать кто кого вызывает и в каком порядке (чтобы соблюсти правильную последовательность).

Кроме того, этот вариант не всегда возможен. Например, мы пишем программу, которая имеет две функции: `А` и `В`. Если функция `А` вызывает функцию `B`, а функция `B` вызывает функцию `А`, то нет никакого способа упорядочить эти функции таким образом, чтобы они обе одновременно знали о существовании друг друга. Если вы объявите сначала `А`, то компилятор будет жаловаться, что не знает, что такое `B`. Если вы объявите сначала `В`, то компилятор будет жаловаться, что не знает, что такое `А`.

## Прототипы функций и Предварительное объявление

***Решение №2***: Использовать предварительное объявление.

**Предварительное объявление** сообщает компилятору о существовании идентификатора ДО его фактического определения.

В случае функций, мы можем сообщить компилятору о существовании функции до её фактического определения. Для этого нам следует использовать прототип этой функции. Прототип функции (полноценный) состоит из типа возврата функции, её имени и параметров (тип + имя параметра). В кратком прототипе отсутствуют имена параметров функции. Основная часть (между фигурными скобками) опускается. А поскольку прототип функции является стейтментом, то он также заканчивается точкой с запятой.

Вот прототип функции `add()`:

``` cpp
int add(int x, int y); // прототип функции состоит из типа возврата функции, её имени, параметров и точки с запятой
```

А вот вышеприведенная программа, но уже с прототипом функции в качестве предварительного объявления аdd():

``` cpp
#include <iostream>
 
int add(int x, int y); // предварительное объявление функции add() (используется её прототип)
 
int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl; // это работает, так как мы предварительно (выше функции main()) объявили функцию add()
    return 0;
}
 
int add(int x, int y) // хотя определение функции add() находится ниже её вызова
{
    return x + y;
}
```

Теперь, когда компилятор встречает вызов функции add() в main(), он знает, что это такое и где это искать.

Стоит отметить, что в прототипах функций можно и не указывать имена параметров. Например, прототип выше мы можем записать следующим образом:

``` cpp
int add(int, int);
```

Тем не менее, предпочтительнее указывать имена параметров, чтобы не путаться лишний раз.

> ***Лайфхак***: Прототипы функций можно легко создавать с помощью копирования/вставки из фактического определения функции. Просто не забывайте указывать точку с запятой в конце.


## Предварительно объявили, но не определили

**Вопрос**: «А что произойдет, если мы предварительно объявим функцию, но не запишем её определение?». Однозначного ответа нет. Если предварительное объявление записано, но функция никогда не вызывается, то программа может запуститься без ошибок. Однако, если предварительное объявление записано, функция вызывается, но её определения нет, то вы получите ошибку на этапе линкинга: программа просто не сможет обработать вызов этой функции.

Рассмотрим следующую программу:
```cpp
#include <iostream>

int add(int x, int y); // предварительное объявление функции add() (используется её прототип)

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
    return 0;
}
```

В этой программе мы предварительно объявили функцию `add()`, вызвали её в `main()`, но не записали её определения. При попытке компиляции этой программы мы получим ошибку от линкера.

## Объявление vs. Определение

В языке C++ вы часто будете слышать слова «объявление» и «определение». Что это такое?

Определение фактически реализует (вызывает выделение памяти) идентификатор. Вот примеры определений:

``` cpp
int add(int x, int y) // определяем функцию add()
{
    int z = x + y; // определяем переменную z
 
    return z;
}
```

Определение необходимо для корректной работы линкера. Если вы используете идентификатор без его определения, то линкер выдаст вам ошибку.

В языке C++ есть правило одного определения, которое состоит из 3-х частей:

  * Внутри файла функция, объект, тип или шаблон могут иметь только одно определение.

  * Внутри программы объект или обычная функция могут иметь только одно определение.

  * Внутри программы типы, шаблоны функций и встроенные функции могут иметь несколько определений, если они идентичны.

Нарушение первой части правила приведет к ошибке компиляции. Нарушение второй или третьей части правила приведет к ошибке линкинга.

**Объявление** — это стейтмент, который сообщает компилятору о существовании идентификатора и о его типе. Вот примеры объявлений:

``` cpp
int add(int x, int y); // сообщаем компилятору о функции add(), которая имеет два параметра типа int и возвращает целочисленное значение
int x; // объявляем целочисленную переменную х
```

Объявление — это всё, что необходимо для корректной работы компилятора, но недостаточно для корректной работы линкера. Определение — это то, что обеспечит корректную работу как компилятора, так и линкера.

## Тест
**Задание №1**: В чём разница между прототипом функции и предварительным объявлением?

**Задание №2**: Запишите прототип следующей функции:

``` cpp
int doMath(int first, int second, int third, int fourth)
{
    return first + second * third / fourth;
}
```

**Задание №3**: Выясните, какие из следующих программ не пройдут этап компиляции, какие не пройдут этап линкинга, а какие не пройдут и то, и другое?

*Программа №1*:
``` cpp
#include <iostream>

int add(int x, int y);
 
int main()
{
    std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << std::endl;
    return 0;
}
 
int add(int x, int y)
{
    return x + y;
}
```
*Программа №2*:
``` cpp
#include <iostream>
 
int add(int x, int y);
 
int main()
{
    std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << std::endl;
    return 0;
}
 
int add(int x, int y, int z)
{
    return x + y + z;
}
```

*Программа №3*:
``` cpp
#include <iostream>
 
int add(int x, int y);
 
int main()
{
    std::cout << "3 + 4 + 5 = " << add(3, 4) << std::endl;
    return 0;
}
 
int add(int x, int y, int z)
{
    return x + y + z;
}
```

*Программа №4*:
```cpp
#include <iostream>

int add(int x, int y, int z);
 
int main()
{
    std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << std::endl;
    return 0;
}
 
int add(int x, int y, int z)
{
    return x + y + z;
}
```

## Ответы


**Ответ №1**

Прототип функции (полноценный) — это стейтмент объявления функции, который состоит из типа возврата функции, её имени и параметров (тип + имя параметра). В кратком прототипе отсутствуют имена параметров функции. Тело функции не записывается.

Предварительное объявление сообщает компилятору о существовании идентификатора до его фактического определения.

Для функций прототип является предварительным объявлением.

**Ответ №2**

``` cpp
// Любой из этих прототипов является правильным
// Не забывайте указывать точку с запятой в конце
 
int doMath(int first, int second, int third, int fourth); // лучшее решение 
int doMath(int, int, int, int); // альтернативное решение
Ответ №3
```
*Программа №1*: Не скомпилируется. Компилятор будет жаловаться, что слишком много аргументов в вызове функции `add()`.

*Программа №2*: Не скомпилируется. Компилятор будет жаловаться на то, что вызов функции `add()` не может принять столько аргументов.

*Программа №3*: Провал на этапе линкинга. Функция `аdd()`, которая принимает два параметра, не была определена (мы определили функцию, которая принимает 3 параметра).

*Программа №4*: Успешная компиляция и линкинг. Вызов функции `add()` соответствует и прототипу, который был объявлен, и определению функции.

___
# Урок №20. Многофайловые программы

Как только программы становятся больше, их следует разбивать на несколько файлов (в целях удобства и улучшения функциональности). Одним из преимуществ использования IDE является легкость в работе с n-ным количеством файлов. Мы уже знаем, как создавать и компилировать однофайловые проекты, добавление новых файлов не составит труда.

> ## Оглавление:
> * [Многофайловые проекты в Visual Studio]()
> * [Многофайловые проекты в Code::Blocks]()
> * [Многофайловые проекты в GCC/G++]()
> * [Пример многофайловой программы]()
> * [Что-то пошло не так!]()
> * [Тест]()

## Многофайловые проекты в Visual Studio
В *Visual Studio* щелкните правой кнопкой мыши по имени вашего проекта в `"Обозревателе решений"`, затем `"Добавить" > "Создать элемент..."`:

![](https://ravesli.com/wp-content/uploads/2016/09/1.jpg)

Во всплывающем диалоговом окне выберите тип файла, укажите его имя, расположение, а затем нажмите `"Добавить"`:

![](https://ravesli.com/wp-content/uploads/2016/09/2.jpg)

Также вы можете добавлять файлы к вашему проекту через `"Проект" > "Добавить новый элемент..."`:

![](https://ravesli.com/wp-content/uploads/2016/09/3.jpg)

## Многофайловые проекты в Code::Blocks

В Code::Blocks перейдите в `"File" > "New" > "File..."`:

![](https://ravesli.com/wp-content/uploads/2016/09/4.jpg)

Затем выберите `"C/C++ source"` и нажмите `"Go"`:

![](https://ravesli.com/wp-content/uploads/2016/09/5.jpg)

Затем `"Next"` (этого окна может и не быть):

![](https://ravesli.com/wp-content/uploads/2016/09/6.jpg)

Затем `"C++"` и опять `"Next"`:

![](https://ravesli.com/wp-content/uploads/2016/09/7.jpg)

Затем укажите имя нового файла (не забудьте расширение `.cpp`) и его расположение (нажмите на троеточие и выберите путь). Убедитесь, что поставлены все три галочки (они отвечают за конфигурации сборки). Затем нажмите `"Finish"`:

![](https://ravesli.com/wp-content/uploads/2016/09/8.jpg)

Готово! Файл добавлен.

## Многофайловые проекты в GCC/G++
В командной строке вам нужно будет создать файл, указать его имя и подключить к компиляции, например:

`g++ main.cpp add.cpp -o main`

(где `main.cpp` и `add.cpp` — это имена файлов с кодом, а *main* — это имя файла-результата)

Пример многофайловой программы

Рассмотрим следующую программу, которая состоит из двух файлов.

add.cpp:
``` cpp
int add(int x, int y)
{
    return x + y;
}
```

main.cpp:
``` cpp
#include <iostream>
 
int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
    return 0;
}
```

Попробуйте запустить эту программу. Она не скомпилируется, вы получите следующую ошибку:

`add: идентификатор не найден`

При компиляции кода, компилятор не знает о существовании функций, которые находятся в других файлах. Это сделано специально, чтобы функции и переменные с одинаковыми именами, но в разных файлах, не вызывали конфликт имен.

Тем не менее, в данном случае, мы хотим, чтобы main.cpp знал (и использовал) функцию `аdd()`, которая находится в `add.cpp`. Для предоставления доступа `main.cpp` к функциям `add.cpp`, нам нужно использовать предварительное объявление:

``` cpp
#include <iostream>
 
int add(int x, int y); // это нужно для того, чтобы main.cpp знал, что функция add() определена в другом месте
 
int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
    return 0;
}
```
Теперь, когда компилятор будет компилировать main.cpp, он будет знать, что такое `add()`. Попробуйте запустить эту программу еще раз.

## Что-то пошло не так!
Есть много вещей, которые могут пойти не так, особенно, если вы это делаете в первый раз. Главное — не паниковать:

* *Пункт №1*: Если вы получили ошибку от компилятора, что функция `add()` не определена в `main()`, то, скорее всего, вы забыли записать предварительное объявление функции `add()` в `main.cpp`.

* *Пункт №2*: Если вы получили следующую ошибку от линкера:

`unresolved external symbol "int __cdecl add(int,int)" (?add@@YAHHH@Z) referenced in function _main`

то возможных решений есть несколько:

* **a)** Cкорее всего, add.cpp некорректно добавлен в ваш проект. Если вы используете Visual Studio или Code::Blocks, то вы должны увидеть `add.cpp` в `"Обозревателе решений"` в списке файлов вашего проекта или в панели проекта IDE. Если добавленного файла нет, то щелкните правой кнопкой мыши по вашему проекту и добавьте файл, как это показано выше, а затем повторите попытку компиляции вашего проекта.

* **б)** Вполне возможно, что вы добавили `add.cpp` к другому проекту.

* **в)** Вполне возможно, что добавленный файл не подключен к компиляции/линкингу. Щелкните правой кнопкой мыши по имени вашего добавленного файла и выберите `"Свойства"`:

![](https://ravesli.com/wp-content/uploads/2016/09/9-1.jpg)

Убедитесь, что пункт `"Исключен из сборки"` оставлен пустым или выбрано значение `"Нет"`:

![](https://ravesli.com/wp-content/uploads/2016/09/10.jpg)

Пункт №3: Не следует писать следующую строку в main.cpp:
``` cpp
#include "add.cpp"
```
Наличие этой строки приведет к тому, что компилятор вставит всё содержимое `add.cpp` непосредственно в `main.cpp` вместо того, чтобы рассматривать эти файлы как отдельные.

Тест

Разделите следующую программу на два файла (`main.cpp` и `input.cpp`): `main.cpp` должен содержать функцию main(), а `input.cpp` — функцию `getInteger()`.

Помните, что для функции `getInteger()` вам понадобится предварительное объявление в `main.cpp`.

``` cpp
#include <iostream>
 
int getInteger()
{
	std::cout << "Enter an integer: ";
	int x;
	std::cin >> x;
	return x;
}
 
int main()
{
	int x = getInteger();
	int y = getInteger();
 
	std::cout << x << " + " << y << " is " << x + y << '\n';
	return 0;
}
```

## Ответ

`input.cpp`:
``` cpp
#include <iostream>
 
int getInteger()
{
	std::cout << "Enter an integer: ";
	int x;
	std::cin >> x;
	return x;
}
```
`main.cpp`:
``` cpp
#include <iostream>
 
int getInteger(); // предварительное объявление функции getInteger()
 
int main()
{
	int x = getInteger();
	int y = getInteger();
 
	std::cout << x << " + " << y << " is " << x + y << '\n';
	return 0;
}
```


___
# Урок №21. Заголовочные файлы

По мере увеличения размера программ весь код уже не помещается в нескольких файлах, записывать каждый раз предварительные объявления для функций, которые мы хотим использовать, но которые находятся в других файлах, становится всё утомительнее и утомительнее. Хорошо было бы, если бы все предварительные объявления находились в одном месте, не так ли?

Файлы `.cpp` не являются единственными файлами в проектах. Есть еще один тип файлов — заголовочные файлы (или «заголовки»), которые имеют расширение `.h`. Целью заголовочных файлов является удобное хранение набора объявлений объектов для их последующего использования в других программах.

> ## Оглавление:
> * [Заголовочные файлы из Cтандартной библиотеки C++]()
> * [Пишем свои собственные заголовочные файлы]()
> * [Угловые скобки (`<>`) vs. Двойные кавычки (`""`)]()
> * [Почему `iostream` пишется без окончания `.h`?]()
> * [Можно ли записывать определения в заголовочных файлах?]()
> * [Советы]()

## Заголовочные файлы из Стандартной библиотеки C++

Рассмотрим следующую программу:
``` cpp
#include <iostream>
 
int main()
{
    std::cout << "Hello, world!" << std::endl;
    return 0;
}
```
Результат выполнения программы:

`Hello, world!`

В этой программе мы используем `cout`, который нигде не определяем. Откуда компилятор знает, что это такое? Дело в том, что `cout` объявлен в заголовочном файле `iostream`. Когда мы пишем `#include <iostream>`, мы делаем запрос, чтобы всё содержимое заголовочного файла `iostream` было скопировано в наш файл. Таким образом, всё содержимое библиотеки `iostream` становится доступным для использования.

Как правило, в заголовочных файлах записываются только объявления, без определений. Следовательно, если cout только объявлен в заголовочном файле `iostream`, то где же он определяется? Ответ: в Стандартной библиотеке С++, которая автоматически подключается к вашему проекту на этапе линкинга.

![](https://ravesli.com/wp-content/uploads/2016/10/headerFile.jpg)

Подумайте о последствиях отсутствия заголовочного файла `iostream`. Каждый раз, при использовании `cout`, вам бы приходилось вручную копировать все предварительные объявления, связанные с `cout` в верхнюю часть вашего файла! Хорошо ведь, что можно просто указать `#include <iostream>`, не так ли?

## Пишем свои собственные заголовочные файлы

Теперь давайте вернемся к примеру, который мы обсуждали на предыдущем уроке. У нас было два файла: `add.cpp` и `main.cpp`.

`add.cpp`:
``` cpp
int add(int x, int y)
{
    return x + y;
}
```
`main.cpp`:
``` cpp
#include <iostream>
 
int add(int x, int y); // предварительное объявление с использованием прототипа функции
 
int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << std::endl;
    return 0;
}
```

> ***Примечание***: Если вы создаете все файлы заново, то не забудьте добавить `add.cpp` в свой проект, чтобы он был подключен к компиляции.

Мы использовали предварительное объявление, чтобы сообщить компилятору, что такое `add()`. Как мы уже говорили, записывать в каждом файле предварительные объявления используемых функций — дело не слишком увлекательное.

И здесь нам на помощь приходят заголовочные файлы. Достаточно просто написать один заголовочный файл и его можно будет повторно использовать в любом количестве программ. Также и вносить изменения в такой код (например, добавление еще одного параметра) гораздо легче, нежели чем шерстить по всем файлам в поисках используемых функций.

Написать свой собственный заголовочный файл не так уж и сложно. Заголовочные файлы состоят из двух частей:

  * Директивы препроцессора — в частности, header guards, которые предотвращают вызов заголовочного файла больше одного раза из одного и того же файла (об этом детально на следующем уроке).

  * Содержимое заголовочного файла — набор объявлений.

Все ваши заголовочные файлы (которые вы написали самостоятельно) должны иметь расширение `.h`.

`add.h`:
``` cpp
// Начнем с директив препроцессора. ADD_H – это произвольное уникальное имя (обычно используется имя заголовочного файла)
#ifndef ADD_H
#define ADD_H
 
// А это уже содержимое заголовочного файла
int add(int x, int y); // прототип функции add() (не забывайте точку с запятой в конце!)
 
// Заканчиваем директивой препроцессора
#endif
```

Чтобы использовать этот файл в `main.cpp`, вам сначала нужно будет подключить его к проекту.

`main.cpp`, в котором мы подключаем `add.h`:
``` cpp
#include <iostream>
#include "add.h"
 
int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << std::endl;
    return 0;
}
```
Когда компилятор встречает `#include "add.h"`, он копирует всё содержимое `add.h` в текущий файл. Таким образом, мы получаем предварительное объявление функции `add()`.

> ***Примечание***: При подключении заголовочного файла, всё его содержимое вставляется сразу же после строки `#include` ....

Если вы получили ошибку от компилятора, что `add.h` не найден, то убедитесь, что имя вашего файла точно «`add.h`». Вполне возможно, что вы могли сделать опечатку, например, просто «`add`» (без «`.h`») или «`add.h.txt`» или «`add.hpp`».

Если вы получили ошибку от линкера, что функция `аdd()` не определена, то убедитесь, что вы корректно подключили `add.cpp` к вашему проекту (и к компиляции тоже)!

## Угловые скобки (<>) vs. Двойные кавычки ("")
Вы, наверное, хотите узнать, почему используются угловые скобки для `iostream` и двойные кавычки для `add.h`. Дело в том, что, используя угловые скобки, мы сообщаем компилятору, что подключаемый заголовочный файл написан не нами (он является «системным», т.е. предоставляется Стандартной библиотекой С++), так что искать этот заголовочный файл следует в системных директориях. Двойные кавычки сообщают компилятору, что мы подключаем наш собственный заголовочный файл, который мы написали самостоятельно, поэтому искать его следует в текущей директории нашего проекта. Если файла там не окажется, то компилятор начнет проверять другие пути, в том числе и системные директории.

> ***Правило***: Используйте угловые скобки для подключения «системных» заголовочных файлов и двойные кавычки для ваших заголовочных файлов.

Стоит отметить, что одни заголовочные файлы могут подключать другие заголовочные файлы. Тем не менее, так делать не рекомендуется.

Почему iostream пишется без окончания `.h`?

Еще один часто задаваемый вопрос: «Почему iostream (или любой другой из стандартных заголовочных файлов) при подключении пишется без окончания «`.h`»?». Дело в том, что есть 2 отдельных файла: iostream.h (заголовочный файл) и просто `iostream`! Для объяснения потребуется краткий экскурс в историю.

Когда C++ только создавался, все файлы библиотеки Runtime имели окончание `.h`. Оригинальные версии cout и cin объявлены в `iostream`.`h.` При стандартизации языка С++ комитетом ANSI, решили перенести все функции из библиотеки Runtime в пространствo имен `std`, чтобы предотвратить возможность возникновения конфликтов имен с пользовательскими идентификаторами (что, между прочим, является хорошей идеей). Тем не менее, возникла проблема: если все функции переместить в пространство имен `std`, то старые программы переставали работать!

Для обеспечения обратной совместимости ввели новый набор заголовочных файлов с теми же именами, но без окончания «`.h`». Весь их функционал находится в пространстве имен std. Таким образом, старые программы с `#include <iostream.h>` не нужно было переписывать, а новые программы уже могли использовать `#include <iostream>`.

Когда вы подключаете заголовочный файл из Стандартной библиотеки C++, убедитесь, что вы используете версию без `.h` (если она существует). В противном случае, вы будете использовать устаревшую версию заголовочного файла, который уже больше не поддерживается.

Кроме того, многие библиотеки, унаследованные от языка Cи, которые до сих пор используются в C++, также были продублированы с добавлением префикса c (например, `stdlib.h` стал `cstdlib`). Функционал этих библиотек также перенесли в пространство имен `std`, чтобы избежать возможность возникновения конфликтов имен с пользовательскими идентификаторами.

> ***Правило***: При подключении заголовочных файлов из Стандартной библиотеки С++, используйте версию без «.h» (если она существует). Пользовательские заголовочные файлы должны иметь окончание «.h».

Можно ли записывать определения в заголовочных файлах?
C++ не будет жаловаться, если вы это сделаете, но так делать не принято.

Как уже было сказано выше, при подключении заголовочного файла, всё его содержимое вставляется сразу же после строки с `#include`. Это означает, что любые определения, которые есть в заголовочном файле, скопируются в ваш файл.

Для небольших проектов, это, скорее всего, не будет проблемой. Но для более крупных это может способствовать увеличению времени компиляции (так как код будет повторно компилироваться) и размеру исполняемого файла. Если внести изменения в определения, которые находятся в файле `.cpp`, то перекомпилировать придется только этот файл. Если же внести изменения в определения, которые записаны в заголовочном файле, то перекомпилировать придется каждый файл, который подключает этот заголовок, используя директиву препроцессора `#include`. И вероятность того, что из-за одного небольшого изменения вам придется перекомпилировать весь проект, резко возрастает!

Иногда делаются исключения для простых функций, которые вряд ли изменятся (например, где определение состоит всего лишь из одной строки).

## Советы

Вот несколько советов по написанию собственных заголовочных файлов:

  * Всегда используйте директивы препроцессора.

  * Не определяйте переменные в заголовочных файлах, если это не константы. Заголовочные файлы следует использовать только для объявлений.

  * Не определяйте функции в заголовочных файлах.

  * Каждый заголовочный файл должен выполнять свое конкретное задание и быть как можно более независимым. Например, вы можете поместить все ваши объявления, связанные с файлом `sА.cpp` в файл `A.h`, а все ваши объявления, связанные с `B.cpp` — в файл `B.h`. Таким образом, если вы будете работать только с `А.cpp`, то вам будет достаточно подключить только `A.h` и наоборот.

  * Используйте имена ваших рабочих файлов в качестве имен для ваших заголовочных файлов (например, `grades.h` работает с `grades.cpp`).

  * Не подключайте одни заголовочные файлы из других заголовочных файлов.

  * Не подключайте файлы `.cpp`, используя директиву препроцессора `#include`.


___
# Урок №22. Директивы препроцессора

**Препроцессор** лучше всего рассматривать как отдельную программу, которая выполняется перед компиляцией. При запуске программы, препроцессор просматривает код сверху вниз, файл за файлом, в поиске директив. Директивы — это специальные команды, которые начинаются с символа # и НЕ заканчиваются точкой с запятой. Есть несколько типов директив, которые мы рассмотрим ниже.

> ## Оглавление:
> * [Директива `#include`]()
> * [Директива `#define`]()
> * [Макросы-объекты с `текст_замена`]()
> * [Макросы-объекты без `текст_замена`]()
> * [Условная компиляция]()
> * [Область видимости директивы `#define`]()

## Директива `#include`
Вы уже видели директиву `#include` в действии. Когда вы подключаете файл с помощью директивы `#include`, препроцессор копирует содержимое подключаемого файла в текущий файл сразу после строки с `#include`. Это очень полезно при использовании определенных данных (например, предварительных объявлений функций) сразу в нескольких местах.

Директива `#include` имеет две формы:

  * `#include <filename>`, которая сообщает препроцессору искать файл в системных путях (в местах хранения системных библиотек языка С++). Чаще всего вы будете использовать эту форму при подключении заголовочных файлов из Стандартной библиотеки C++.

  * `#include "filename"`, которая сообщает препроцессору искать файл в текущей директории проекта. Если его там не окажется, то препроцессор начнет проверять системные пути и любые другие, которые вы указали в настройках вашей IDE. Эта форма используется для подключения пользовательских заголовочных файлов.


## Директива `#define`

Директиву `#define` можно использовать для создания макросов. **Макрос** — это правило, которое определяет конвертацию идентификатора в указанные данные.

Есть два основных типа макросов: макросы-функции и макросы-объекты.

Макросы-функции ведут себя как функции и используются в тех же целях. Мы не будем сейчас их обсуждать, так как их использование, как правило, считается опасным, и почти всё, что они могут сделать, можно осуществить с помощью простой (линейной) функции.

Макросы-объекты можно определить одним из следующих двух способов:

`#define идентификатор`

Или:

`#define идентификатор текст_замена`

Верхнее определение не имеет никакого `текст_замена`, в то время как нижнее — имеет. Поскольку это директивы препроцессора (а не простые стейтменты), то ни одна из форм не заканчивается точкой с запятой.

## Макросы-объекты с `текст_замена`
Когда препроцессор встречает макросы-объекты с `текст_замена`, то любое дальнейшее появление идентификатор заменяется на `текст_замена`. идентификатор обычно пишется заглавными буквами с символами подчёркивания вместо пробелов.

Рассмотрим следующий фрагмент кода:
``` cpp
#define MY_FAVORITE_NUMBER 9
 
std::cout << "My favorite number is: " << MY_FAVORITE_NUMBER << std::endl;
```

Препроцессор преобразует вышеприведенный код в:
``` cpp
std::cout << "My favorite number is: " << 9 << std::endl;
```

Результат выполнения:

`My favorite number is: 9`

Мы обсудим это детально, и почему так не стоит делать, на следующих уроках.

## Макросы-объекты без `текст_замена`

Макросы-объекты также могут быть определены без текст_замена, например:
``` cpp
#define USE_YEN
```

Любое дальнейшее появление идентификатора `USE_YEN` удаляется и заменяется «ничем» (пустым местом)!

Это может показаться довольно бесполезным, однако, это не основное предназначение подобных директив. В отличие от макросов-объектов с текст_замена, эта форма макросов считается приемлемой для использования.

## Условная компиляция
Директивы препроцессора условной компиляции позволяют определить, при каких условиях код будет компилироваться, а при каких — нет. На этом уроке мы рассмотрим только три директивы условной компиляции:

  * `#ifdef`

  * `#ifndef`

  * `#endif`

Директива `#ifdef` (сокр. от «if defined» = «если определено») позволяет препроцессору проверить, было ли значение ранее определено с помощью директивы `#define`. Если да, то код между #ifdef и #endif скомпилируется. Если нет, то код будет проигнорирован. Например:
``` cpp
#define PRINT_JOE
 
#ifdef PRINT_JOE
std::cout << "Joe" << std::endl;
#endif
 
#ifdef PRINT_BOB
std::cout << "Bob" << std::endl;
#endif
```
Поскольку `PRINT_JOE` уже был определен, то строка `std::cout << "Joe" << std::endl;` скомпилируется и выполнится. А поскольку `PRINT_BOB` не был определен, то строка `std::cout << "Bob" << std::endl;` не скомпилируется и, следовательно, не выполнится.

Директива `#ifndef` (сокр. от «if not defined» = «если не определено») — это полная противоположность к `#ifdef`, которая позволяет проверить, не было ли значение ранее определено. Например:
```
Результатом выполнения этого фрагмента кода будет `Bob`, так как `PRINT_BOB` ранее никогда не был определен. Условная компиляция очень часто используется в качестве `header guards` (о них мы поговорим на следующем уроке).

## Область видимости директивы `#define`

Директивы выполняются перед компиляцией программы: сверху вниз, файл за файлом. Рассмотрим следующую программу:
``` cpp
#include <iostream>
 
void boo()
{
#define MY_NAME "Alex"
}
 
int main()
{
	std::cout << "My name is: " << MY_NAME;
 
	return 0;
}
```

Несмотря на то, что директива `#define MY_NAME "Alex"` определена внутри функции `boo()`, препроцессор этого не заметит, так как он не понимает такие понятия языка C++, как функции. Следовательно, выполнение этой программы будет идентично той, в которой бы `#define MY_NAME "Alex"` было определено ДО, либо сразу ПОСЛЕ функции `boo()`. Для лучше читабельности кода определяйте идентификаторы (с помощью `#define`) вне функций.

После того, как препроцессор завершит свое выполнение, все идентификаторы (определенные с помощью `#define`) из этого файла — отбрасываются. Это означает, что директивы действительны только с точки определения и до конца файла, в котором они определены. Директивы, определенные в одном файле кода, не влияют на директивы, определенные внутри других файлов этого же проекта.

Рассмотрим следующий пример:

`function.cpp`:
``` cpp
#include <iostream>
 
void doSomething()
{
#ifdef PRINT
    std::cout << "Printing!";
#endif
#ifndef PRINT
    std::cout << "Not printing!";
#endif
}
```

`main.cpp`:
``` cpp
void doSomething(); // предварительное объявление функции doSomething()
 
int main()
{
#define PRINT
 
    doSomething();
 
    return 0;
}
```

Результат выполнения программы:

`Not printing!`

Несмотря на то, что мы объявили `PRINT` в `main.cpp` (`#define PRINT`), это все равно не имеет никакого влияния на что-либо в `function.cpp`. Поэтому, при выполнении функции `doSomething()`, у нас выводится `Not printing!`, так как в файле `function.cpp` мы не объявляли идентификатор `PRINT` (с помощью директивы `#define`). Это связано с header guards.


___
# Урок №23. Header guards и #pragma once

На этом уроке мы рассмотрим, что такое header guards и #pragma once в языке C++, а также зачем они нужны и как их правильно использовать.

> ## Оглавление:
> * [Проблема дублирования объявлений]()
> * [Header guards]()
> * [`#pragma once`]()
> * [Тест]()

Проблема дублирования объявлений
Как мы уже знаем из урока о предварительных объявлениях, идентификатор может иметь только одно объявление. Таким образом, программа с двумя объявлениями одной переменной получит ошибку компиляции:
``` cpp
int main()
{
    int x; // это объявление идентификатора x
    int x; // ошибка компиляции: дублирование объявлений
 
    return 0;
}
```
То же самое касается и функций:
``` cpp
#include <iostream>
 
int boo()
{
    return 7;
}
 
int boo() // ошибка компиляции: дублирование определений
{
    return 7;
}
 
int main()
{
    std::cout << boo();
    return 0;
}
```

Хотя вышеприведенные ошибки легко исправить (достаточно просто удалить дублирование), с заголовочными файлами дела обстоят несколько иначе. Довольно легко можно попасть в ситуацию, когда определения одних и тех же заголовочных файлов будут подключаться больше одного раза в файл `.cpp`. Очень часто это случается при подключении одного заголовочного файла другим.

Рассмотрим следующую программу:

`math.h`:
``` cpp
int getSquareSides()
{
    return 4;
}

`geometry.h`:
``` cpp
#include "math.h"
```

`main.cpp`:
``` cpp
#include "math.h"
#include "geometry.h"
 
int main()
{
    return 0;
}
```

Эта, казалось бы, невинная программа, не скомпилируется! Проблема кроется в определении функции в файле `math.h`. Давайте детально рассмотрим, что здесь происходит:

  * Сначала `main.cpp` подключает заголовочный файл `math.h, вследствие чего определение функции getSquareSides копируется в main.cpp.

  * Затем main.cpp подключает заголовочный файл `geometry.h`, который, в свою очередь, подключает `math.h`.

  * В `geometry.h` находится копия функции `getSquareSides` (из файла `math.h`), которая уже во второй раз копируется в `main.cpp`.

Таким образом, после выполнения всех директив ``#include`, `main.cpp` будет выглядеть следующим образом:
``` cpp
int getSquareSides()  // из math.h
{
    return 4;
}
 
int getSquareSides() // из geometry.h
{
    return 4;
}
 
int main()
{
    return 0;
}
```

Мы получим дублирование определений и ошибку компиляции. Если рассматривать каждый файл по отдельности, то ошибок нет. Однако в `main.cpp`, который подключает сразу два заголовочных файла с одним и тем же определением функции, мы столкнемся с проблемами. Если для `geometry.h` нужна функция `getSquareSides()`, а для `main.cpp` нужен как `geometry.h`, так и `math.h`, то какое же решение?

## Header guards

На самом деле решение простое — использовать header guards (защиту подключения в языке C++). Header guards — это директивы условной компиляции, которые состоят из следующего:
``` cpp
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE
 
// Основная часть кода 
 
#endif
```

Если подключить этот заголовочный файл, то первое, что он сделает — это проверит, был ли ранее определен идентификатор `SOME_UNIQUE_NAME_HERE`. Если мы впервые подключаем этот заголовок, то `SOME_UNIQUE_NAME_HERE` еще не был определен. Следовательно, мы определяем `SOME_UNIQUE_NAME_HERE` (с помощью директивы `#define`) и выполняется основная часть заголовочного файла. Если же мы раньше подключали этот заголовочный файл, то `SOME_UNIQUE_NAME_HERE` уже был определен. В таком случае, при подключении этого заголовочного файла во второй раз, его содержимое будет проигнорировано.

Все ваши заголовочные файлы должны иметь header guards. `SOME_UNIQUE_NAME_HERE` может быть любым идентификатором, но, как правило, в качестве идентификатора используется имя заголовочного файла с окончанием `_H`. Например, в файле `math.h `идентификатор будет `MATH_H`:

`math.h`:
``` cpp
#ifndef MATH_H
#define MATH_H
 
int getSquareSides()
{
    return 4;
}
 
#endif
```

Даже заголовочные файлы из Стандартной библиотеки С++ используют header guards. Если бы вы взглянули на содержимое заголовочного файла iostream, то вы бы увидели:
``` cpp
#ifndef _IOSTREAM_
#define _IOSTREAM_
 
// основная часть кода
 
#endif
```

Но сейчас вернемся к нашему примеру с `math.h`, где мы попытаемся исправить ситуацию с помощью header guards:

`math.h`:
``` cpp
#ifndef MATH_H
#define MATH_H
 
int getSquareSides()
{
    return 4;
}
 
#endif
```

`geometry.h`:
``` cpp
#include "math.h"
```
`main.cpp`:
``` cpp
#include "math.h"
#include "geometry.h"
 
int main()
{
    return 0;
}
```

Теперь, при подключении в `main.cpp` заголовочного файла `math.h`, препроцессор увидит, что `MATH_H` не был определен, следовательно, выполнится директива определения `MATH_H` и содержимое `math.h` скопируется в `main.cpp`. Затем main.cpp подключает заголовочный файл `geometry.h`, который, в свою очередь, подключает `math.h`. Препроцессор видит, что `MATH_H` уже был ранее определен и содержимое `geometry.h` не будет скопировано в `main.cpp`.

Вот так можно бороться с дублированием определений с помощью header guards.

## `#pragma once`
Большинство компиляторов поддерживают более простую, альтернативную форму header guards — директиву `#pragma`:
``` cpp
#pragma once
 
// основная часть кода
```

`#pragma once` используется в качестве header guards, но имеет дополнительные преимущества — она короче и менее подвержена ошибкам.

Однако, `#pragma` once не является официальной частью языка C++, и не все компиляторы её поддерживают (хотя большинство современных компиляторов поддерживают).

Я же рекомендую использовать header guards, чтобы сохранить максимальную совместимость вашего кода.

## Тест

Добавьте header guards к следующему заголовочному файлу:

`add.h`:
``` cpp
int add(int x, int y);
```
## Ответ
``` cpp
#ifndef ADD_H
#define ADD_H
 
int add(int x, int y);
 
#endif
```

___
# Урок №24. Конфликт имен и std namespace

На этом уроке мы рассмотрим, что такое конфликт имен в языке C++ и как его решить с помощью пространств имен и оператора разрешения области видимости.

> ## Оглавление:
> * [Конфликт имен в C++]()
> * [Пространство имен]()
> * [Оператор разрешения области видимости `::`]()

## Конфликт имен в C++

Допустим, что вам нужно съездить к дальним родственникам в другой город. У вас есть только их адрес: г. Ржев, ул. Вербовая, 13. Попав в город Ржев, вы открываете Google Карты/Яндекс.Карты и видите, что есть две улицы с названием Вербовая, еще и в противоположных концах города! Какая из них нужна вам? Если у вас нет никакой дополнительной информации (например, вы знаете, что их дом находится возле аптеки или школы), вам придется позвонить им и спросить. Чтобы подобной путаницы не возникало, все названия улиц в городе должны быть уникальными.

Аналогично и в языке C++ все идентификаторы (имена переменных/функций/классов и т.д.) должны быть уникальными. Если в вашей программе находятся два одинаковых идентификатора, то будьте уверены, что ваша программа не скомпилируется: вы получите ошибку конфликта имен.

Пример конфликта имен:

`a.cpp`:
``` cpp
#include <iostream>
 
void doSomething(int x)
{
    std::cout << x;
}
```

`b.cpp`:
``` cpp
#include <iostream>
 
void doSomething(int x)
{
    std::cout << x * 2;
}
```

`main.cpp`:
``` cpp
void doSomething(int x); // предварительное объявление функции doSomething()
 
int main()
{
    doSomething(5);
 
    return 0;
}
```

По отдельности файлы `a.cpp`, `b.cpp` и `main.cpp` скомпилируются. Однако, если `a.cpp` и `b.cpp` разместить в одном проекте — произойдет конфликт имен, так как определение функции `doSomething()` находится сразу в обоих файлах.

Большинство конфликтов имен происходят в двух случаях:

  * Файлы, добавленные в один проект, имеют функцию (или глобальную переменную) с одинаковыми именами (ошибка на этапе линкинга).

  * Файл `.cpp` подключает заголовочный файл, в котором идентификатор конфликтует с идентификатором из файла `.cpp` (ошибка на этапе компиляции).

Как только программы становятся больше, то и идентификаторов используется больше. Следовательно, вероятность возникновения конфликта имен значительно возрастает. Хорошая новость заключается в том, что язык C++ предоставляет достаточно механизмов для предотвращения возникновения конфликтов имен (например, локальная область видимости или пространства имен).

## Пространство имен

В первых версиях языка C++ все идентификаторы из Стандартной библиотеки C++ (такие как `cin`/`cout` и т.д.) можно было использовать напрямую. Тем не менее, это означало, что любой идентификатор из Стандартной библиотеки С++ потенциально мог конфликтовать с именем, которое вы выбрали для ваших собственных идентификаторов. Код, который работал, мог внезапно получить конфликт имен при подключении нового заголовочного файла из Стандартной библиотеки С++. Или, что еще хуже, код, написанный по стандартам одной версии языка С++, мог уже не работать в новой версии языка С++. Чтобы устранить данную проблему, весь функционал Стандартной библиотеки С++ перенесли в специальную область — пространство имен (англ. «namespace»).

Аналогично тому, как город гарантирует, что все улицы в его пределах имеют уникальные названия, так и пространство имен гарантирует, что все его идентификаторы — уникальны.

Таким образом, `std::cout` состоит из двух частей: идентификатор cout и пространство имен `std`. Весь функционал Стандартной библиотеки C++ определен внутри пространства имен `std` (сокр. от «standard»).

Мы еще поговорим о пространствах имен на следующих уроках, а также рассмотрим создание своего собственного пространства имен. Сейчас, главное, что вам нужно запомнить, — это то, что всякий раз, когда вы используете идентификаторы из Стандартной библиотеки С++ (например, `cout`), вы должны сообщать компилятору, что этот идентификатор находится внутри пространства имен `std`.

> ***Правило***: При использовании идентификаторов из пространства имен — указывайте используемое пространство имен.

## Оператор разрешения области видимости `::`
Самый простой способ сообщить компилятору, что определенный идентификатор находится в определенном пространстве имен — использовать оператор разрешения области видимости `::`. Например:
``` cpp
std::cout << "Hello, world!";
```

Здесь мы сообщаем компилятору, что хотим использовать объект cout из пространства имен `std`.

___
# Урок №25. Разработка ваших первых программ

При написании программ, у вас, как правило, есть какая-то проблема, которую нужно решить. Новички очень часто спотыкаются на этапе преобразования идеи решения проблемы в реальный код. Но самое главное, что вам нужно запомнить — разработка программы выполняется перед этапом написания её кода.

Во многих отношениях, программирование — это как архитектура. Что произойдет, если вы попытаетесь построить дом без соблюдения архитектурного плана? Дом может вы и сумеете построить, но какой он будет: кривые стены, протекающая крыша и т.д. Аналогично, если вы начнете программировать что-нибудь серьезное перед тем, как составите план, то очень скоро обнаружите, что ваш код имеет очень много проблем, на решения которых вы потратите гораздо больше времени/усилий/нервов, нежели на изначальное составление хорошего плана.

> ## Оглавление:
> * [Шаг №1: Определите проблему]()
> * [Шаг №2: Определите свой инструментарий, цели и план бэкапа]()
> * [Шаг №3: Разбейте проблему на части]()
> * [Шаг №4: Определите последовательность событий]()
> * [Шаг №5: Определите данные ввода и данные вывода на каждом этапе]()
> * [Шаг №6: Позаботьтесь о деталях]()
> * [Шаг №7: Соедините данные ввода с данными вывода в программе]()
> * [Советы]()

## Шаг №1: Определите проблему
Первое, что вам нужно сделать — это определить проблему, которую решит ваша программа. В идеале, вы должны сформулировать это одним или двумя предложениями. Например:

  * Я хочу написать программу-справочник для удобного хранения и редактирования всех телефонных номеров и звонков.

  * Я хочу написать программу для генерации случайных чисел, с помощью которой можно будет определять победителей разных конкурсов.

  * Я хочу написать программу, которая будет отслеживать и анализировать акции на фондовом рынке для генерации выигрышных прогнозов.

Хотя этот шаг кажется очевидным, но он также очень важен. Самое худшее, что вы можете сделать — это написать программу, которая делает не то, что вам нужно!

## Шаг №2: Определите свой инструментарий, цели и план бэкапа

Для опытных программистов на этом этапе будет еще немало дополнительных пунктов:

  * Какая ваша целевая аудитория и какие у нее потребности?

  * На какой архитектуре/ОС ваша программа будет работать?

  * Какой инструментарий вы будете использовать?

  * Будете ли вы разрабатывать программу в одиночку или в составе команды?

  * Анализ требований.

  * Определение стратегий тестирования/обратной связи/релиза.

  * Создание плана бэкапа в случае неожиданных проблем.

Новички, как правило, большим количеством вопросов не задаются: «Пишу программу для собственного использования, в одиночку, на своей операционной системе, с помощью своей IDE, пользоваться этой программой буду только я». Всё просто.

Если же вы будете работать над чем-нибудь посерьезнее, то стоит еще задуматься о плане бэкапа вашей программы/проекта. Это не просто скопировать код в другую папку ноутбука (хотя это уже лучше, чем ничего). Если ваша ОС «сломается», то вы потеряете все данные. Хорошая стратегия резервного копирования включает в себя создание копии вашего кода вне вашей операционной системы, например:

  * Отправить самому себе E-mail с кодом (прикрепить как файл).

  * Скопировать в Dropbox или в любое другое облако.

  * Перенести на внешнее запоминающее устройство (например, на портативный жёсткий диск).

  * Скопировать на другой компьютер в локальной сети.

  * Воспользоваться системами контроля версий (например, GitHub, GitLab или Bitbucket).


## Шаг №3: Разбейте проблему на части
В реальной жизни нам часто приходится выполнять очень сложные задачи. Понять, как их решить, также бывает очень трудно. В таких случаях можно использовать метод деления на части (или метод «от большого к малому»). То есть, вместо того, чтобы решать одну большую сложную задачу, мы разбиваем её на несколько подзадач, каждую из которых проще решить. Если эти подзадачи все еще слишком сложные, то их также нужно еще раз разбить. И так до тех пор, пока мы не доберемся до точки, где каждая отдельно взятая задача — легко решаема.

Рассмотрим это на примере. Допустим, что нам нужно написать доклад о картошке. Наша иерархия задач в настоящее время выглядит следующим образом:

  * Написать доклад о картошке

Это довольно большая задача, давайте разделим её на подзадачи:

  Написать доклад о картошке

  * Поиск информации о картошке

  * Создание плана

  * Заполнение каждого пункта плана подробной информацией

  * Заключение

Это уже проще, так как теперь мы имеем список подзадач, на которых можем сосредоточиться в индивидуальном порядке. Тем не менее, в данном случае, «Поиск информации о картошке» звучит немного расплывчато, нужно дополнительно разбить и этот пункт:

   Написать доклад о картошке

  * Поиск информации о картошке

  * Сходить в библиотеку за книжками о картошке

  * Поискать информацию в Интернете

  * Делать заметки в соответствующих разделах из справочного материала

  * Создание плана

  * Информация о выращивании

  * Информация об обработке

  * Информация об удобрениях

  * Заполнение каждого пункта плана подробной информацией

  * Заключение

Выполняя каждый подпункт этого задания, мы решим одну большую задачу.

Есть еще один метод создания иерархии — метод «от малого к большому». Рассмотрим на примере.

Большинство из нас вынуждены ходить на работу (школу/университет) по будням. Предположим, что нам нужно решить проблему «от постели к работе». Если бы вас спросили, что вы делаете перед тем, как добраться на работу, вы бы ответили примерно следующее:

  * Выбрать одежду

  * Одеться

  * Позавтракать

  * Ехать на работу

  * Почистить зубы

  * Встать с постели

  * Приготовить завтрак

  * Принять душ

Используя метод «от малого к большому», мы можем сгруппировать задания и создать иерархию:

  От постели к работе

  * **Спальня**:

      * Встать с постели

      * Выбрать одежду

      * Одеться

   * **Ванная**

      * Принять душ

      * Почистить зубы

   * **Завтрак**

      * Сделать завтрак

      * Позавтракать

   * **Транспорт**

      * Ехать на работу

Использование подобных иерархий чрезвычайно полезно в программировании для определения структуры всей программы. Задача верхнего уровня (например, «Написать доклад о картошке» или «От постели к работе») становится функцией main() (так как это основная проблема, которую нужно решить). Подзадачи становятся функциями в программе.

## Шаг №4: Определите последовательность событий

Теперь, когда ваша программа имеет структуру, пришло время ответить на вопрос: «А как же связать все эти пункты вместе?». Первый шаг заключается в определении последовательности событий. Например, когда вы просыпаетесь утром, в какой последовательности вы выполняете вышеперечисленные дела? Скорее всего, в следующей:

  * Встать с постели

  * Выбрать одежду

  * Принять душ

  * Одеться

  * Приготовить завтрак

  * Позавтракать

  * Почистить зубы

  * Ехать на работу

Если бы мы создавали калькулятор, то последовательность заданий выглядела бы следующим образом:

  * Получить первое значение от пользователя

  * Получить математическую операцию от пользователя

  * Получить второе значение от пользователя

  * Вычислить результат

  * Вывести результат

Этот список определяет содержимое функции main():
``` cpp
int main()
{
    getOutOfBed();
    pickOutClothes();
    takeAShower();
    getDressed();
    prepareBreakfast();
    eatBreakfast();
    brushTeeth();
    driveToWork();
}
```
Или, в случае с калькулятором:
``` cpp
int main()
{
    // Получить первое значение от пользователя
    getUserInput();
 
    // Получить математическую операцию от пользователя
    getMathematicalOperation();
 
    // Получить второе значение от пользователя
    getUserInput();
 
    // Вычислить результат
    calculateResult();
 
    // Вывести результат
    printResult();
}
```


## Шаг №5: Определите данные ввода и данные вывода на каждом этапе
После определения иерархии задач и последовательности событий, нам нужно определить, какими будут данные ввода и данные вывода на каждом этапе.

Например, первая функция из вышеприведенного примера — `getUserInput()`, довольно проста. Мы собираемся получить число от пользователя и вернуть его обратно в `caller`. Таким образом, прототип функции будет выглядеть следующим образом:
``` cpp
int getUserInput();
```

В примере с калькулятором, функции `calculateResult()` требуется 3 ввода данных: два числа и 1 математический оператор. При вызове `calculateResult()` у нас уже должны быть 3 фрагмента данных, которые мы будем использовать в качестве параметров функции. Функция `calculateResult()` вычисляет значение результата, но не выводит его. Следовательно, нам необходимо вернуть этот результат в качестве возвращаемого значения обратно в `caller`, чтобы другие функции также имели возможность его использовать.

Учитывая это, прототип функции становится следующим:
``` cpp
int calculateResult(int input1, int op, int input2);
```

## Шаг №6: Позаботьтесь о деталях

На этом этапе нам нужно реализовать каждый подпункт из нашей иерархии задач. Если вы разбили задание на достаточно мелкие кусочки, то выполнить каждый из этих кусочков будет несложно. Например:
``` cpp
int getMathematicalOperation()
{
    std::cout << "Please enter which operator you want (1 = +, 2 = -, 3 = *, 4 = /): ";
 
    int op;
    std::cin >> op;
 
    // А что, если пользователь введет некорректный символ?
    // Пока что мы это проигнорируем
 
    return op;
}
```

## Шаг №7: Соедините данные ввода с данными вывода в программе
И, наконец, последний шаг — это соединение данных ввода с данными вывода. Например, вы можете отправить выходные данные функции calculateResult() во входные данные функции printResult(), чтобы вторая функция могла вывести результат. Чаще всего в таких случаях используются промежуточные переменные для временного хранения результата и его перемещения между функциями. Например:
``` cpp
// Переменная result - это промежуточная переменная, которая используется для передачи выходного значения функции calculateResult() во входные данные функции printResult()
int result = calculateResult(input1, op, input2);
printResult(result);
```
Согласитесь, что вариант, приведенный выше, читабельнее варианта без использования временных переменных (см. ниже):
``` cpp
printResult(calculateResult(input1, op, input2));
```
Рассмотрим готовую версию программы-калькулятора, её структуру и перемещение данных:
```
#include <iostream>
 
int getUserInput()
{
    std::cout << "Please enter an integer: ";
    int value;
    std::cin >> value;
    return value;
}

int getMathematicalOperation()
{
    std::cout << "Please enter which operator you want (1 = +, 2 = -, 3 = *, 4 = /): ";
 
    int op;
    std::cin >> op;
 
    // А что, если пользователь введет некорректный символ?
    // Пока что мы это проигнорируем
 
    return op;
}
 
int calculateResult(int x, int op, int y)
{
    // Обратите внимание, оператор == используется для сравнения двух значений
 
    if (op == 1) // если пользователь выбрал операцию сложения (№1)
        return x + y; // то выполняем эту строку
    if (op == 2) // если пользователь выбрал операцию вычитания (№2)
        return x - y; // то выполняем эту строку
    if (op == 3) // если пользователь выбрал операцию умножения (№3)
        return x * y; // то выполняем эту строку
    if (op == 4) // если пользователь выбрал операцию деления (№4)
        return x / y; // то выполняем эту строку
	
    return -1; // вариант, если пользователь ввел некорректный символ
}
 
void printResult(int result)
{
    std::cout << "Your result is: " << result << std::endl;
}
 
int main()
{
    // Получаем первое значение от пользователя
    int input1 = getUserInput();
 
    // Получаем математическую операцию от пользователя
    int op = getMathematicalOperation();
 
    // Получаем второе значение от пользователя
    int input2 = getUserInput();
 
    // Вычисляем результат и сохраняем его во временной переменной
    int result = calculateResult(input1, op, input2 );
 
    // Выводим результат
    printResult(result);
}
```

Здесь есть несколько концепций, которые мы еще не рассматривали: условное ветвление `if` и использование оператора равенства `==` для сравнения двух элементов. Не беспокойтесь, если вы это не понимаете — мы всё это детально рассмотрим на следующих уроках.

## Советы

**Пускай ваши первые программы будут простыми**. Очень часто новички ставят слишком высокие планки для своих первых более-менее серьезных программ. Например, «Я хочу написать игру с графикой, звуком, монстрами, подземельями и городом, в котором можно будет продавать найденные вещи». Если вы попытаетесь написать что-нибудь подобное в начале вашего пути как программиста, то очень скоро у вас пропадет любое желание программировать. Вместо этого, пускай ваши первые цели/задания/программы будут попроще, например, «Я хочу написать программу, которая отображала бы 2D-поле на экране».

**Добавляйте новый функционал со временем**. Как только вы написали простенькую программу, которая работает (даже без сбоев), то следующим вашим шагом должно стать добавление нового функционала. Например, когда вы сможете отображать 2D-поле на экране — добавьте персонажа, который сможет ходить по этому полю. После того, как вы уже сможете ходить — добавьте стены, которые будут препятствовать вашему движению. После того, как у вас будут стены — постройте из них город. После того, как у вас будет город — добавьте персонажей-продавцов. При таком подходе на вас не наваливается всё сразу и вы знаете с чего начинать, что делать дальше, в какой последовательности и т.д.

**Фокусируйтесь только на одном задании в определенный промежуток времени**. Не пытайтесь сделать всё и сразу, не распыляйтесь на несколько задач одновременно. Сосредоточьтесь на одном. Лучше иметь одно выполненное задание и пять невыполненных, нежели шесть частично выполненных заданий. Если вы рассеиваете свое внимание в нескольких направлениях, то и ошибок будет много.

**Тестируйте каждую новую часть кода**. Начинающие программисты часто пишут программу за один присест. Затем, при компиляции проекта, получают сотни ошибок. Поэтому, после написания определенной части кода — сразу компилируйте и тестируйте её. Если ваш код не будет работать, то вы будете знать, где находится проблема, и исправить её будет намного легче. Как только вы убедились, что ваш код рабочий — переходите к написанию следующей части, а затем repeat. Тестирование может занять больше времени, но в конечном итоге ваш код будет работать так, как вам нужно.

Большинство новичков пропустят некоторые из этих шагов и советов, так как это не столь захватывающе, как, собственно, сам процесс кодинга. Хорошая новость заключается в том, что как только вы освоите все эти концепции — они станут для вас естественными в процессе разработки ваших программных продуктов.

___
# Урок №26. Отладка программ: степпинг и точки останова

Как ни странно, программирование может быть сложным и ошибок может быть очень много. Ошибки, как правило, попадают в одну из двух категорий: синтаксические или семантические/смысловые.

> ## Оглавление:
> * [Типы ошибок]()
> * [Отладчик]()
> * [Степпинг]()
> * [Команда «Шаг с заходом»]()
> * [Команда «Шаг с обходом»]()
> * [Команда «Шаг с выходом»]()
> * [Команда «Выполнить до текущей позиции»]()
> * [Команда «Продолжить»]()
> * [Точки останова]()

## Типы ошибок
Синтаксическая ошибка возникает, когда вы пишете код, который не соответствует правилам грамматики языка C++. Например, пропущенные точки с запятой, необъявленные переменные, непарные круглые или фигурные скобки и т.д. В следующей программе есть несколько синтаксических ошибок:
``` cpp
#include <iostream>; // директивы препроцессора не заканчиваются точкой с запятой
 
int main()
{
    std:cout < "Hi there; << x; // недействительный оператор (:), незаконченное предложение (пропущено ") и необъявленная переменная
    return 0 // пропущена точка с запятой в конце стейтмента
}
```

К счастью, компилятор ловит подобные ошибки и сообщает о них в виде предупреждений или ошибок.

Семантическая ошибка возникает, когда код является синтаксически правильным, но делает не то, что задумал программист.

Иногда это может привести к сбою в программе, например, если делить на ноль:
``` cpp
#include <iostream>
 
int main()
{
    int a = 10;
    int b = 0;
    std::cout << a << " / " << b << " = " << a / b; // делить на 0 нельзя
    return 0;
}
```

Иногда это может привести к неверным результатам:
``` cpp
#include <iostream>
 
int main()
{
    std::cout << "Hello, word!"; // орфографическая ошибка
    return 0;
}
```

Либо делать вообще не то, что нужно:
``` cpp
#include <iostream>
 
int add(int x, int y)
{
    return x - y; // функция должна выполнять сложение, но выполняет вычитание
}
 
int main()
{
    std::cout << add(5, 3); // должно быть 8, но результат - 2
    return 0;
}
```

К сожалению, компилятор не ловит подобные ошибки, так как он проверяет только то, что вы написали, а не то, что вы хотели этим сделать.

В примерах, приведенных выше, ошибки довольно легко обнаружить. Но в большинстве программ (в которых больше 40 строк кода), семантические ошибки увидеть с помощью простого просмотра кода будет не так-то и легко.

И здесь нам на помощь приходит отладчик.

## Отладчик

Отладчик (или «дебаггер», от англ. «debugger») — это компьютерная программа, которая позволяет программисту контролировать выполнение кода. Например, программист может использовать отладчик для выполнения программы пошагово, последовательно изучая значения переменных в программе.

Более ранние дебаггеры, такие как GDB, имели интерфейс командной строки, где программисту приходилось вводить специальные команды для старта работы. Более современные дебаггеры уже имеют «графический» интерфейс, что значительно упрощает работу с ними. Сейчас почти все современные IDE имеют встроенные отладчики. То есть, вы можете использовать одну среду разработки как для написания кода, так и для его отладки (вместо постоянного переключения между разными программами).

Базовый функционал у всех отладчиков один и тот же. Отличаются они, как правило, тем, как этот функционал и доступ к нему организованы, горячими клавишами и дополнительными возможностями.

> ***Примечание***: Перед тем как продолжить, убедитесь, что вы находитесь в режиме конфигурации «Debug». Все скриншоты данного урока выполнены в Visual Studio 2019.


## Степпинг
**Степпинг** (англ. «stepping») — это возможность отладчика выполнять код пошагово (строка за строкой). Есть три команды степпинга:

  * Команда `"Шаг с заходом"`

  * Команда `"Шаг с обходом"`

  * Команда `"Шаг с выходом"`

Мы сейчас рассмотрим каждую из этих команд в индивидуальном порядке.

## Команда «Шаг с заходом»

Команда «Шаг с заходом» (англ. «Step into») выполняет следующую строку кода. Если этой строкой является вызов функции, то «Шаг с заходом» открывает функцию и выполнение переносится в начало этой функции.

Давайте рассмотрим очень простую программу:
``` cpp
#include <iostream>
 
void printValue(int nValue)
{
    std::cout << nValue;
}
 
int main()
{
    printValue(5);
    return 0;
}
```

Как вы уже знаете, при запуске программы выполнение начинается с вызова главной функции `main()`. Так как мы хотим выполнить отладку внутри функции `main()`, то давайте начнем с использования команды «Шаг с заходом».

В Visual Studio, перейдите в меню `"Отладка" > "Шаг с заходом"` (либо нажмите `F11`):

![](https://ravesli.com/wp-content/uploads/2016/12/1.png)

Если вы используете другую IDE, то найдите в меню команду `"Step Into/Шаг с заходом"` и выберите её.

Когда вы это сделаете, должны произойти две вещи. Во-первых, так как наше приложение является консольной программой, то должно открыться консольное окно. Оно будет пустым, так как мы еще ничего не выводили. Во-вторых, вы должны увидеть специальный маркер слева возле открывающей скобки функции `main()`. В Visual Studio этим маркером является жёлтая стрелочка (если вы используете другую IDE, то должно появиться что-нибудь похожее):

![](https://ravesli.com/wp-content/uploads/2016/12/2.png)

Стрелка-маркер указывает на следующую строку, которая будет выполняться. В этом случае отладчик говорит нам, что следующей строкой, которая будет выполняться, — будет открывающая фигурная скобка функции `main()`. Выберите «Шаг с заходом» еще раз — стрелка переместится на следующую строку:

![](https://ravesli.com/wp-content/uploads/2016/12/3.png)

Это значит, что следующей строкой, которая будет выполняться, — будет вызов функции `printValue()`. Выберите «Шаг с заходом» еще раз. Поскольку `printValue()` — это вызов функции, то мы переместимся в начало функции `printValue()`:

![](https://ravesli.com/wp-content/uploads/2016/12/4.png)

Выберите еще раз «Шаг с заходом» для выполнения открывающей фигурной скобки `printValue()`. Стрелка будет указывать на `std::cout << nValue`;.

Теперь выберите «Шаг с обходом» (`F10`). Вы увидите число 5 в консольном окне.

Выберите «`Шаг с заходом`» еще раз для выполнения закрывающей фигурной скобки `printValue()`. Функция `printValue()` завершит свое выполнение и стрелка переместиться в функцию `main()`. Обратите внимание, в `main()` стрелка снова будет указывать на вызов `printValue()`:

![](https://ravesli.com/wp-content/uploads/2016/12/5.png)

Может показаться, будто отладчик намеревается еще раз повторить цикл с функцией `printValue()`, но в действительности он нам просто сообщает, что он только что вернулся из этой функции.

Выберите «Шаг с заходом» два раза. Готово, все строки кода выполнены. Некоторые дебаггеры автоматически прекращают сеанс отладки в этой точке. Но Visual Studio так не делает, так что если вы используете Visual Studio, то выберите `"Отладка" > "Остановить отладку"` (или `Shift+F5`):

![](https://ravesli.com/wp-content/uploads/2016/12/6.png)

Таким образом мы полностью остановили сеанс отладки нашей программы.

## Команда «Шаг с обходом»
Как и команда «Шаг с заходом», команда «Шаг с обходом» (англ. «Step over») позволяет выполнить следующую строку кода. Только если этой строкой является вызов функции, то «Шаг с обходом» выполнит весь код функции в одно нажатие и возвратит нам контроль после того, как функция будет выполнена.

> **Примечание для пользователей Code::Blocks**: Команда «`Step over`» называется «`Next Line`».

Рассмотрим пример, используя следующую программу:

``` cpp
#include <iostream>
 
void printValue(int nValue)
{
    std::cout << nValue;
}
 
int main()
{
    printValue(5);
    return 0;
}
```
Нажмите «Шаг с заходом», чтобы дойти до вызова функции `printValue()`:

![](https://ravesli.com/wp-content/uploads/2016/12/10-1.png)

Теперь вместо команды «`Шаг с заходом`» выберите «`Шаг с обходом`» (или `F10`):

![](https://ravesli.com/wp-content/uploads/2016/12/7.png)

Отладчик выполнит функцию (которая выведет значение 5 в консоль), а затем возвратит нам управление на строке `return 0;`. И это всё за одно нажатие.

Команда «Шаг с обходом» позволяет быстро пропустить код функций, когда мы уверены, что они работают корректно и их не нужно отлаживать.

## Команда «Шаг с выходом»

В отличие от двух предыдущих команд, команда «Шаг с выходом» (англ. «Step out») не просто выполняет следующую строку кода. Она выполняет весь оставшийся код функции, в которой вы сейчас находитесь, и возвращает контроль только после того, когда функция завершит свое выполнение. Проще говоря, «Шаг с выходом» позволяет выйти из функции.

Обратите внимание, команда «Шаг с выходом» появится в меню «Отладка» только после начала сеанса отладки (что делается путем использования одной из двух вышеприведенных команд).

Рассмотрим все тот же пример:
``` cpp
#include <iostream>
 
void printValue(int nValue)
{
    std::cout << nValue;
}
 
int main()
{
    printValue(5);
    return 0;
}
```

Нажимайте «Шаг с заходом» до тех пор, пока не перейдете к открывающей фигурной скобке функции printValue():

![](https://ravesli.com/wp-content/uploads/2016/12/8.png)

Затем выберите `"Отладка" > "Шаг с выходом"` (либо `Shift+F11`):

![](https://ravesli.com/wp-content/uploads/2016/12/9.png)

Вы заметите, что значение 5 отобразилось в консольном окне, а отладчик перешел к вызову функции `printValue()` в `main()`:

![](https://ravesli.com/wp-content/uploads/2016/12/10-1.png)


## Команда «Выполнить до текущей позиции»
В то время как степпинг полезен для изучения каждой строки кода по отдельности, в большой программе перемещаться по коду с помощью этих команд будет не очень удобно.

Но и здесь современные отладчики предлагают еще несколько инструментов для эффективной отладки программ.

Команда «Выполнить до текущей позиции» позволяет в одно нажатие выполнить весь код до строки, обозначенной курсором. Затем контроль обратно возвращается к вам, и вы можете проводить отладку с указанной точки уже более детально. Давайте попробуем, используя уже знакомую нам программу:
``` cpp
#include <iostream>
 
void printValue(int nValue)
{
    std::cout << nValue;
}
 
int main()
{
    printValue(5);
    return 0;
}
```

Поместите курсор на строку `std::cout << nValue;` внутри функции `printValue()`, затем щелкните правой кнопкой мыши и выберите "Выполнить до текущей позиции" (либо `Ctrl+F10`):

![](https://ravesli.com/wp-content/uploads/2016/12/11.png)

Вы заметите, что жёлтая стрелочка переместится на указанную вами строку. Выполнение программы остановится в этой точке, и программа будет ждать ваших дальнейших команд.

## Команда «`Продолжить`»

Если вы находитесь в середине сеанса отладки вашей программы, то вы можете сообщить отладчику продолжать выполнение кода до тех пор, пока он не дойдет до конца программы (или до следующей контрольной точки). В Visual Studio эта команда называется «`Продолжить`» (англ. «Continue»). В других дебаггерах она может иметь название «`Run`» или «`Go`».

Возвращаясь к вышеприведенному примеру, мы находимся как раз внутри функции printValue(). Выберите "Отладка" > "Продолжить" (или `F5`):

![https://ravesli.com/wp-content/uploads/2016/12/11.png]()

Программа завершит свое выполнение и выйдет из сеанса отладки.

## Точки останова
Точки останова (англ. «breakpoints») — это специальные маркеры, на которых отладчик останавливает процесс выполнения программы.

Чтобы задать точку останова в Visual Studio, щелкните правой кнопкой мыши по выбранной строке > "Точка останова" > "Вставить точку останова":

![](https://ravesli.com/wp-content/uploads/2016/12/13.png)

Появится кружочек возле строки:

![](https://ravesli.com/wp-content/uploads/2016/12/14-1.png)

В программе, приведенной выше, создайте точку останова на строке std::cout << nValue;. Затем выберите «Шаг с заходом» для старта сеанса отладки, а затем «Продолжить». Вы увидите, что вместо завершения выполнения программы и остановки сеанса отладки, отладчик остановится в указанной вами точке:

![](https://ravesli.com/wp-content/uploads/2016/12/15.png)

Точки останова чрезвычайно полезны, если вы хотите изучить только определенную часть кода. Просто задайте точку останова в выбранном участке кода, выберите команду «Продолжить» и отладчик автоматически остановится возле указанной строки. Затем вы сможете использовать команды степпинга для более детального просмотра/изучения кода.

___
# Урок №27. Отладка программ: стек вызовов и отслеживание переменных

На предыдущем уроке о степпинге и точках останова, мы узнали, как, с их использованием, контролировать выполнение программы шаг за шагом. Тем не менее, на этом не заканчиваются все полезные возможности отладчика. Он также позволяет отслеживать значения переменных.

> ***Примечание***: Перед тем как продолжить, убедитесь, что вы находитесь в режиме конфигурации «Debug».

> ## Оглавление:
> * [Отслеживание переменных]()
> * [Окно просмотра]()
> * [Стек вызовов]()
> * [Заключение]()

## Отслеживание переменных
**Отслеживание переменных** — это процесс проверки значений переменных во время отладки. Например:
``` cpp
#include <iostream>
 
int main()
{
    int x = 1;
    std::cout << x << " ";
 
    x = x + 1;
    std::cout << x << " ";
 
    x = x + 2;
    std::cout << x << " ";
 
    x = x + 4;
    std::cout << x << " ";
 
    return 0;
}
```

Результат выполнения программы:

`1 2 4 8`

Используя команду «Выполнить до текущей позиции» переместитесь к строке `std::cout << x << " ";`:

![](https://ravesli.com/wp-content/uploads/2016/12/1-1.png)

К этому моменту переменная `х` уже создана и инициализирована, поэтому, при проверке этой переменной, вы должны увидеть число `1`.

Самый простой способ отслеживания простых переменных (как `х`) — это наведение курсора мыши на элемент. Большинство современных отладчиков поддерживают эту возможность:

![](https://ravesli.com/wp-content/uploads/2016/12/2-1.png)

Обратите внимание, вы можете навести курсор мыши на любую другую переменную (и на любой строке):

![](https://ravesli.com/wp-content/uploads/2016/12/3-1.png)

В Visual Studio есть еще возможность использовать «Быструю проверку». Выделите переменную `х` с помощью мыши > ПКМ (правая кнопка мыши) > `"Быстрая проверка..."`:

![](https://ravesli.com/wp-content/uploads/2016/12/4-1.png)

Появится специальное окно с текущим значением переменной:

![](https://ravesli.com/wp-content/uploads/2016/12/5-1.png)

Хорошо, теперь закройте это окно.

Значения переменных можно отслеживать и во время выполнения отладки. Переместитесь с помощью команды «`Шаг с обходом`» к строке `std::cout << x << " ";`:

![](https://ravesli.com/wp-content/uploads/2016/12/6-1.png)

Значение переменной х должно поменяться на 2. Проверьте!

## Окно просмотра

Команда «Быстрая проверка» или наведение курсора на элемент подходят для статического просмотра переменных, но не очень подходят для отслеживания изменений переменной во время выполнения программы, так как с каждой новой выполненной строкой придется заново наводить курсор на элемент или использовать «Быструю проверку».

Для решения этой проблемы, все современные отладчики предлагают еще один инструмент — окно просмотра. Окно просмотра — это окно, в которое можно добавлять переменные для постоянного отслеживания. Данные переменные будут автоматически обновляться при последовательном выполнении программы. Окно просмотра уже может быть подключено и отображаться в вашей рабочей области, но если это не так, то вы можете это исправить, перейдя в настройки вашей IDE.

В Visual Studio для отображения окна просмотра вам нужно перейти в `"Отладка" > "Окна" > "Контрольные значения" > "Контрольные значения 1"`:

![](https://ravesli.com/wp-content/uploads/2016/12/7-1.png)

> ***Примечание***: Вы должны находиться в режиме отладки — используйте для этого команду «Шаг с заходом».

Вы должны увидеть следующее:

![](https://ravesli.com/wp-content/uploads/2016/12/8-1.png)

Пока что в этом окне ничего нет, так как вы еще ничего в него не добавили. Есть 2 пути:

  * Ввести имя переменной, которую нужно отслеживать, в колонку "Имя" в окне просмотра.

  * Выделить переменную, которую нужно отслеживать > ПКМ > "Добавить контрольное значение".

Попробуйте добавить переменную `х` в окно просмотра:

![](https://ravesli.com/wp-content/uploads/2016/12/9-1.png)

Теперь выберите команду «`Шаг с обходом`» несколько раз и следите за изменениями значения вашей переменной!

## Стек вызовов
Современные отладчики имеют еще одно информационное окно, которое может быть очень полезным при отладке программ — «`Стек вызовов`».

Как вы уже знаете, при вызове функции программа оставляет закладку в текущем местоположении, выполняет функцию, а затем возвращается в место закладки. Программа отслеживает все вызовы функций в стеке вызовов.

**Стек вызовов** — это список всех активных функций, которые вызывались до текущего местоположения. В стек вызовов записывается вызываемая функция и выполняемая строка. Всякий раз, когда происходит вызов новой функции, эта новая функция добавляется в верх стека. Когда выполнение текущей функции прекращается, она удаляется из верхней части стека и управление переходит к функции ниже (второй по счету).

Отобразить окно «`Стека вызовов`» в Visual Studio можно через `"Отладка" > "Окна"> "Стек вызовов"`:

![](https://ravesli.com/wp-content/uploads/2016/12/10.png)

Примечание: Вы должны находиться в режиме отладки — используйте для этого команду «Шаг с заходом».

Рассмотрим пример:
``` cpp
#include <iostream>
 
void CallC()
{
	std::cout << "C called" << std::endl;
}
 
void CallB()
{
	std::cout << "B called" << std::endl;
	CallC();
}
 
void CallA()
{
	CallB();
	CallC();
}
 
int main()
{
	CallA();
 
    return 0;
}
```

Укажите точку останова в функции `CallC()`, а затем запустите отладку. Программа выполнится до точки останова.

Несмотря на то, что вы знаете, что сейчас выполняется `CallC()`, в программе есть два вызова `CallC()`: в функции `CallB()` и в функции `CallA()`. Какая функция ответственна за вызов `CallC()` в данный момент? Стек вызовов нам это покажет:

![](https://ravesli.com/wp-content/uploads/2016/12/11-1.png)

Сначала выполняется `main()`. Затем `main()` вызывает `CallA()`, которая, в свою очередь, вызывает `CallB()`. Функция `CallB()` вызывает `CallC()`. Вы можете щелкнуть дважды по разным строкам в окне «`Стек вызовов`», чтобы увидеть больше информации о вызываемых функциях. Некоторые IDE переносят курсор непосредственно к вызову указанной функции. Visual Studio переносит курсор к следующей строке, которая находится после вызова функции. Попробуйте! Для того, чтобы возобновить степпинг, щелкните дважды по самой верхней (первой) строке в окне «Стек вызовов» и вы вернетесь к текущей точке выполнения.

Выберите команду «`Продолжить`». Точка останова должна сработать во второй раз, когда будет повторный вызов функции `CallC()` (на этот раз из функции `CallA()`). Всё происходящее вы должны увидеть в окне «Стек вызовов»:

![](https://ravesli.com/wp-content/uploads/2016/12/12-1.png)

## Заключение

Теперь вы знаете об основных возможностях встроенных отладчиков! Используя степпинг, точки останова, отслеживание переменных и окно «`Стек вызовов`» вы можете успешно проводить отладку программ.

___
# *Глава №1*. Итоговый тест

Данные задания призваны улучшить запоминание пройденного материала и показать его применение на практике.

> ## Оглавление:
> * [Задание №1]()
> * [Задание №2]()
> * [Задание №3]()

## Задание №1
Напишите однофайловую программу (с именем main.cpp), которая запрашивает у пользователя два целых числа, складывает их, а затем выводит результат. В программе должно быть 3 функции:

  * функция `readNumber()`, которая запрашивает у пользователя целое число, а затем возвращает его в `main()`;

  * функция `writeAnswer()`, которая выводит результат на экран. Функция должна быть без возвращаемого значения и иметь только один параметр;

  * функция `main()`, которая соединяет всё и вся.

Подсказки:

  * Для выполнения операции сложения не нужно создавать отдельную функцию (просто используйте оператор `+`).

  * Функцию `readNumber()` нужно вызывать дважды.

**Ответ №1**

`main.cpp`:

``` cpp
#include <iostream>
 
int readNumber()
{
    std::cout << "Enter a number: ";
    int x;
    std::cin >> x;
    return x;
}
 
void writeAnswer(int x)
{
    std::cout << "The answer is " << x << std::endl;
}
 
int main()
{
    int x = readNumber();
    int y = readNumber();
    writeAnswer(x + y); // передаем результат в функцию writeAnswer()
    return 0;
}
```

## Задание №2
Измените программу из задания *№1* так, чтобы функции `readNumber()` и `writeAnswer()` находились в отдельном файле `io.cpp`. Используйте предварительные объявления для доступа к этим функциям с функции `main()`.

> ***Подсказка***: Если у вас возникли проблемы, убедитесь, что io.cpp правильно добавлен к вашему проекту и подключен к компиляции (см. [Урок №20](). Многофайловые программы).

**Ответ №2**

`io.cpp`:

``` cpp
#include <iostream>
 
int readNumber()
{
    std::cout << "Enter a number: ";
    int x;
    std::cin >> x;
    return x;
}
 
void writeAnswer(int x)
{
    std::cout << "The answer is " << x << std::endl;
}
```
`main.cpp`:
``` cpp
// Это предварительные объявления функций, которые находятся в файле io.cpp
int readNumber();
void writeAnswer(int x);
 
int main()
{
    int x = readNumber();
    int y = readNumber();
    writeAnswer(x+y);
    return 0;
}
```



## Задание №3
Измените программу из задания №2 так, чтобы она использовала заголовочный файл io.h для доступа к функциям (вместо использования предварительных объявлений). Убедитесь, что ваш заголовочный файл использует header guards.

**Ответ №3**

`io.cpp`:
``` cpp
#include <iostream>
 
int readNumber()
{
    std::cout << "Enter a number: ";
    int x;
    std::cin >> x;
    return x;
}
 
void writeAnswer(int x)
{
    std::cout << "The answer is " << x << std::endl;
}
```

`io.h`:
``` cpp
#ifndef IO_H
#define IO_H
 
int readNumber();
void writeAnswer(int x);
 
#endif
```

`main.cpp`:
``` cpp
#include "io.h"
 
int main()
{
    int x = readNumber();
    int y = readNumber();
    writeAnswer(x+y);
    return 0;
}
```

___
___
# **Глава №4. Область видимости и другие типы переменных в C++**
___
# Урок №28. Инициализация, присваивание и объявление переменных

Этот урок является более детальным продолжением урока *№10*.

> ## Оглавление:
> * [Адреса и переменные]()
> * [Фундаментальные типы данных в С++]()
> * [Объявление переменных]()
> * [Инициализация переменных]()
> * [uniform-инициализация]()
> * [Присваивание переменных]()
> * [Объявление нескольких переменных]()
> * [Где объявлять переменные?]()

## Адреса и переменные
Как вы уже знаете, переменные — это имена кусочков памяти, которые могут хранить информацию. Помним, что компьютеры имеют оперативную память, которая доступна программам для использования. Когда мы определяем переменную, часть этой памяти отводится ей.

Наименьшая единица памяти — **бит** (англ. "**bit**" от «binary digit»), который может содержать либо значение **`0`**, либо значение **`1`**. Вы можете думать о бите, как о переключателе света — либо свет выключен (`0`), либо включен (`1`). Чего-то среднего между ними нет. Если просмотреть случайный кусочек памяти, то всё, что вы увидите, — будет `...011010100101010...` или что-то в этом роде. Память организована в последовательные части, каждая из которых имеет свой адрес. Подобно тому, как мы используем адреса в реальной жизни, чтобы найти определенный дом на улице, так и здесь: адреса позволяют найти и получить доступ к содержимому, которое находится в определенном месте памяти. Возможно, это удивит вас, но в современных компьютерах, у каждого бита по отдельности нет своего собственного адреса. Наименьшей единицей с адресом является байт (который состоит из 8 битов).

Поскольку все данные компьютера — это лишь последовательность битов, то мы используем тип данных (или просто «тип»), чтобы сообщить компилятору, как интерпретировать содержимое памяти. Вы уже видели пример типа данных: `int` (целочисленный тип данных). Когда мы объявляем целочисленную переменную, то мы сообщаем компилятору, что «кусочек памяти, который находится по такому-то адресу, следует интерпретировать как целое число».

Когда вы указываете тип данных для переменной, то компилятор и процессор заботятся о деталях преобразования вашего значения в соответствующую последовательность бит определенного типа данных. Когда вы просите ваше значение обратно, то оно «восстанавливается» из этой же последовательности бит.

Кроме `int`, есть много других типов данных в языке C++, большинство из которых мы детально рассмотрим на соответствующих уроках.

Фундаментальные типы данных в С++

В языке C++ есть встроенная поддержка определенных типов данных. Их называют основными типами данных (или «фундаментальные/базовые/встроенные типы данных»).

Вот список основных типов данных в языке C++:

<table class="tabluc" style="margin-bottom: 15px;"><tbody><tr><td><strong><span class="raznui_kolir_td">Категория</span></strong></td><td><strong><span class="raznui_kolir_td">Тип</span></strong></td><td><strong><span class="raznui_kolir_td">Значение</span></strong></td><td><strong><span class="raznui_kolir_td">Пример</span></strong></td></tr><tr><td>Логический тип данных</td><td>bool</td><td>true или false</td><td>true</td></tr><tr><td>Символьный тип данных</td><td>char, wchar_t, char16_t, char32_t</td><td>Один из ASCII-символов</td><td>‘c’</td></tr><tr><td>Тип данных с плавающей запятой</td><td>float, double, long double</td><td>Десятичная дробь</td><td>3.14159</td></tr><tr><td>Целочисленный тип данных</td><td>short, int, long, long long</td><td>Целое число</td><td>64</td></tr><tr><td>Пустота</td><td>void</td><td>Пустота</td><td></td></tr></tbody></table>

## Объявление переменных
Вы уже знаете, как объявить целочисленную переменную:
``` cpp
int nVarName; // int - это тип, а nVarName - это имя переменной
```

Принцип объявления переменных других типов аналогичен:
``` cpp
type varName; // type - это тип (например, int), а varName - это имя переменной
```

Объявление пяти переменных разных типов:

``` cpp
bool bValue;
char chValue;
int nValue;
float fValue;
double dValue;
```

Обратите внимание, переменной типа void здесь нет (о типе void мы поговорим детально на следующем уроке).

``` cpp
void vValue; // не будет работать, так как void не может использоваться в качестве типа переменной
```




















